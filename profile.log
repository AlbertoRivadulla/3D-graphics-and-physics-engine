SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-doge/ftplugin/cpp.vim
Sourced 3 times
Total time:   0.006276
 Self time:   0.001328

count  total (s)   self (s)
                            " ==============================================================================
                            " The C++ documentation should follow the 'Doxygen' conventions.
                            " see http://www.doxygen.nl/manual/docblocks.html
                            " ==============================================================================
                            
    3              0.000018 let s:save_cpo = &cpoptions
    3              0.000017 set cpoptions&vim
                            
    3              0.000006 let b:doge_parser = 'cpp'
    3              0.000004 let b:doge_insert = 'above'
                            
    3   0.000197   0.000056 let b:doge_supported_doc_standards = doge#buffer#get_supported_doc_standards([
                                  \ 'doxygen_javadoc',
                                  \ 'doxygen_javadoc_no_asterisk',
                                  \ 'doxygen_javadoc_banner',
                                  \ 'doxygen_qt',
                                  \ 'doxygen_qt_no_asterisk',
                                  \ ])
    3   0.000065   0.000031 let b:doge_doc_standard = doge#buffer#get_doc_standard('cpp')
    3   0.000036   0.000021 let b:doge_patterns = doge#buffer#get_patterns()
                            
                            " ==============================================================================
                            "
                            " Define our base for every pattern.
                            "
                            " ==============================================================================
    3              0.000027 let s:pattern_base = {
                            \  'parameters': {
                            \    'format': '@param {name} !description',
                            \  },
                            \  'typeParameters': {
                            \    'format': '@tparam {name} !description',
                            \  },
                            \}
                            
                            " ==============================================================================
                            "
                            " Define the pattern types.
                            "
                            " ==============================================================================
                            
                            " ------------------------------------------------------------------------------
                            " Matches classes.
                            " ------------------------------------------------------------------------------
    3   0.000340   0.000057 let s:class_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'nodeTypes': ['class_specifier', 'template_declaration'],
                            \})
    3              0.000010 unlet s:class_pattern['parameters']
                            
                            " ------------------------------------------------------------------------------
                            " Matches (template) function- and class method declarations.
                            " ------------------------------------------------------------------------------
    3   0.000308   0.000053 let s:function_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'nodeTypes': [
                            \    'function_definition',
                            \    'declaration',
                            \    'template_declaration',
                            \    'function_declarator',
                            \  ],
                            \})
                            
                            " ------------------------------------------------------------------------------
                            " Matches structs.
                            " ------------------------------------------------------------------------------
    3   0.000293   0.000046 let s:struct_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'nodeTypes': ['struct_specifier', 'template_declaration'],
                            \})
    3              0.000009 unlet s:struct_pattern['parameters']
                            
                            " ------------------------------------------------------------------------------
                            " Matches field declarations inside structs.
                            " ------------------------------------------------------------------------------
    3   0.000346   0.000045 let s:field_pattern = doge#helpers#deepextend(s:pattern_base, {
                            \  'nodeTypes': ['field_declaration'],
                            \  'template': [
                            \    '/**',
                            \    ' * @{name} !description',
                            \    ' */',
                            \  ],
                            \})
    3              0.000008 unlet s:field_pattern['parameters']
    3              0.000006 unlet s:field_pattern['typeParameters']
                            
                            " ==============================================================================
                            "
                            " Define the doc standards.
                            "
                            " ==============================================================================
                            
    3   0.000923   0.000164 call doge#buffer#register_doc_standard('doxygen_javadoc', [
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * @brief !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * struct {name} - !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
    3   0.000902   0.000163 call doge#buffer#register_doc_standard('doxygen_javadoc_no_asterisk', [
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/**',
                            \      '@brief !description',
                            \      '%(typeParameters|)%',
                            \      '%(typeParameters|{typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      '@brief !description',
                            \      '',
                            \      '%(typeParameters|{typeParameters})%',
                            \      '%(parameters|{parameters})%',
                            \      '%(returnType|@return !description)%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/**',
                            \      'struct {name} - !description',
                            \      '%(typeParameters|)%',
                            \      '%(typeParameters|{typeParameters})%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
    3   0.000907   0.000173 call doge#buffer#register_doc_standard('doxygen_javadoc_banner', [
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/*******************************************************************************',
                            \      ' * @brief !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' ******************************************************************************/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*******************************************************************************',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' ******************************************************************************/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*******************************************************************************',
                            \      ' * struct {name} - !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' ******************************************************************************/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
    3   0.000900   0.000154 call doge#buffer#register_doc_standard('doxygen_qt', [
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      ' * @brief !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      ' * struct {name} - !description',
                            \      '%(typeParameters| *)%',
                            \      '%(typeParameters| * {typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
    3   0.000841   0.000146 call doge#buffer#register_doc_standard('doxygen_qt_no_asterisk', [
                            \  doge#helpers#deepextend(s:class_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      '@brief !description',
                            \      '%(typeParameters|)%',
                            \      '%(typeParameters|{typeParameters})%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      '@brief !description',
                            \      '',
                            \      '%(typeParameters|{typeParameters})%',
                            \      '%(parameters|{parameters})%',
                            \      '%(returnType|@return !description)%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      'struct {name} - !description',
                            \      '%(typeParameters|)%',
                            \      '%(typeParameters|{typeParameters})%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
    3              0.000016 let &cpoptions = s:save_cpo
    3              0.000012 unlet s:save_cpo

SCRIPT  /usr/share/nvim/runtime/ftplugin/cpp.vim
Sourced 3 times
Total time:   0.008196
 Self time:   0.007794

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Jul 26
                            
                            " Only do this when not done yet for this buffer
    3              0.000017 if exists("b:did_ftplugin")
                              finish
    3              0.000002 endif
                            
                            " Behaves mostly just like C
    3   0.008136   0.007735 runtime! ftplugin/c.vim ftplugin/c_*.vim ftplugin/c/*.vim
                            
                            " C++ uses templates with <things>
                            " Disabled, because it gives an error for typing an unmatched ">".
                            " set matchpairs+=<:>
                            " let b:undo_ftplugin ..= ' | setl matchpairs<'

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-doge/ftplugin/c.vim
Sourced 3 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
                            " ==============================================================================
                            " The C documentation should follow the 'Doxygen' conventions.
                            " - Doxygen: http://www.doxygen.nl/manual/docblocks.html
                            " - KernelDoc: https://www.kernel.org/doc/html/latest/doc-guide/kernel-doc.html
                            " ==============================================================================
                            
    3              0.000014 let s:save_cpo = &cpoptions
    3              0.000014 set cpoptions&vim
                            
                            " The C filetype also gets triggerred for C++, so we want to ignore this.
    3              0.000007 if &filetype !=? 'c'
    3              0.000003   finish
                            endif
                            
                            let b:doge_parser = 'c'
                            let b:doge_insert = 'above'
                            
                            let b:doge_supported_doc_standards = doge#buffer#get_supported_doc_standards([
                                  \ 'doxygen_javadoc',
                                  \ 'doxygen_javadoc_no_asterisk',
                                  \ 'doxygen_javadoc_banner',
                                  \ 'doxygen_qt',
                                  \ 'doxygen_qt_no_asterisk',
                                  \ 'kernel_doc'
                                  \ ])
                            let b:doge_doc_standard = doge#buffer#get_doc_standard('c')
                            let b:doge_patterns = doge#buffer#get_patterns()
                            
                            " ==============================================================================
                            "
                            " Define the pattern types.
                            "
                            " ==============================================================================
                            
                            " ------------------------------------------------------------------------------
                            " Matches regular functions.
                            " ------------------------------------------------------------------------------
                            let s:function_pattern = {
                            \  'nodeTypes': ['function_definition', 'declaration'],
                            \  'parameters': {
                            \    'format': '@param {name} !description',
                            \  },
                            \}
                            
                            " ------------------------------------------------------------------------------
                            " Matches structs.
                            " ------------------------------------------------------------------------------
                            let s:struct_pattern = {
                            \  'nodeTypes': ['struct_specifier'],
                            \}
                            
                            " ------------------------------------------------------------------------------
                            " Matches field declarations inside structs.
                            " ------------------------------------------------------------------------------
                            let s:field_pattern = {
                            \  'nodeTypes': ['field_declaration'],
                            \  'template': [
                            \    '/**',
                            \    ' * @{name} !description',
                            \    ' */',
                            \  ],
                            \}
                            
                            " ==============================================================================
                            "
                            " Define the doc standards.
                            "
                            " ==============================================================================
                            
                            call doge#buffer#register_doc_standard('doxygen_javadoc', [
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/**',
                            \      ' * struct {name} - !description',
                            \      ' */',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            call doge#buffer#register_doc_standard('doxygen_javadoc_no_asterisk', [
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/**',
                            \      '@brief !description',
                            \      '',
                            \      '%(parameters|{parameters})%',
                            \      '%(returnType|@return !description)%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/**',
                            \      'struct {name} - !description',
                            \      '*/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            call doge#buffer#register_doc_standard('doxygen_javadoc_banner', [
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*******************************************************************************',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' ******************************************************************************/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*******************************************************************************',
                            \      ' * struct {name} - !description',
                            \      ' ******************************************************************************/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            call doge#buffer#register_doc_standard('doxygen_qt', [
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      ' * @brief !description',
                            \      ' *',
                            \      '%(parameters| * {parameters})%',
                            \      '%(returnType| * @return !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      ' * struct {name} - !description',
                            \      ' */',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            call doge#buffer#register_doc_standard('doxygen_qt_no_asterisk', [
                            \  doge#helpers#deepextend(s:function_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      '@brief !description',
                            \      '',
                            \      '%(parameters|{parameters})%',
                            \      '%(returnType|@return !description)%',
                            \      '*/',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, {
                            \    'template': [
                            \      '/*!',
                            \      'struct {name} - !description',
                            \      '*/',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            let s:kernel_doc_pattern_base = {'parameters': {'format': '@{name}: !description'}}
                            call doge#buffer#register_doc_standard('kernel_doc', [
                            \  doge#helpers#deepextend(s:function_pattern, s:kernel_doc_pattern_base, {
                            \    'template': [
                            \      '/**',
                            \      ' * {name}(): !description',
                            \      '%(parameters| * {parameters})%',
                            \      ' *',
                            \      ' * !description',
                            \      '%(returnType| *)%',
                            \      '%(returnType| * Return: !description)%',
                            \      ' */',
                            \    ],
                            \  }),
                            \  doge#helpers#deepextend(s:struct_pattern, s:kernel_doc_pattern_base, {
                            \    'template': [
                            \      '/**',
                            \      ' * struct {name} - !description',
                            \      ' */',
                            \    ],
                            \  }),
                            \  s:field_pattern,
                            \])
                            
                            let &cpoptions = s:save_cpo
                            unlet s:save_cpo

SCRIPT  /usr/share/nvim/runtime/ftplugin/c.vim
Sourced 3 times
Total time:   0.000311
 Self time:   0.000311

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Feb 01
                            
                            " Only do this when not done yet for this buffer
    3              0.000013 if exists("b:did_ftplugin")
                              finish
    3              0.000002 endif
                            
                            " Don't load another plugin for this buffer
    3              0.000007 let b:did_ftplugin = 1
                            
                            " Using line continuation here.
    3              0.000021 let s:cpo_save = &cpo
    3              0.000021 set cpo-=C
                            
    3              0.000007 let b:undo_ftplugin = "setl fo< com< ofu< cms< def< inc<"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    3              0.000027 setlocal fo-=t fo+=croql
                            
                            " These options have the right value as default, but the user may have
                            " overruled that.
    3              0.000016 setlocal commentstring& define& include&
                            
                            " Set completion with CTRL-X CTRL-O to autoloaded function.
    3              0.000011 if exists('&ofu')
    3              0.000014   setlocal ofu=ccomplete#Complete
    3              0.000002 endif
                            
                            " Set 'comments' to format dashed lists in comments.
    3              0.000010 setlocal comments=sO:*\ -,mO:*\ \ ,exO:*/,s1:/*,mb:*,ex:*/,://
                            
                            " When the matchit plugin is loaded, this makes the % command skip parens and
                            " braces in comments properly.
    3              0.000008 let b:match_words = '^\s*#\s*if\(\|def\|ndef\)\>:^\s*#\s*elif\>:^\s*#\s*else\>:^\s*#\s*endif\>'
    3              0.000006 let b:match_skip = 's:comment\|string\|character\|special'
                            
                            " Win32 can filter files in the browse dialog
    3              0.000026 if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
                              if &ft == "cpp"
                                let b:browsefilter = "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              elseif &ft == "ch"
                                let b:browsefilter = "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "C Source Files (*.c)\t*.c\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              else
                                let b:browsefilter = "C Source Files (*.c)\t*.c\n" .
                            	  \ "C Header Files (*.h)\t*.h\n" .
                            	  \ "Ch Source Files (*.ch *.chf)\t*.ch;*.chf\n" .
                            	  \ "C++ Source Files (*.cpp *.c++)\t*.cpp;*.c++\n" .
                            	  \ "All Files (*.*)\t*.*\n"
                              endif
    3              0.000002 endif
                            
    3              0.000006 let b:man_default_sects = '3,2'
                            
    3              0.000019 let &cpo = s:cpo_save
    3              0.000010 unlet s:cpo_save

SCRIPT  /usr/share/nvim/runtime/indent/cpp.vim
Sourced 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	C++
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Nov 29
                            
                            " Only load this indent file when no other was loaded.
    3              0.000011 if exists("b:did_indent")
                               finish
    3              0.000002 endif
    3              0.000006 let b:did_indent = 1
                            
                            " C++ indenting is built-in, thus this is very simple
    3              0.000016 setlocal cindent
                            
    3              0.000009 let b:undo_indent = "setl cin<"

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/syntax/cpp.vim
Sourced 3 times
Total time:   0.010697
 Self time:   0.002946

count  total (s)   self (s)
    3   0.000103   0.000045 if polyglot#init#is_disabled(expand('<sfile>:p'), 'c/c++', 'syntax/cpp.vim')
                              finish
    3              0.000002 endif
                            
                            " Vim syntax file
                            " Language:	C++
                            " Current Maintainer:	vim-jp (https://github.com/vim-jp/vim-cpp)
                            " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
                            " Last Change:	2021 May 04
                            
                            " quit when a syntax file was already loaded
    3              0.000007 if exists("b:current_syntax")
                              finish
    3              0.000002 endif
                            
                            " inform C syntax that the file was included from cpp.vim
    3              0.000007 let b:filetype_in_cpp_family = 1
                            
                            " Read the C syntax to start with
    3   0.009277   0.001584 runtime! syntax/c.vim
    3              0.000008 unlet b:current_syntax
                            
                            " C++ extensions
    3              0.000014 syn keyword cppStatement	new delete this friend using
    3              0.000009 syn keyword cppAccess		public protected private
    3              0.000008 syn keyword cppModifier		inline virtual explicit export
    3              0.000007 syn keyword cppType		bool wchar_t
    3              0.000008 syn keyword cppExceptions	throw try catch
    3              0.000007 syn keyword cppOperator		operator typeid
    3              0.000014 syn keyword cppOperator		and bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
    3              0.000022 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
    3              0.000017 syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
    3              0.000007 syn keyword cppStorageClass	mutable
    3              0.000009 syn keyword cppStructure	class typename template namespace
    3              0.000007 syn keyword cppBoolean		true false
    3              0.000006 syn keyword cppConstant		__cplusplus
                            
                            " C++ 11 extensions
    3              0.000010 if !exists("cpp_no_cpp11")
    3              0.000008   syn keyword cppModifier	override final
    3              0.000007   syn keyword cppType		nullptr_t auto
    3              0.000006   syn keyword cppExceptions	noexcept
    3              0.000008   syn keyword cppStorageClass	constexpr decltype thread_local
    3              0.000006   syn keyword cppConstant	nullptr
    3              0.000006   syn keyword cppConstant	ATOMIC_FLAG_INIT ATOMIC_VAR_INIT
    3              0.000007   syn keyword cppConstant	ATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
    3              0.000007   syn keyword cppConstant	ATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
    3              0.000006   syn keyword cppConstant	ATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
    3              0.000006   syn keyword cppConstant	ATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
    3              0.000007   syn keyword cppConstant	ATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
    3              0.000111   syn region cppRawString	matchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"\(sv\|s\|_[_a-zA-Z][_a-zA-Z0-9]*\)\=+ contains=@Spell
    3              0.000022   syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*<"me=e-1
    3              0.000016   syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*$"
    3              0.000003 endif
                            
                            " C++ 14 extensions
    3              0.000008 if !exists("cpp_no_cpp14")
    3              0.000026   syn match cppNumbers		display transparent "\<\d\|\.\d" contains=cppNumber,cppFloat
    3              0.000031   syn match cppNumber		display contained "\<0\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000027   syn match cppNumber		display contained "\<[1-9]\('\=\d\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000020   syn match cppNumber		display contained "\<0\o\+\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000022   syn match cppNumber		display contained "\<0b[01]\('\=[01]\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000020   syn match cppNumber		display contained "\<0x\x\('\=\x\+\)*\([Uu]\=\([Ll]\|LL\|ll\)\|\([Ll]\|LL\|ll\)\=[Uu]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000022   syn match cppFloat		display contained "\<\d\+\.\d*\(e[-+]\=\d\+\)\=\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000019   syn match cppFloat		display contained "\<\.\d\+\(e[-+]\=\d\+\)\=\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000017   syn match cppFloat		display contained "\<\d\+e[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000073   syn region cppString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"\(sv\|s\|_\i*\)\=+ end='$' contains=cSpecial,cFormat,@Spell
    3              0.000003 endif
                            
                            " C++ 17 extensions
    3              0.000008 if !exists("cpp_no_cpp17")
    3              0.000052   syn match cppCast		"\<reinterpret_pointer_cast\s*<"me=e-1
    3              0.000014   syn match cppCast		"\<reinterpret_pointer_cast\s*$"
    3              0.000020   syn match cppFloat		display contained "\<0x\x*\.\x\+p[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000017   syn match cppFloat		display contained "\<0x\x\+\.\=p[-+]\=\d\+\([FfLl]\|i[fl]\=\|h\|min\|s\|ms\|us\|ns\|_\i*\)\=\>"
    3              0.000002 endif
                            
                            " C++ 20 extensions
    3              0.000007 if !exists("cpp_no_cpp20")
    3              0.000012   syn match cppNumber		display contained "\<0\(y\|d\)\>"
    3              0.000013   syn match cppNumber		display contained "\<[1-9]\('\=\d\+\)*\(y\|d\)\>"
    3              0.000009   syn match cppNumber		display contained "\<0\o\+\(y\|d\)\>"
    3              0.000013   syn match cppNumber		display contained "\<0b[01]\('\=[01]\+\)*\(y\|d\)\>"
    3              0.000011   syn match cppNumber		display contained "\<0x\x\('\=\x\+\)*\(y\|d\)\>"
    3              0.000011   syn keyword cppStatement	co_await co_return co_yield requires
    3              0.000008   syn keyword cppStorageClass	consteval constinit
    3              0.000006   syn keyword cppStructure	concept
    3              0.000007   syn keyword cppType		char8_t
    3              0.000007   syn keyword cppModule		import module export
    3              0.000002 endif
                            
                            " The minimum and maximum operators in GNU C++
    3              0.000010 syn match cppMinMax "[<>]?"
                            
                            " Default highlighting
    3              0.000011 hi def link cppAccess		cppStatement
    3              0.000008 hi def link cppCast		cppStatement
    3              0.000024 hi def link cppExceptions		Exception
    3              0.000025 hi def link cppOperator		Operator
    3              0.000021 hi def link cppStatement		Statement
    3              0.000022 hi def link cppModifier		Type
    3              0.000021 hi def link cppType		Type
    3              0.000020 hi def link cppStorageClass	StorageClass
    3              0.000018 hi def link cppStructure		Structure
    3              0.000018 hi def link cppBoolean		Boolean
    3              0.000019 hi def link cppConstant		Constant
    3              0.000021 hi def link cppRawStringDelimiter	Delimiter
    3              0.000021 hi def link cppRawString		String
    3              0.000021 hi def link cppString		String
    3              0.000021 hi def link cppNumber		Number
    3              0.000020 hi def link cppFloat		Number
    3              0.000019 hi def link cppModule		Include
                            
    3              0.000008 let b:current_syntax = "cpp"
                            
                            " vim: ts=8

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/syntax/c.vim
Sourced 3 times
Total time:   0.007084
 Self time:   0.007037

count  total (s)   self (s)
    3   0.000095   0.000048 if polyglot#init#is_disabled(expand('<sfile>:p'), 'c/c++', 'syntax/c.vim')
                              finish
    3              0.000002 endif
                            
                            " Vim syntax file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Jan 11
                            
                            " Quit when a (custom) syntax file was already loaded
    3              0.000006 if exists("b:current_syntax")
                              finish
    3              0.000001 endif
                            
    3              0.000022 let s:cpo_save = &cpo
    3              0.000020 set cpo&vim
                            
    3              0.000035 let s:ft = matchstr(&ft, '^\([^.]\)\+')
                            
                            " check if this was included from cpp.vim
    3              0.000014 let s:in_cpp_family = exists("b:filetype_in_cpp_family")
                            
                            " Optional embedded Autodoc parsing
                            " To enable it add: let g:c_autodoc = 1
                            " to your .vimrc
    3              0.000008 if exists("c_autodoc")
                              syn include @cAutodoc <sfile>:p:h/autodoc.vim
                              unlet b:current_syntax
    3              0.000002 endif
                            
                            " A bunch of useful C keywords
    3              0.000046 syn keyword	cStatement	goto break return continue asm
    3              0.000011 syn keyword	cLabel		case default
    3              0.000010 syn keyword	cConditional	if else switch
    3              0.000009 syn keyword	cRepeat		while for do
                            
    3              0.000011 syn keyword	cTodo		contained TODO FIXME XXX
                            
                            " It's easy to accidentally add a space after a backslash that was intended
                            " for line continuation.  Some compilers allow it, which makes it
                            " unpredictable and should be avoided.
    3              0.000019 syn match	cBadContinuation contained "\\\s\+$"
                            
                            " cCommentGroup allows adding matches for special things in comments
    3              0.000034 syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
                            
                            " String and Character constants
                            " Highlight special characters (those which have a backslash) differently
    3              0.000020 syn match	cSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
    3              0.000008 if !exists("c_no_utf")
    3              0.000017   syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
    3              0.000002 endif
                            
    3              0.000006 if !exists("c_no_cformat")
                              " Highlight % items in strings.
    3              0.000006   if !exists("c_no_c99") " ISO C99
    3              0.000036     syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              else
                                syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
    3              0.000002   endif
    3              0.000011   syn match	cFormat		display "%%" contained
    3              0.000002 endif
                            
                            " cCppString: same as cString, but ends at end of line
    3              0.000013 if s:in_cpp_family && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
                              " ISO C++11
    3              0.000065   syn region	cString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    3              0.000057   syn region 	cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
                              " ISO C99
                              syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            else
                              " older C or C++
                              syn match	cFormat		display "%%" contained
                              syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
    3              0.000003 endif
                            
    3              0.000051 syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
                            
    3              0.000025 syn cluster	cStringGroup	contains=cCppString,cCppSkip
                            
    3              0.000015 syn match	cCharacter	"L\='[^\\]'"
    3              0.000025 syn match	cCharacter	"L'[^']*'" contains=cSpecial
    3              0.000008 if exists("c_gnu")
                              syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
    3              0.000002 else
    3              0.000013   syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
    3              0.000013   syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
    3              0.000002 endif
    3              0.000013 syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
    3              0.000012 syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
    3              0.000011 syn match	cSpecialCharacter display "L'\\x\x\+'"
                            
    3              0.000016 if (s:ft ==# "c" && !exists("c_no_c11")) || (s:in_cpp_family && !exists("cpp_no_cpp11"))
                              " ISO C11 or ISO C++ 11
    3              0.000005   if exists("c_no_cformat")
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
    3              0.000011   else
    3              0.000041     syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
    3              0.000003   endif
    3              0.000014   syn match	cCharacter	"[Uu]'[^\\]'"
    3              0.000022   syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
    3              0.000007   if exists("c_gnu")
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
    3              0.000002   else
    3              0.000012     syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
    3              0.000013     syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
    3              0.000002   endif
    3              0.000012   syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
    3              0.000011   syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
    3              0.000002 endif
                            
                            "when wanted, highlight trailing white space
    3              0.000006 if exists("c_space_errors")
                              if !exists("c_no_trail_space_error")
                                syn match	cSpaceError	display excludenl "\s\+$"
                              endif
                              if !exists("c_no_tab_space_error")
                                syn match	cSpaceError	display " \+\t"me=e-1
                              endif
    3              0.000002 endif
                            
                            " This should be before cErrInParen to avoid problems with #define ({ xxx })
    3              0.000006 if exists("c_curly_error")
                              syn match cCurlyError "}"
                              syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
    3              0.000003 else
    3              0.000016   syn region	cBlock		start="{" end="}" transparent fold
    3              0.000002 endif
                            
                            " Catch errors caused by wrong parenthesis and brackets.
                            " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
                            " But avoid matching <::.
    3              0.000131 syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
    3              0.000008 if exists("c_no_curly_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^^<%\|^%>"
                              else
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
                              endif
    3              0.000008 elseif exists("c_no_bracket_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "<%\|%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "[{}]\|<%\|%>"
                              endif
    3              0.000002 else
    3              0.000009   if s:in_cpp_family && !exists("cpp_no_cpp11")
    3              0.000043     syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
    3              0.000056     syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
    3              0.000013     syn match	cParenError	display "[\])]"
    3              0.000019     syn match	cErrInParen	display contained "<%\|%>"
    3              0.000049     syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
                                syn match	cParenError	display "[\])]"
                                syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
                                syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
    3              0.000003   endif
                              " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
    3              0.000056   syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
    3              0.000015   syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
    3              0.000003 endif
                            
    3              0.000012 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
    3              0.000003 endif
                            
                            "integer number, or floating point number without a dot and with "f".
    3              0.000004 syn case ignore
    3              0.000045 syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
                            " Same, but without octal error (for comments)
    3              0.000032 syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
    3              0.000018 syn match	cNumber		display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
                            "hex number
    3              0.000014 syn match	cNumber		display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
                            " Flag the first zero of an octal number as something special
    3              0.000026 syn match	cOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
    3              0.000011 syn match	cOctalZero	display contained "\<0"
    3              0.000012 syn match	cFloat		display contained "\d\+f"
                            "floating point number, with dot, optional exponent
    3              0.000016 syn match	cFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
                            "floating point number, starting with a dot, optional exponent
    3              0.000013 syn match	cFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
                            "floating point number, without dot, with exponent
    3              0.000013 syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
    3              0.000009 if !exists("c_no_c99")
                              "hexadecimal floating point number, optional leading digits, with dot, with exponent
    3              0.000015   syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
                              "hexadecimal floating point number, with leading digits, optional dot, with exponent
    3              0.000012   syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
    3              0.000002 endif
                            
                            " flag an octal number with wrong digits
    3              0.000011 syn match	cOctalError	display contained "0\o*[89]\d*"
    3              0.000004 syn case match
                            
    3              0.000007 if exists("c_comment_strings")
                              " A comment can contain cString, cCharacter and cNumber.
                              " But a "*/" inside a cString in a cComment DOES end the comment!  So we
                              " need to use a special type of cString: cCommentString, which also ends on
                              " "*/", and sees a "*" at the start of the line as comment again.
                              " Unfortunately this doesn't very well work for // type of comments :-(
                              syn match	cCommentSkip	contained "^\s*\*\($\|\s\+\)"
                              syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
                              syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
                              syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,cWrongComTail,@Spell
                              if exists("c_no_comment_fold")
                                " Use "extend" here to have preprocessor lines not terminate halfway a
                                " comment.
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
                              else
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
                              endif
    3              0.000002 else
    3              0.000036   syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
    3              0.000009   if exists("c_no_comment_fold")
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
    3              0.000003   else
    3              0.000039     syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
    3              0.000002   endif
    3              0.000002 endif
                            " keep a // comment separately, it terminates a preproc. conditional
    3              0.000010 syn match	cCommentError	display "\*/"
    3              0.000010 syn match	cCommentStartError display "/\*"me=e-1 contained
    3              0.000009 syn match	cWrongComTail	display "\*/"
                            
    3              0.000043 syn keyword	cOperator	sizeof
    3              0.000007 if exists("c_gnu")
                              syn keyword	cStatement	__asm__
                              syn keyword	cOperator	typeof __real__ __imag__
    3              0.000002 endif
    3              0.000012 syn keyword	cType		int long short char void
    3              0.000009 syn keyword	cType		signed unsigned float double
    3              0.000009 if !exists("c_no_ansi") || exists("c_ansi_typedefs")
    3              0.000012   syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
    3              0.000012   syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
    3              0.000027   syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
    3              0.000002 endif
    3              0.000006 if !exists("c_no_c99") " ISO C99
    3              0.000022   syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
    3              0.000008   syn keyword	cType		int8_t int16_t int32_t int64_t
    3              0.000008   syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
    3              0.000006   if !exists("c_no_bsd")
                                " These are BSD specific.
    3              0.000008     syn keyword	cType		u_int8_t u_int16_t u_int32_t u_int64_t
    3              0.000002   endif
    3              0.000008   syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
    3              0.000008   syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
    3              0.000008   syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
    3              0.000007   syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
    3              0.000006   syn keyword	cType		intptr_t uintptr_t
    3              0.000006   syn keyword	cType		intmax_t uintmax_t
    3              0.000002 endif
    3              0.000005 if exists("c_gnu")
                              syn keyword	cType		__label__ __complex__ __volatile__
    3              0.000002 endif
                            
    3              0.000007 syn keyword	cTypedef	typedef
    3              0.000020 syn keyword	cStructure	struct union enum
    3              0.000012 syn keyword	cStorageClass	static register auto volatile extern const
    3              0.000005 if exists("c_gnu")
                              syn keyword	cStorageClass	inline __attribute__
    3              0.000002 endif
    3              0.000007 if !exists("c_no_c99") && !s:in_cpp_family
                              syn keyword	cStorageClass	inline restrict
    3              0.000002 endif
    3              0.000004 if !exists("c_no_c11")
    3              0.000007   syn keyword	cStorageClass	_Alignas alignas
    3              0.000014   syn keyword	cOperator	_Alignof alignof
    3              0.000007   syn keyword	cStorageClass	_Atomic
    3              0.000012   syn keyword	cOperator	_Generic
    3              0.000007   syn keyword	cStorageClass	_Noreturn noreturn
    3              0.000014   syn keyword	cOperator	_Static_assert static_assert
    3              0.000007   syn keyword	cStorageClass	_Thread_local thread_local
    3              0.000008   syn keyword   cType		char16_t char32_t
                              " C11 atomics (take down the shield wall!)
    3              0.000008   syn keyword	cType		atomic_bool atomic_char atomic_schar atomic_uchar
    3              0.000008   syn keyword	Ctype		atomic_short atomic_ushort atomic_int atomic_uint
    3              0.000007   syn keyword	cType		atomic_long atomic_ulong atomic_llong atomic_ullong
    3              0.000007   syn keyword	cType		atomic_char16_t atomic_char32_t atomic_wchar_t
    3              0.000007   syn keyword	cType		atomic_int_least8_t atomic_uint_least8_t
    3              0.000006   syn keyword	cType		atomic_int_least16_t atomic_uint_least16_t
    3              0.000006   syn keyword	cType		atomic_int_least32_t atomic_uint_least32_t
    3              0.000007   syn keyword	cType		atomic_int_least64_t atomic_uint_least64_t
    3              0.000006   syn keyword	cType		atomic_int_fast8_t atomic_uint_fast8_t
    3              0.000006   syn keyword	cType		atomic_int_fast16_t atomic_uint_fast16_t
    3              0.000006   syn keyword	cType		atomic_int_fast32_t atomic_uint_fast32_t
    3              0.000006   syn keyword	cType		atomic_int_fast64_t atomic_uint_fast64_t
    3              0.000006   syn keyword	cType		atomic_intptr_t atomic_uintptr_t
    3              0.000006   syn keyword	cType		atomic_size_t atomic_ptrdiff_t
    3              0.000006   syn keyword	cType		atomic_intmax_t atomic_uintmax_t
    3              0.000002 endif
                            
    3              0.000010 if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
    3              0.000004   if exists("c_gnu")
                                syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
    3              0.000002   endif
    3              0.000011   syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__ __STDC_VERSION__ __STDC_HOSTED__
    3              0.000008   syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
    3              0.000014   syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
    3              0.000008   syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
    3              0.000008   syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
    3              0.000008   syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
    3              0.000097   syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
    3              0.000008   if !exists("c_no_c99")
    3              0.000022     syn keyword cConstant __func__ __VA_ARGS__
    3              0.000025     syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
    3              0.000031     syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
    3              0.000031     syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
    3              0.000031     syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
    3              0.000033     syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
    3              0.000032     syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
    3              0.000033     syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
    3              0.000015     syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
    3              0.000008     syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
    3              0.000007     syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
    3              0.000007     syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
    3              0.000007     syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
    3              0.000009     syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
    3              0.000008     syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
    3              0.000002   endif
    3              0.000012   syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
    3              0.000012   syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
    3              0.000013   syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
    3              0.000011   syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
    3              0.000013   syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
                              " Add POSIX signals as well...
    3              0.000013   syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
    3              0.000010   syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
    3              0.000011   syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
    3              0.000012   syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
                              " used in assert.h
    3              0.000006   syn keyword cConstant NDEBUG
                              " POSIX 2001
    3              0.000010   syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
                              " non-POSIX signals
    3              0.000007   syn keyword cConstant SIGWINCH SIGINFO
                              " Add POSIX errors as well.  List comes from:
                              " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
    3              0.000011   syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
    3              0.000010   syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
    3              0.000011   syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
    3              0.000015   syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
    3              0.000011   syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
    3              0.000012   syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
    3              0.000011   syn keyword cConstant ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
    3              0.000010   syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
    3              0.000010   syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
    3              0.000007   syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
                              " math.h
    3              0.000009   syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
    3              0.000008   syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
    3              0.000002 endif
    3              0.000006 if !exists("c_no_c99") " ISO C99
    3              0.000007   syn keyword cConstant true false
    3              0.000002 endif
                            
                            " Accept %: for # (C99)
    3              0.000119 syn region	cPreCondit	start="^\s*\zs\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
    3              0.000038 syn match	cPreConditMatch	display "^\s*\zs\(%:\|#\)\s*\(else\|endif\)\>"
    3              0.000009 if !exists("c_no_if0")
    3              0.000061   syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
    3              0.000049   syn region	cCppOutWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
    3              0.000040   syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
    3              0.000010   if !exists("c_no_if0_fold")
    3              0.000059     syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
                              else
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
    3              0.000003   endif
    3              0.000038   syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
    3              0.000040   syn region	cCppInWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
    3              0.000034   syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
    3              0.000008   if !exists("c_no_if0_fold")
    3              0.000044     syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
                              else
                                syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
    3              0.000003   endif
    3              0.000047   syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
    3              0.000070   syn region	cCppOutSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
    3              0.000065   syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
    3              0.000003 endif
    3              0.000022 syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
    3              0.000014 syn match	cIncluded	display contained "<[^>]*>"
    3              0.000028 syn match	cInclude	display "^\s*\zs\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            "syn match cLineSkip	"\\$"
    3              0.000195 syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
    3              0.000035 syn region	cDefine		start="^\s*\zs\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
    3              0.000049 syn region	cPreProc	start="^\s*\zs\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            
                            " Optional embedded Autodoc parsing
    3              0.000009 if exists("c_autodoc")
                              syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
                              syn cluster cCommentGroup add=cAutodocReal
                              syn cluster cPreProcGroup add=cAutodocReal
    3              0.000002 endif
                            
                            " Highlight User Labels
    3              0.000163 syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
    3              0.000013 if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
    3              0.000002 endif
                            " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
    3              0.000013 syn cluster	cLabelGroup	contains=cUserLabel
    3              0.000021 syn match	cUserCont	display "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    3              0.000014 syn match	cUserCont	display ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
    3              0.000005 if s:in_cpp_family
    3              0.000021   syn match	cUserCont	display "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    3              0.000017   syn match	cUserCont	display ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                            else
                              syn match	cUserCont	display "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                              syn match	cUserCont	display ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
    3              0.000002 endif
                            
    3              0.000018 syn match	cUserLabel	display "\I\i*" contained
                            
                            " Avoid recognizing most bitfields as labels
    3              0.000025 syn match	cBitField	display "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
    3              0.000019 syn match	cBitField	display ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            
    3              0.000007 if exists("c_minlines")
                              let b:c_minlines = c_minlines
    3              0.000002 else
    3              0.000005   if !exists("c_no_if0")
    3              0.000008     let b:c_minlines = 50	" #if 0 constructs can be long
                              else
                                let b:c_minlines = 15	" mostly for () constructs
    3              0.000002   endif
    3              0.000002 endif
    3              0.000006 if exists("c_curly_error")
                              syn sync fromstart
    3              0.000002 else
    3              0.000023   exec "syn sync ccomment cComment minlines=" . b:c_minlines
    3              0.000002 endif
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
    3              0.000016 hi def link cFormat		cSpecial
    3              0.000011 hi def link cCppString		cString
    3              0.000009 hi def link cCommentL		cComment
    3              0.000009 hi def link cCommentStart	cComment
    3              0.000040 hi def link cLabel		Label
    3              0.000022 hi def link cUserLabel		Label
    3              0.000021 hi def link cConditional	Conditional
    3              0.000020 hi def link cRepeat		Repeat
    3              0.000020 hi def link cCharacter		Character
    3              0.000011 hi def link cSpecialCharacter	cSpecial
    3              0.000026 hi def link cNumber		Number
    3              0.000021 hi def link cOctal		Number
    3              0.000021 hi def link cOctalZero		PreProc	 " link this to Error if you want
    3              0.000019 hi def link cFloat		Float
    3              0.000009 hi def link cOctalError		cError
    3              0.000008 hi def link cParenError		cError
    3              0.000008 hi def link cErrInParen		cError
    3              0.000008 hi def link cErrInBracket	cError
    3              0.000008 hi def link cCommentError	cError
    3              0.000008 hi def link cCommentStartError	cError
    3              0.000008 hi def link cSpaceError		cError
    3              0.000007 hi def link cWrongComTail	cError
    3              0.000008 hi def link cSpecialError	cError
    3              0.000008 hi def link cCurlyError		cError
    3              0.000030 hi def link cOperator		Operator
    3              0.000026 hi def link cStructure		Structure
    3              0.000018 hi def link cTypedef		Structure
    3              0.000018 hi def link cStorageClass	StorageClass
    3              0.000018 hi def link cInclude		Include
    3              0.000019 hi def link cPreProc		PreProc
    3              0.000018 hi def link cDefine		Macro
    3              0.000010 hi def link cIncluded		cString
    3              0.000019 hi def link cError		Error
    3              0.000020 hi def link cStatement		Statement
    3              0.000009 hi def link cCppInWrapper	cCppOutWrapper
    3              0.000008 hi def link cCppOutWrapper	cPreCondit
    3              0.000008 hi def link cPreConditMatch	cPreCondit
    3              0.000018 hi def link cPreCondit		PreCondit
    3              0.000021 hi def link cType		Type
    3              0.000019 hi def link cConstant		Constant
    3              0.000010 hi def link cCommentString	cString
    3              0.000009 hi def link cComment2String	cString
    3              0.000008 hi def link cCommentSkip	cComment
    3              0.000020 hi def link cString		String
    3              0.000020 hi def link cComment		Comment
    3              0.000022 hi def link cSpecial		SpecialChar
    3              0.000020 hi def link cTodo		Todo
    3              0.000021 hi def link cBadContinuation	Error
    3              0.000009 hi def link cCppOutSkip		cCppOutIf2
    3              0.000008 hi def link cCppInElse2		cCppOutIf2
    3              0.000007 hi def link cCppOutIf2		cCppOut
    3              0.000018 hi def link cCppOut		Comment
                            
    3              0.000007 let b:current_syntax = "c"
                            
    3              0.000005 unlet s:ft
                            
    3              0.000025 let &cpo = s:cpo_save
    3              0.000004 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/share/nvim/runtime/syntax/c.vim
Sourced 3 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Jan 11
                            
                            " Quit when a (custom) syntax file was already loaded
    3              0.000013 if exists("b:current_syntax")
    3              0.000004   finish
                            endif
                            
                            let s:cpo_save = &cpo
                            set cpo&vim
                            
                            let s:ft = matchstr(&ft, '^\([^.]\)\+')
                            
                            " check if this was included from cpp.vim
                            let s:in_cpp_family = exists("b:filetype_in_cpp_family")
                            
                            " Optional embedded Autodoc parsing
                            " To enable it add: let g:c_autodoc = 1
                            " to your .vimrc
                            if exists("c_autodoc")
                              syn include @cAutodoc <sfile>:p:h/autodoc.vim
                              unlet b:current_syntax
                            endif
                            
                            " A bunch of useful C keywords
                            syn keyword	cStatement	goto break return continue asm
                            syn keyword	cLabel		case default
                            syn keyword	cConditional	if else switch
                            syn keyword	cRepeat		while for do
                            
                            syn keyword	cTodo		contained TODO FIXME XXX
                            
                            " It's easy to accidentally add a space after a backslash that was intended
                            " for line continuation.  Some compilers allow it, which makes it
                            " unpredictable and should be avoided.
                            syn match	cBadContinuation contained "\\\s\+$"
                            
                            " cCommentGroup allows adding matches for special things in comments
                            syn cluster	cCommentGroup	contains=cTodo,cBadContinuation
                            
                            " String and Character constants
                            " Highlight special characters (those which have a backslash) differently
                            syn match	cSpecial	display contained "\\\(x\x\+\|\o\{1,3}\|.\|$\)"
                            if !exists("c_no_utf")
                              syn match	cSpecial	display contained "\\\(u\x\{4}\|U\x\{8}\)"
                            endif
                            
                            if !exists("c_no_cformat")
                              " Highlight % items in strings.
                              if !exists("c_no_c99") " ISO C99
                                syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlLjzt]\|ll\|hh\)\=\([aAbdiuoxXDOUfFeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              else
                                syn match	cFormat		display "%\(\d\+\$\)\=[-+' #0*]*\(\d*\|\*\|\*\d\+\$\)\(\.\(\d*\|\*\|\*\d\+\$\)\)\=\([hlL]\|ll\)\=\([bdiuoxXDOUfeEgGcCsSpn]\|\[\^\=.[^]]*\]\)" contained
                              endif
                              syn match	cFormat		display "%%" contained
                            endif
                            
                            " cCppString: same as cString, but ends at end of line
                            if s:in_cpp_family && !exists("cpp_no_cpp11") && !exists("c_no_cformat")
                              " ISO C++11
                              syn region	cString		start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region 	cCppString	start=+\(L\|u\|u8\|U\|R\|LR\|u8R\|uR\|UR\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            elseif s:ft ==# "c" && !exists("c_no_c11") && !exists("c_no_cformat")
                              " ISO C99
                              syn region	cString		start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+\%(L\|U\|u8\)\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            else
                              " older C or C++
                              syn match	cFormat		display "%%" contained
                              syn region	cString		start=+L\="+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              syn region	cCppString	start=+L\="+ skip=+\\\\\|\\"\|\\$+ excludenl end=+"+ end='$' contains=cSpecial,cFormat,@Spell
                            endif
                            
                            syn region	cCppSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppSkip
                            
                            syn cluster	cStringGroup	contains=cCppString,cCppSkip
                            
                            syn match	cCharacter	"L\='[^\\]'"
                            syn match	cCharacter	"L'[^']*'" contains=cSpecial
                            if exists("c_gnu")
                              syn match	cSpecialError	"L\='\\[^'\"?\\abefnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abefnrtv]'"
                            else
                              syn match	cSpecialError	"L\='\\[^'\"?\\abfnrtv]'"
                              syn match	cSpecialCharacter "L\='\\['\"?\\abfnrtv]'"
                            endif
                            syn match	cSpecialCharacter display "L\='\\\o\{1,3}'"
                            syn match	cSpecialCharacter display "'\\x\x\{1,2}'"
                            syn match	cSpecialCharacter display "L'\\x\x\+'"
                            
                            if (s:ft ==# "c" && !exists("c_no_c11")) || (s:in_cpp_family && !exists("cpp_no_cpp11"))
                              " ISO C11 or ISO C++ 11
                              if exists("c_no_cformat")
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,@Spell extend
                              else
                                syn region	cString		start=+\%(U\|u8\=\)"+ skip=+\\\\\|\\"+ end=+"+ contains=cSpecial,cFormat,@Spell extend
                              endif
                              syn match	cCharacter	"[Uu]'[^\\]'"
                              syn match	cCharacter	"[Uu]'[^']*'" contains=cSpecial
                              if exists("c_gnu")
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abefnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abefnrtv]'"
                              else
                                syn match	cSpecialError	"[Uu]'\\[^'\"?\\abfnrtv]'"
                                syn match	cSpecialCharacter "[Uu]'\\['\"?\\abfnrtv]'"
                              endif
                              syn match	cSpecialCharacter display "[Uu]'\\\o\{1,3}'"
                              syn match	cSpecialCharacter display "[Uu]'\\x\x\+'"
                            endif
                            
                            "when wanted, highlight trailing white space
                            if exists("c_space_errors")
                              if !exists("c_no_trail_space_error")
                                syn match	cSpaceError	display excludenl "\s\+$"
                              endif
                              if !exists("c_no_tab_space_error")
                                syn match	cSpaceError	display " \+\t"me=e-1
                              endif
                            endif
                            
                            " This should be before cErrInParen to avoid problems with #define ({ xxx })
                            if exists("c_curly_error")
                              syn match cCurlyError "}"
                              syn region	cBlock		start="{" end="}" contains=ALLBUT,cBadBlock,cCurlyError,@cParenGroup,cErrInParen,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell fold
                            else
                              syn region	cBlock		start="{" end="}" transparent fold
                            endif
                            
                            " Catch errors caused by wrong parenthesis and brackets.
                            " Also accept <% for {, %> for }, <: for [ and :> for ] (C99)
                            " But avoid matching <::.
                            syn cluster	cParenGroup	contains=cParenError,cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserLabel,cBitField,cOctalZero,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom
                            if exists("c_no_curly_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^^<%\|^%>"
                              else
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "^[{}]\|^<%\|^%>"
                              endif
                            elseif exists("c_no_bracket_error")
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "<%\|%>"
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cParen,cString,@Spell
                                syn match	cParenError	display ")"
                                syn match	cErrInParen	display contained "[{}]\|<%\|%>"
                              endif
                            else
                              if s:in_cpp_family && !exists("cpp_no_cpp11")
                                syn region	cParen		transparent start='(' end=')' contains=ALLBUT,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
                                syn match	cParenError	display "[\])]"
                                syn match	cErrInParen	display contained "<%\|%>"
                                syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' contains=ALLBUT,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
                              else
                                syn region	cParen		transparent start='(' end=')' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cCppParen,cErrInBracket,cCppBracket,@cStringGroup,@Spell
                                " cCppParen: same as cParen but ends at end-of-line; used in cDefine
                                syn region	cCppParen	transparent start='(' skip='\\$' excludenl end=')' end='$' contained contains=ALLBUT,@cParenGroup,cErrInBracket,cParen,cBracket,cString,@Spell
                                syn match	cParenError	display "[\])]"
                                syn match	cErrInParen	display contained "[\]{}]\|<%\|%>"
                                syn region	cBracket	transparent start='\[\|<::\@!' end=']\|:>' end='}'me=s-1 contains=ALLBUT,cBlock,@cParenGroup,cErrInParen,cCppParen,cCppBracket,@cStringGroup,@Spell
                              endif
                              " cCppBracket: same as cParen but ends at end-of-line; used in cDefine
                              syn region	cCppBracket	transparent start='\[\|<::\@!' skip='\\$' excludenl end=']\|:>' end='$' contained contains=ALLBUT,@cParenGroup,cErrInParen,cParen,cBracket,cString,@Spell
                              syn match	cErrInBracket	display contained "[);{}]\|<%\|%>"
                            endif
                            
                            if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cBadBlock	keepend start="{" end="}" contained containedin=cParen,cBracket,cBadBlock transparent fold
                            endif
                            
                            "integer number, or floating point number without a dot and with "f".
                            syn case ignore
                            syn match	cNumbers	display transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctalError,cOctal
                            " Same, but without octal error (for comments)
                            syn match	cNumbersCom	display contained transparent "\<\d\|\.\d" contains=cNumber,cFloat,cOctal
                            syn match	cNumber		display contained "\d\+\(u\=l\{0,2}\|ll\=u\)\>"
                            "hex number
                            syn match	cNumber		display contained "0x\x\+\(u\=l\{0,2}\|ll\=u\)\>"
                            " Flag the first zero of an octal number as something special
                            syn match	cOctal		display contained "0\o\+\(u\=l\{0,2}\|ll\=u\)\>" contains=cOctalZero
                            syn match	cOctalZero	display contained "\<0"
                            syn match	cFloat		display contained "\d\+f"
                            "floating point number, with dot, optional exponent
                            syn match	cFloat		display contained "\d\+\.\d*\(e[-+]\=\d\+\)\=[fl]\="
                            "floating point number, starting with a dot, optional exponent
                            syn match	cFloat		display contained "\.\d\+\(e[-+]\=\d\+\)\=[fl]\=\>"
                            "floating point number, without dot, with exponent
                            syn match	cFloat		display contained "\d\+e[-+]\=\d\+[fl]\=\>"
                            if !exists("c_no_c99")
                              "hexadecimal floating point number, optional leading digits, with dot, with exponent
                              syn match	cFloat		display contained "0x\x*\.\x\+p[-+]\=\d\+[fl]\=\>"
                              "hexadecimal floating point number, with leading digits, optional dot, with exponent
                              syn match	cFloat		display contained "0x\x\+\.\=p[-+]\=\d\+[fl]\=\>"
                            endif
                            
                            " flag an octal number with wrong digits
                            syn match	cOctalError	display contained "0\o*[89]\d*"
                            syn case match
                            
                            if exists("c_comment_strings")
                              " A comment can contain cString, cCharacter and cNumber.
                              " But a "*/" inside a cString in a cComment DOES end the comment!  So we
                              " need to use a special type of cString: cCommentString, which also ends on
                              " "*/", and sees a "*" at the start of the line as comment again.
                              " Unfortunately this doesn't very well work for // type of comments :-(
                              syn match	cCommentSkip	contained "^\s*\*\($\|\s\+\)"
                              syn region cCommentString	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end=+\*/+me=s-1 contains=cSpecial,cCommentSkip
                              syn region cComment2String	contained start=+L\=\\\@<!"+ skip=+\\\\\|\\"+ end=+"+ end="$" contains=cSpecial
                              syn region  cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cComment2String,cCharacter,cNumbersCom,cSpaceError,cWrongComTail,@Spell
                              if exists("c_no_comment_fold")
                                " Use "extend" here to have preprocessor lines not terminate halfway a
                                " comment.
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell extend
                              else
                                syn region cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cCommentString,cCharacter,cNumbersCom,cSpaceError,@Spell fold extend
                              endif
                            else
                              syn region	cCommentL	start="//" skip="\\$" end="$" keepend contains=@cCommentGroup,cSpaceError,@Spell
                              if exists("c_no_comment_fold")
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell extend
                              else
                                syn region	cComment	matchgroup=cCommentStart start="/\*" end="\*/" contains=@cCommentGroup,cCommentStartError,cSpaceError,@Spell fold extend
                              endif
                            endif
                            " keep a // comment separately, it terminates a preproc. conditional
                            syn match	cCommentError	display "\*/"
                            syn match	cCommentStartError display "/\*"me=e-1 contained
                            syn match	cWrongComTail	display "\*/"
                            
                            syn keyword	cOperator	sizeof
                            if exists("c_gnu")
                              syn keyword	cStatement	__asm__
                              syn keyword	cOperator	typeof __real__ __imag__
                            endif
                            syn keyword	cType		int long short char void
                            syn keyword	cType		signed unsigned float double
                            if !exists("c_no_ansi") || exists("c_ansi_typedefs")
                              syn keyword   cType		size_t ssize_t off_t wchar_t ptrdiff_t sig_atomic_t fpos_t
                              syn keyword   cType		clock_t time_t va_list jmp_buf FILE DIR div_t ldiv_t
                              syn keyword   cType		mbstate_t wctrans_t wint_t wctype_t
                            endif
                            if !exists("c_no_c99") " ISO C99
                              syn keyword	cType		_Bool bool _Complex complex _Imaginary imaginary
                              syn keyword	cType		int8_t int16_t int32_t int64_t
                              syn keyword	cType		uint8_t uint16_t uint32_t uint64_t
                              if !exists("c_no_bsd")
                                " These are BSD specific.
                                syn keyword	cType		u_int8_t u_int16_t u_int32_t u_int64_t
                              endif
                              syn keyword	cType		int_least8_t int_least16_t int_least32_t int_least64_t
                              syn keyword	cType		uint_least8_t uint_least16_t uint_least32_t uint_least64_t
                              syn keyword	cType		int_fast8_t int_fast16_t int_fast32_t int_fast64_t
                              syn keyword	cType		uint_fast8_t uint_fast16_t uint_fast32_t uint_fast64_t
                              syn keyword	cType		intptr_t uintptr_t
                              syn keyword	cType		intmax_t uintmax_t
                            endif
                            if exists("c_gnu")
                              syn keyword	cType		__label__ __complex__ __volatile__
                            endif
                            
                            syn keyword	cTypedef	typedef
                            syn keyword	cStructure	struct union enum
                            syn keyword	cStorageClass	static register auto volatile extern const
                            if exists("c_gnu")
                              syn keyword	cStorageClass	inline __attribute__
                            endif
                            if !exists("c_no_c99") && !s:in_cpp_family
                              syn keyword	cStorageClass	inline restrict
                            endif
                            if !exists("c_no_c11")
                              syn keyword	cStorageClass	_Alignas alignas
                              syn keyword	cOperator	_Alignof alignof
                              syn keyword	cStorageClass	_Atomic
                              syn keyword	cOperator	_Generic
                              syn keyword	cStorageClass	_Noreturn noreturn
                              syn keyword	cOperator	_Static_assert static_assert
                              syn keyword	cStorageClass	_Thread_local thread_local
                              syn keyword   cType		char16_t char32_t
                              " C11 atomics (take down the shield wall!)
                              syn keyword	cType		atomic_bool atomic_char atomic_schar atomic_uchar
                              syn keyword	Ctype		atomic_short atomic_ushort atomic_int atomic_uint
                              syn keyword	cType		atomic_long atomic_ulong atomic_llong atomic_ullong
                              syn keyword	cType		atomic_char16_t atomic_char32_t atomic_wchar_t
                              syn keyword	cType		atomic_int_least8_t atomic_uint_least8_t
                              syn keyword	cType		atomic_int_least16_t atomic_uint_least16_t
                              syn keyword	cType		atomic_int_least32_t atomic_uint_least32_t
                              syn keyword	cType		atomic_int_least64_t atomic_uint_least64_t
                              syn keyword	cType		atomic_int_fast8_t atomic_uint_fast8_t
                              syn keyword	cType		atomic_int_fast16_t atomic_uint_fast16_t
                              syn keyword	cType		atomic_int_fast32_t atomic_uint_fast32_t
                              syn keyword	cType		atomic_int_fast64_t atomic_uint_fast64_t
                              syn keyword	cType		atomic_intptr_t atomic_uintptr_t
                              syn keyword	cType		atomic_size_t atomic_ptrdiff_t
                              syn keyword	cType		atomic_intmax_t atomic_uintmax_t
                            endif
                            
                            if !exists("c_no_ansi") || exists("c_ansi_constants") || exists("c_gnu")
                              if exists("c_gnu")
                                syn keyword cConstant __GNUC__ __FUNCTION__ __PRETTY_FUNCTION__ __func__
                              endif
                              syn keyword cConstant __LINE__ __FILE__ __DATE__ __TIME__ __STDC__ __STDC_VERSION__ __STDC_HOSTED__
                              syn keyword cConstant CHAR_BIT MB_LEN_MAX MB_CUR_MAX
                              syn keyword cConstant UCHAR_MAX UINT_MAX ULONG_MAX USHRT_MAX
                              syn keyword cConstant CHAR_MIN INT_MIN LONG_MIN SHRT_MIN
                              syn keyword cConstant CHAR_MAX INT_MAX LONG_MAX SHRT_MAX
                              syn keyword cConstant SCHAR_MIN SINT_MIN SLONG_MIN SSHRT_MIN
                              syn keyword cConstant SCHAR_MAX SINT_MAX SLONG_MAX SSHRT_MAX
                              if !exists("c_no_c99")
                                syn keyword cConstant __func__ __VA_ARGS__
                                syn keyword cConstant LLONG_MIN LLONG_MAX ULLONG_MAX
                                syn keyword cConstant INT8_MIN INT16_MIN INT32_MIN INT64_MIN
                                syn keyword cConstant INT8_MAX INT16_MAX INT32_MAX INT64_MAX
                                syn keyword cConstant UINT8_MAX UINT16_MAX UINT32_MAX UINT64_MAX
                                syn keyword cConstant INT_LEAST8_MIN INT_LEAST16_MIN INT_LEAST32_MIN INT_LEAST64_MIN
                                syn keyword cConstant INT_LEAST8_MAX INT_LEAST16_MAX INT_LEAST32_MAX INT_LEAST64_MAX
                                syn keyword cConstant UINT_LEAST8_MAX UINT_LEAST16_MAX UINT_LEAST32_MAX UINT_LEAST64_MAX
                                syn keyword cConstant INT_FAST8_MIN INT_FAST16_MIN INT_FAST32_MIN INT_FAST64_MIN
                                syn keyword cConstant INT_FAST8_MAX INT_FAST16_MAX INT_FAST32_MAX INT_FAST64_MAX
                                syn keyword cConstant UINT_FAST8_MAX UINT_FAST16_MAX UINT_FAST32_MAX UINT_FAST64_MAX
                                syn keyword cConstant INTPTR_MIN INTPTR_MAX UINTPTR_MAX
                                syn keyword cConstant INTMAX_MIN INTMAX_MAX UINTMAX_MAX
                                syn keyword cConstant PTRDIFF_MIN PTRDIFF_MAX SIG_ATOMIC_MIN SIG_ATOMIC_MAX
                                syn keyword cConstant SIZE_MAX WCHAR_MIN WCHAR_MAX WINT_MIN WINT_MAX
                              endif
                              syn keyword cConstant FLT_RADIX FLT_ROUNDS FLT_DIG FLT_MANT_DIG FLT_EPSILON DBL_DIG DBL_MANT_DIG DBL_EPSILON
                              syn keyword cConstant LDBL_DIG LDBL_MANT_DIG LDBL_EPSILON FLT_MIN FLT_MAX FLT_MIN_EXP FLT_MAX_EXP FLT_MIN_10_EXP FLT_MAX_10_EXP
                              syn keyword cConstant DBL_MIN DBL_MAX DBL_MIN_EXP DBL_MAX_EXP DBL_MIN_10_EXP DBL_MAX_10_EXP LDBL_MIN LDBL_MAX LDBL_MIN_EXP LDBL_MAX_EXP
                              syn keyword cConstant LDBL_MIN_10_EXP LDBL_MAX_10_EXP HUGE_VAL CLOCKS_PER_SEC NULL LC_ALL LC_COLLATE LC_CTYPE LC_MONETARY
                              syn keyword cConstant LC_NUMERIC LC_TIME SIG_DFL SIG_ERR SIG_IGN SIGABRT SIGFPE SIGILL SIGHUP SIGINT SIGSEGV SIGTERM
                              " Add POSIX signals as well...
                              syn keyword cConstant SIGABRT SIGALRM SIGCHLD SIGCONT SIGFPE SIGHUP SIGILL SIGINT SIGKILL SIGPIPE SIGQUIT SIGSEGV
                              syn keyword cConstant SIGSTOP SIGTERM SIGTRAP SIGTSTP SIGTTIN SIGTTOU SIGUSR1 SIGUSR2
                              syn keyword cConstant _IOFBF _IOLBF _IONBF BUFSIZ EOF WEOF FOPEN_MAX FILENAME_MAX L_tmpnam
                              syn keyword cConstant SEEK_CUR SEEK_END SEEK_SET TMP_MAX stderr stdin stdout EXIT_FAILURE EXIT_SUCCESS RAND_MAX
                              " used in assert.h
                              syn keyword cConstant NDEBUG
                              " POSIX 2001
                              syn keyword cConstant SIGBUS SIGPOLL SIGPROF SIGSYS SIGURG SIGVTALRM SIGXCPU SIGXFSZ
                              " non-POSIX signals
                              syn keyword cConstant SIGWINCH SIGINFO
                              " Add POSIX errors as well.  List comes from:
                              " http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/errno.h.html
                              syn keyword cConstant E2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY EBADF
                              syn keyword cConstant EBADMSG EBUSY ECANCELED ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK
                              syn keyword cConstant EDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTUNREACH EIDRM EILSEQ
                              syn keyword cConstant EINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK EMSGSIZE
                              syn keyword cConstant EMULTIHOP ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS ENODATA
                              syn keyword cConstant ENODEV ENOENT ENOEXEC ENOLCK ENOLINK ENOMEM ENOMSG ENOPROTOOPT ENOSPC ENOSR
                              syn keyword cConstant ENOSTR ENOSYS ENOTBLK ENOTCONN ENOTDIR ENOTEMPTY ENOTRECOVERABLE ENOTSOCK ENOTSUP
                              syn keyword cConstant ENOTTY ENXIO EOPNOTSUPP EOVERFLOW EOWNERDEAD EPERM EPIPE EPROTO
                              syn keyword cConstant EPROTONOSUPPORT EPROTOTYPE ERANGE EROFS ESPIPE ESRCH ESTALE ETIME ETIMEDOUT
                              syn keyword cConstant ETXTBSY EWOULDBLOCK EXDEV
                              " math.h
                              syn keyword cConstant M_E M_LOG2E M_LOG10E M_LN2 M_LN10 M_PI M_PI_2 M_PI_4
                              syn keyword cConstant M_1_PI M_2_PI M_2_SQRTPI M_SQRT2 M_SQRT1_2
                            endif
                            if !exists("c_no_c99") " ISO C99
                              syn keyword cConstant true false
                            endif
                            
                            " Accept %: for # (C99)
                            syn region	cPreCondit	start="^\s*\zs\(%:\|#\)\s*\(if\|ifdef\|ifndef\|elif\)\>" skip="\\$" end="$" keepend contains=cComment,cCommentL,cCppString,cCharacter,cCppParen,cParenError,cNumbers,cCommentError,cSpaceError
                            syn match	cPreConditMatch	display "^\s*\zs\(%:\|#\)\s*\(else\|endif\)\>"
                            if !exists("c_no_if0")
                              syn cluster	cCppOutInGroup	contains=cCppInIf,cCppInElse,cCppInElse2,cCppOutIf,cCppOutIf2,cCppOutElse,cCppInSkip,cCppOutSkip
                              syn region	cCppOutWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0\+\s*\($\|//\|/\*\|&\)" end=".\@=\|$" contains=cCppOutIf,cCppOutElse,@NoSpell fold
                              syn region	cCppOutIf	contained start="0\+" matchgroup=cCppOutWrapper end="^\s*\(%:\|#\)\s*endif\>" contains=cCppOutIf2,cCppOutElse
                              if !exists("c_no_if0_fold")
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell fold
                              else
                                syn region	cCppOutIf2	contained matchgroup=cCppOutWrapper start="0\+" end="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0\+\s*\($\|//\|/\*\|&\)\)\@!\|endif\>\)"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
                              endif
                              syn region	cCppOutElse	contained matchgroup=cCppOutWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=TOP,cPreCondit
                              syn region	cCppInWrapper	start="^\s*\zs\(%:\|#\)\s*if\s\+0*[1-9]\d*\s*\($\|//\|/\*\||\)" end=".\@=\|$" contains=cCppInIf,cCppInElse fold
                              syn region	cCppInIf	contained matchgroup=cCppInWrapper start="\d\+" end="^\s*\(%:\|#\)\s*endif\>" contains=TOP,cPreCondit
                              if !exists("c_no_if0_fold")
                                syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2 fold
                              else
                                syn region	cCppInElse	contained start="^\s*\(%:\|#\)\s*\(else\>\|elif\s\+\(0*[1-9]\d*\s*\($\|//\|/\*\||\)\)\@!\)" end=".\@=\|$" containedin=cCppInIf contains=cCppInElse2
                              endif
                              syn region	cCppInElse2	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(else\|elif\)\([^/]\|/[^/*]\)*" end="^\s*\(%:\|#\)\s*endif\>"me=s-1 contains=cSpaceError,cCppOutSkip,@Spell
                              syn region	cCppOutSkip	contained start="^\s*\(%:\|#\)\s*\(if\>\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" contains=cSpaceError,cCppOutSkip
                              syn region	cCppInSkip	contained matchgroup=cCppInWrapper start="^\s*\(%:\|#\)\s*\(if\s\+\(\d\+\s*\($\|//\|/\*\||\|&\)\)\@!\|ifdef\>\|ifndef\>\)" skip="\\$" end="^\s*\(%:\|#\)\s*endif\>" containedin=cCppOutElse,cCppInIf,cCppInSkip contains=TOP,cPreProc
                            endif
                            syn region	cIncluded	display contained start=+"+ skip=+\\\\\|\\"+ end=+"+
                            syn match	cIncluded	display contained "<[^>]*>"
                            syn match	cInclude	display "^\s*\zs\(%:\|#\)\s*include\>\s*["<]" contains=cIncluded
                            "syn match cLineSkip	"\\$"
                            syn cluster	cPreProcGroup	contains=cPreCondit,cIncluded,cInclude,cDefine,cErrInParen,cErrInBracket,cUserLabel,cSpecial,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cString,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cParen,cBracket,cMulti,cBadBlock
                            syn region	cDefine		start="^\s*\zs\(%:\|#\)\s*\(define\|undef\)\>" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            syn region	cPreProc	start="^\s*\zs\(%:\|#\)\s*\(pragma\>\|line\>\|warning\>\|warn\>\|error\>\)" skip="\\$" end="$" keepend contains=ALLBUT,@cPreProcGroup,@Spell
                            
                            " Optional embedded Autodoc parsing
                            if exists("c_autodoc")
                              syn match cAutodocReal display contained "\%(//\|[/ \t\v]\*\|^\*\)\@2<=!.*" contains=@cAutodoc containedin=cComment,cCommentL
                              syn cluster cCommentGroup add=cAutodocReal
                              syn cluster cPreProcGroup add=cAutodocReal
                            endif
                            
                            " Highlight User Labels
                            syn cluster	cMultiGroup	contains=cIncluded,cSpecial,cCommentSkip,cCommentString,cComment2String,@cCommentGroup,cCommentStartError,cUserCont,cUserLabel,cBitField,cOctalZero,cCppOutWrapper,cCppInWrapper,@cCppOutInGroup,cFormat,cNumber,cFloat,cOctal,cOctalError,cNumbersCom,cCppParen,cCppBracket,cCppString
                            if s:ft ==# 'c' || exists("cpp_no_cpp11")
                              syn region	cMulti		transparent start='?' skip='::' end=':' contains=ALLBUT,@cMultiGroup,@Spell,@cStringGroup
                            endif
                            " Avoid matching foo::bar() in C++ by requiring that the next char is not ':'
                            syn cluster	cLabelGroup	contains=cUserLabel
                            syn match	cUserCont	display "^\s*\zs\I\i*\s*:$" contains=@cLabelGroup
                            syn match	cUserCont	display ";\s*\zs\I\i*\s*:$" contains=@cLabelGroup
                            if s:in_cpp_family
                              syn match	cUserCont	display "^\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                              syn match	cUserCont	display ";\s*\zs\%(class\|struct\|enum\)\@!\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                            else
                              syn match	cUserCont	display "^\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                              syn match	cUserCont	display ";\s*\zs\I\i*\s*:[^:]"me=e-1 contains=@cLabelGroup
                            endif
                            
                            syn match	cUserLabel	display "\I\i*" contained
                            
                            " Avoid recognizing most bitfields as labels
                            syn match	cBitField	display "^\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            syn match	cBitField	display ";\s*\zs\I\i*\s*:\s*[1-9]"me=e-1 contains=cType
                            
                            if exists("c_minlines")
                              let b:c_minlines = c_minlines
                            else
                              if !exists("c_no_if0")
                                let b:c_minlines = 50	" #if 0 constructs can be long
                              else
                                let b:c_minlines = 15	" mostly for () constructs
                              endif
                            endif
                            if exists("c_curly_error")
                              syn sync fromstart
                            else
                              exec "syn sync ccomment cComment minlines=" . b:c_minlines
                            endif
                            
                            " Define the default highlighting.
                            " Only used when an item doesn't have highlighting yet
                            hi def link cFormat		cSpecial
                            hi def link cCppString		cString
                            hi def link cCommentL		cComment
                            hi def link cCommentStart	cComment
                            hi def link cLabel		Label
                            hi def link cUserLabel		Label
                            hi def link cConditional	Conditional
                            hi def link cRepeat		Repeat
                            hi def link cCharacter		Character
                            hi def link cSpecialCharacter	cSpecial
                            hi def link cNumber		Number
                            hi def link cOctal		Number
                            hi def link cOctalZero		PreProc	 " link this to Error if you want
                            hi def link cFloat		Float
                            hi def link cOctalError		cError
                            hi def link cParenError		cError
                            hi def link cErrInParen		cError
                            hi def link cErrInBracket	cError
                            hi def link cCommentError	cError
                            hi def link cCommentStartError	cError
                            hi def link cSpaceError		cError
                            hi def link cWrongComTail	cError
                            hi def link cSpecialError	cError
                            hi def link cCurlyError		cError
                            hi def link cOperator		Operator
                            hi def link cStructure		Structure
                            hi def link cTypedef		Structure
                            hi def link cStorageClass	StorageClass
                            hi def link cInclude		Include
                            hi def link cPreProc		PreProc
                            hi def link cDefine		Macro
                            hi def link cIncluded		cString
                            hi def link cError		Error
                            hi def link cStatement		Statement
                            hi def link cCppInWrapper	cCppOutWrapper
                            hi def link cCppOutWrapper	cPreCondit
                            hi def link cPreConditMatch	cPreCondit
                            hi def link cPreCondit		PreCondit
                            hi def link cType		Type
                            hi def link cConstant		Constant
                            hi def link cCommentString	cString
                            hi def link cComment2String	cString
                            hi def link cCommentSkip	cComment
                            hi def link cString		String
                            hi def link cComment		Comment
                            hi def link cSpecial		SpecialChar
                            hi def link cTodo		Todo
                            hi def link cBadContinuation	Error
                            hi def link cCppOutSkip		cCppOutIf2
                            hi def link cCppInElse2		cCppOutIf2
                            hi def link cCppOutIf2		cCppOut
                            hi def link cCppOut		Comment
                            
                            let b:current_syntax = "c"
                            
                            unlet s:ft
                            
                            let &cpo = s:cpo_save
                            unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/c.vim
Sourced 3 times
Total time:   0.000531
 Self time:   0.000476

count  total (s)   self (s)
    3   0.000104   0.000050 if polyglot#init#is_disabled(expand('<sfile>:p'), 'cpp-modern', 'after/syntax/c.vim')
                              finish
    3              0.000002 endif
                            
                            " ==============================================================================
                            " Vim syntax file
                            " Language:        C Additions
                            " Original Author: Mikhail Wolfson <mywolfson@gmail.com>
                            " Maintainer:      bfrg <https://github.com/bfrg>
                            " Website:         https://github.com/bfrg/vim-cpp-modern
                            " Last Change:     Nov 23, 2020
                            "
                            " This syntax file is based on:
                            " https://github.com/octol/vim-cpp-enhanced-highlight
                            " ==============================================================================
                            
                            
                            " Highlight additional keywords in the comments
    3              0.000014 syn keyword cTodo contained BUG NOTE
                            
                            
                            " Highlight function names
    3              0.000010 if !get(g:, 'cpp_no_function_highlight', 0)
    3              0.000038     syn match cUserFunction "\<\h\w*\>\(\s\|\n\)*("me=e-1 contains=cParen,cCppParen
    3              0.000024     hi def link cUserFunction Function
    3              0.000002 endif
                            
                            
                            " Highlight struct/class member variables
    3              0.000008 if get(g:, 'cpp_member_highlight', 0)
                                syn match cMemberAccess "\.\|->" nextgroup=cStructMember,cppTemplateKeyword
                                syn match cStructMember "\<\h\w*\>\%((\|<\)\@!" contained
                                syn cluster cParenGroup add=cStructMember
                                syn cluster cPreProcGroup add=cStructMember
                                syn cluster cMultiGroup add=cStructMember
                                hi def link cStructMember Identifier
                            
                                if &filetype ==# 'cpp'
                                    syn keyword cppTemplateKeyword template
                                    hi def link cppTemplateKeyword cppStructure
                                endif
    3              0.000002 endif
                            
                            
                            " Common ANSI-standard Names
    3              0.000133 syn keyword cAnsiName
                                    \ PRId8 PRIi16 PRIo32 PRIu64 PRId16 PRIi32 PRIo64 PRIuLEAST8 PRId32 PRIi64 PRIoLEAST8 PRIuLEAST16 PRId64 PRIiLEAST8 PRIoLEAST16 PRIuLEAST32 PRIdLEAST8 PRIiLEAST16 PRIoLEAST32 PRIuLEAST64 PRIdLEAST16 PRIiLEAST32 PRIoLEAST64 PRIuFAST8 PRIdLEAST32 PRIiLEAST64 PRIoFAST8 PRIuFAST16 PRIdLEAST64 PRIiFAST8 PRIoFAST16 PRIuFAST32 PRIdFAST8 PRIiFAST16 PRIoFAST32 PRIuFAST64 PRIdFAST16 PRIiFAST32 PRIoFAST64 PRIuMAX PRIdFAST32 PRIiFAST64 PRIoMAX PRIuPTR PRIdFAST64 PRIiMAX PRIoPTR PRIx8 PRIdMAX PRIiPTR PRIu8 PRIx16 PRIdPTR PRIo8 PRIu16 PRIx32 PRIi8 PRIo16 PRIu32 PRIx64 PRIxLEAST8 SCNd8 SCNiFAST32 SCNuLEAST32 PRIxLEAST16 SCNd16 SCNiFAST64 SCNuLEAST64 PRIxLEAST32 SCNd32 SCNiMAX SCNuFAST8 PRIxLEAST64 SCNd64 SCNiPTR SCNuFAST16 PRIxFAST8 SCNdLEAST8 SCNo8 SCNuFAST32 PRIxFAST16 SCNdLEAST16 SCNo16 SCNuFAST64 PRIxFAST32 SCNdLEAST32 SCNo32 SCNuMAX PRIxFAST64 SCNdLEAST64 SCNo64 SCNuPTR PRIxMAX SCNdFAST8 SCNoLEAST8 SCNx8 PRIxPTR SCNdFAST16 SCNoLEAST16 SCNx16 PRIX8 SCNdFAST32 SCNoLEAST32 SCNx32 PRIX16 SCNdFAST64 SCNoLEAST64 SCN
                                    \ errno environ and bitor not_eq xor and_eq compl or xor_eq bitand not or_eq
                            
                            " Booleans
    3              0.000012 syn keyword cBoolean true false TRUE FALSE
                            
                            
                            " Default highlighting
    3              0.000023 hi def link cBoolean  Boolean
    3              0.000023 hi def link cAnsiName Identifier
                            
                            
                            " Highlight all standard C keywords as Statement
                            " This is very similar to what other IDEs and editors do
    3              0.000009 if get(g:, 'cpp_simple_highlight', 0)
                                hi! def link cStorageClass Statement
                                hi! def link cStructure    Statement
                                hi! def link cTypedef      Statement
                                hi! def link cLabel        Statement
    3              0.000009 endif

SCRIPT  /usr/share/nvim/runtime/syntax/cpp.vim
Sourced 3 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	C++
                            " Current Maintainer:	vim-jp (https://github.com/vim-jp/vim-cpp)
                            " Previous Maintainer:	Ken Shan <ccshan@post.harvard.edu>
                            " Last Change:	2021 Jan 12
                            
                            " quit when a syntax file was already loaded
    3              0.000012 if exists("b:current_syntax")
    3              0.000003   finish
                            endif
                            
                            " inform C syntax that the file was included from cpp.vim
                            let b:filetype_in_cpp_family = 1
                            
                            " Read the C syntax to start with
                            runtime! syntax/c.vim
                            unlet b:current_syntax
                            
                            " C++ extensions
                            syn keyword cppStatement	new delete this friend using
                            syn keyword cppAccess		public protected private
                            syn keyword cppModifier		inline virtual explicit export
                            syn keyword cppType		bool wchar_t
                            syn keyword cppExceptions	throw try catch
                            syn keyword cppOperator		operator typeid
                            syn keyword cppOperator		and bitor or xor compl bitand and_eq or_eq xor_eq not not_eq
                            syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*<"me=e-1
                            syn match cppCast		"\<\(const\|static\|dynamic\|reinterpret\)_cast\s*$"
                            syn keyword cppStorageClass	mutable
                            syn keyword cppStructure	class typename template namespace
                            syn keyword cppBoolean		true false
                            syn keyword cppConstant		__cplusplus
                            
                            " C++ 11 extensions
                            if !exists("cpp_no_cpp11")
                              syn keyword cppModifier	override final
                              syn keyword cppType		nullptr_t auto
                              syn keyword cppExceptions	noexcept
                              syn keyword cppStorageClass	constexpr decltype thread_local
                              syn keyword cppConstant	nullptr
                              syn keyword cppConstant	ATOMIC_FLAG_INIT ATOMIC_VAR_INIT
                              syn keyword cppConstant	ATOMIC_BOOL_LOCK_FREE ATOMIC_CHAR_LOCK_FREE
                              syn keyword cppConstant	ATOMIC_CHAR16_T_LOCK_FREE ATOMIC_CHAR32_T_LOCK_FREE
                              syn keyword cppConstant	ATOMIC_WCHAR_T_LOCK_FREE ATOMIC_SHORT_LOCK_FREE
                              syn keyword cppConstant	ATOMIC_INT_LOCK_FREE ATOMIC_LONG_LOCK_FREE
                              syn keyword cppConstant	ATOMIC_LLONG_LOCK_FREE ATOMIC_POINTER_LOCK_FREE
                              syn region cppRawString	matchgroup=cppRawStringDelimiter start=+\%(u8\|[uLU]\)\=R"\z([[:alnum:]_{}[\]#<>%:;.?*\+\-/\^&|~!=,"']\{,16}\)(+ end=+)\z1"+ contains=@Spell
                              syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*<"me=e-1
                              syn match cppCast		"\<\(const\|static\|dynamic\)_pointer_cast\s*$"
                            endif
                            
                            " C++ 14 extensions
                            if !exists("cpp_no_cpp14")
                              syn case ignore
                              syn match cppNumber		display "\<0b[01]\('\=[01]\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
                              syn match cppNumber		display "\<[1-9]\('\=\d\+\)*\(u\=l\{0,2}\|ll\=u\)\>" contains=cFloat
                              syn match cppNumber		display "\<0x\x\('\=\x\+\)*\(u\=l\{0,2}\|ll\=u\)\>"
                              syn case match
                            endif
                            
                            " C++ 20 extensions
                            if !exists("cpp_no_cpp20")
                              syn keyword cppStatement	co_await co_return co_yield requires
                              syn keyword cppStorageClass	consteval constinit
                              syn keyword cppStructure	concept
                              syn keyword cppType		char8_t
                              syn keyword cppModule		import module export
                            endif
                            
                            " C++ 17 extensions
                            if !exists("cpp_no_cpp17")
                              syn match cppCast		"\<reinterpret_pointer_cast\s*<"me=e-1
                              syn match cppCast		"\<reinterpret_pointer_cast\s*$"
                            endif
                            
                            " The minimum and maximum operators in GNU C++
                            syn match cppMinMax "[<>]?"
                            
                            " Default highlighting
                            hi def link cppAccess		cppStatement
                            hi def link cppCast		cppStatement
                            hi def link cppExceptions		Exception
                            hi def link cppOperator		Operator
                            hi def link cppStatement		Statement
                            hi def link cppModifier		Type
                            hi def link cppType		Type
                            hi def link cppStorageClass	StorageClass
                            hi def link cppStructure		Structure
                            hi def link cppBoolean		Boolean
                            hi def link cppConstant		Constant
                            hi def link cppRawStringDelimiter	Delimiter
                            hi def link cppRawString		String
                            hi def link cppNumber		Number
                            hi def link cppModule		Include
                            
                            let b:current_syntax = "cpp"
                            
                            " vim: ts=8

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/after/syntax/cpp.vim
Sourced 3 times
Total time:   0.005930
 Self time:   0.005875

count  total (s)   self (s)
    3   0.000104   0.000049 if polyglot#init#is_disabled(expand('<sfile>:p'), 'cpp-modern', 'after/syntax/cpp.vim')
                              finish
    3              0.000002 endif
                            
                            " ==============================================================================
                            " Vim syntax file
                            " Language:        C++ (Standard library including C++11/14/17/20)
                            " Original Author: Jon Haggblad <https://github.com/octol>
                            " Maintainer:      bfrg <https://github.com/bfrg>
                            " Website:         https://github.com/bfrg/vim-cpp-modern
                            " Last Change:     Nov 23, 2020
                            "
                            " This syntax file is based on:
                            " https://github.com/octol/vim-cpp-enhanced-highlight
                            " ==============================================================================
                            
                            " C++ attributes {{{1
    3              0.000008 if get(g:, 'cpp_attributes_highlight', 0)
                                syntax region cppAttribute matchgroup=cppAttributeBrackets start='\[\[' end=']]' contains=cString
                                hi def link cppAttribute         Macro
                                hi def link cppAttributeBrackets Identifier
    3              0.000002 endif
                            
                            
                            " Standard library {{{1
    3              0.000017 syntax keyword cppSTLdefine
                                    \ MB_CUR_MAX MB_LEN_MAX WCHAR_MAX WCHAR_MIN WEOF __STDC_UTF_16__ __STDC_UTF_32__
                            
    3              0.000010 syntax keyword cppSTLnamespace
                                    \ std experimental rel_ops
                            
    3              0.000029 syntax keyword cppSTLconstant
                                    \ badbit digits digits10 eofbit failbit goodbit has_denorm has_denorm_loss has_infinity has_quiet_NaN has_signaling_NaN is_bounded is_exact is_iec559 is_integer is_modulo is_signed is_specialized max_exponent max_exponent10 min_exponent min_exponent10 npos radix round_style tinyness_before traps
                            
    3              0.000293 syntax keyword cppSTLvariable
                                    \ cerr cin clog cout wcerr wcin wclog wcout nothrow
                            
    3              0.000451 syntax keyword cppSTLexception
                                    \ bad_alloc bad_exception bad_typeid bad_cast domain_error exception failure invalid_argument length_error logic_error out_of_range overflow_error range_error runtime_error underflow_error
                            
    3              0.000282 syntax keyword cppSTLios
                                    \ endl ends flush resetiosflags setbase setfill setiosflags setprecision setw ws
                            
    3              0.000699 syntax keyword cppSTLios
                                    \ boolalpha dec defaultfloat fixed hex hexfloat internal left noboolalpha noshowbase noshowpoint noshowpos noskipws nounitbuf nouppercase oct right scientific showbase showpoint showpos skipws unitbuf uppercase
                            
    3              0.002531 syntax keyword cppSTLtype
                                    \ fmtflags iostate openmode Init allocator auto_ptr basic_filebuf basic_fstream basic_ifstream basic_ios basic_iostream basic_istream basic_istringstream basic_ofstream basic_ostream basic_ostringstream basic_streambuf basic_string basic_stringbuf basic_stringstream binary_compose binder1st binder2nd bitset char_traits char_type const_mem_fun1_t const_mem_fun_ref1_t const_mem_fun_ref_t const_mem_fun_t const_pointer const_reference container_type deque difference_type div_t event_callback filebuf first_type float_denorm_style float_round_style fpos fstream gslice_array ifstream imaxdiv_t indirect_array int_type ios ios_base iostream istream istringstream istrstream iterator_category iterator_traits key_compare key_type ldiv_t list lldiv_t map mapped_type mask_array mbstate_t mem_fun1_t mem_fun_ref1_t mem_fun_ref_t mem_fun_t multimap multiset nothrow_t numeric_limits off_type ofstream ostream ostringstream ostrstream pair pointer pointer_to_binary_function pointer_to_unary_function pos_type priority_qu
                            
    3              0.000014 syntax keyword cppSTLtypedef
                                    \ time_t sig_atomic_t wctrans_t wctype_t wint_t
                            
    3              0.000024 syntax keyword cppSTLiterator
                                    \ back_insert_iterator bidirectional_iterator const_iterator const_reverse_iterator forward_iterator front_insert_iterator input_iterator insert_iterator istream_iterator istreambuf_iterator iterator ostream_iterator ostreambuf_iterator output_iterator random_access_iterator raw_storage_iterator reverse_bidirectional_iterator reverse_iterator
                            
                            " Function templates that are called with template parameters
    3              0.000009 syntax keyword cppSTLfunction
                                    \ use_facet has_facet get
                            
                            " Some of these keywords can be highlighted as cppSTLios or cppSTLconstant
                            " syntax keyword cppSTLconstant
                            "         \ adjustfield app ate basefield binary floatfield in out trunc boolalpha dec fixed hex internal left oct right scientific showbase showpoint showpos skipws unitbuf uppercase
                            
                            
                            " C++11 extensions {{{1
    3              0.000011 if !exists('cpp_no_cpp11')
    3              0.000008     syntax keyword cppStatement nullptr
    3              0.000008     syntax keyword cppType char16_t char32_t
                            
    3              0.000007     syntax keyword cppSTLnamespace chrono this_thread
                            
    3              0.000217     syntax keyword cppSTLtype
                                        \ array atomic atomic_bool atomic_char atomic_flag atomic_int atomic_llong atomic_long atomic_schar atomic_short atomic_uchar atomic_uint atomic_ullong atomic_ulong atomic_ushort duration duration_values high_resolution_clock hours microseconds milliseconds minutes nanoseconds seconds steady_clock system_clock time_point treat_as_floating_point condition_variable exception_ptr nested_exception hash is_bind_expression is_placeholder reference_wrapper forward_list future packaged_task promise shared_future initializer_list codecvt_mode codecvt_utf16 codecvt_utf8 codecvt_utf8_utf16 wbuffer_convert wstring_convert allocator_traits allocator_type default_delete enable_shared_from_this is_always_equal owner_less pointer_safety pointer_traits propagate_on_container_copy_assignment propagate_on_container_move_assignment propagate_on_container_swap rebind_alloc rebind_traits shared_ptr unique_ptr uses_allocator void_pointer const_void_pointer weak_ptr condition_variable_any lock_guard mutex once_flag recu
                            
    3              0.000036     syntax keyword cppSTLtypedef
                                        \ atomic_char16_t atomic_char32_t atomic_int_fast16_t atomic_int_fast32_t atomic_int_fast64_t atomic_int_fast8_t atomic_int_least16_t atomic_int_least32_t atomic_int_least64_t atomic_int_least8_t atomic_intmax_t atomic_intptr_t atomic_ptrdiff_t atomic_size_t atomic_uint_fast16_t atomic_uint_fast32_t atomic_uint_fast64_t atomic_uint_fast8_t atomic_uint_least16_t atomic_uint_least32_t atomic_uint_least64_t atomic_uint_least8_t atomic_uintmax_t atomic_uintptr_t atomic_wchar_t nullptr_t max_align_t allocator_arg_t adopt_lock_t defer_lock_t try_to_lock_t piecewise_construct_t
                            
    3              0.000006     syntax keyword cppSTLconstant max_digits10
                            
    3              0.000013     syntax keyword cppSTLvariable
                                        \ _1 _2 _3 _4 _5 _6 _7 _8 _9 defer_lock try_to_lock adopt_lock allocator_arg
                            
    3              0.000015     syntax keyword cppSTLdefine
                                        \ math_errhandling FLT_EVAL_METHOD FP_INFINITE FP_NAN FP_NORMAL FP_SUBNORMAL FP_ZERO HUGE_VALF HUGE_VALL INFINITY MATH_ERREXCEPT MATH_ERRNO NAN
                            
    3              0.000010     syntax keyword cppSTLenum
                                        \ memory_order future_status future_errc launch io_errc cv_status errc
                            
    3              0.000023     syntax keyword cppSTLfunction
                                        \ duration_cast time_point_cast mem_fn const_pointer_cast dynamic_pointer_cast static_pointer_cast allocate_shared make_shared isblank generate_canonical forward_as_tuple make_tuple tie tuple_cat declval forward move move_if_noexcept
                            
    3              0.000010     syntax keyword cppSTLexception
                                        \ bad_function_call future_error regex_error system_error bad_weak_ptr bad_array_new_length
                            
                                " syntax keyword cppSTLiterator contained
    3              0.000009     syntax keyword cppSTLiterator
                                        \ move_iterator regex_iterator regex_token_iterator const_local_iterator local_iterator
                            
                                " Note: ignore is also a function
    3              0.000016     syntax match cppSTLvariable "\<ignore\>(\@!"
    3              0.000003 endif
                            
                            
                            " C++14 extensions {{{1
    3              0.000008 if !exists('cpp_no_cpp14')
    3              0.000009     syntax keyword cppSTLnamespace literals chrono_literals string_literals complex_literals
                            
    3              0.000005     syntax keyword cppSTLfunction make_unique
                            
    3              0.000012     syntax keyword cppSTLtype
                                        \ index_sequence index_sequence_for integer_sequence make_index_sequence make_integer_sequence shared_lock shared_timed_mutex is_null_pointer
                            
    3              0.000025     syntax keyword cppSTLtypedef
                                        \ tuple_element_t add_const_t add_cv_t add_lvalue_reference_t add_pointer_t add_rvalue_reference_t add_volatile_t aligned_storage_t aligned_union_t common_type_t conditional_t decay_t enable_if_t make_signed_t make_unsigned_t remove_all_extents_t remove_const_t remove_cv_t remove_extent_t remove_pointer_t remove_reference_t remove_volatile_t result_of_t underlying_type_t
    3              0.000002 endif
                            
                            
                            " C++17 extensions {{{1
    3              0.000006 if !exists('cpp_no_cpp17')
    3              0.000008     syntax keyword cppSTLnamespace filesystem execution string_view_literals
                            
    3              0.000055     syntax keyword cppSTLtype
                                        \ any byte is_execution_policy parallel_policy parallel_unsequenced_policy sequenced_policy directory_entry directory_iterator file_status file_time_type path recursive_directory_iterator space_info default_order default_searcher boyer_moore_searcher boyer_moore_horspool_searcher memory_resource monotonic_buffer_resource polymorphic_allocator pool_options synchronized_pool_resource unsynchronized_pool_resource scoped_lock optional shared_mutex basic_string_view string_view u16string_view u32string_view wstring_view bool_constant conjunction disjunction has_unique_object_representations invoke_result is_aggregate is_callable is_invocable is_invocable_r is_nothrow_invocable is_nothrow_invocable_r is_nothrow_swappable is_nothrow_swappable_with is_nowthrow_callable is_swappable is_swappable_with negation node_type insert_return_type in_place_tag monostate variant variant_size variant_alternative
                            
    3              0.000012     syntax keyword cppSTLtypedef
                                        \ invoke_result_t default_order_t nullopt_t void_t in_place_t in_place_type_t in_place_index_t variant_alternative_t
                            
    3              0.000008     syntax keyword cppSTLexception
                                        \ bad_any_cast filesystem_error bad_optional_access bad_variant_access
                            
    3              0.000048     syntax keyword cppSTLconstant
                                        \ is_always_lock_free seq par par_unseq copy_symlinks auto_format create_hard_links create_symlinks directories_only follow_directory_symlink generic_format group_all group_exec group_read group_write native_format others_all others_exec others_read others_write overwrite_existing owner_all owner_exec owner_read owner_write preferred_separator recursive set_gid set_uid skip_existing skip_permission_denied skip_symlinks sticky_bit update_existing hardware_destructive_interference_size hardware_constructive_interference_size tuple_size_v nullopt alignment_of_v rank_v extent_v variant_npos variant_size_v
                            
    3              0.000073     syntax keyword cppSTLbool
                                        \ treat_as_floating_point_v is_execution_policy_v is_bind_expression_v is_placeholder_v is_error_code_enum_v is_error_condition_enum_v uses_allocator_v conjunction_v disjunction_v has_unique_object_representations_v has_virtual_destructor_v is_abstract_v is_aggregate_v is_arithmetic_v is_array_v is_assignable_v is_base_of_v is_callable_v is_class_v is_compound_v is_const_v is_constructible_v is_convertible_v is_copy_assignable_v is_copy_constructible_v is_default_constructible_v is_destructible_v is_empty_v is_enum_v is_floating_point_v is_function_v is_fundamental_v is_integral_v is_invocable_r_v is_invocable_v is_literal_type_v is_lvalue_reference_v is_member_function_pointer_v is_member_object_pointer_v is_member_pointer_v is_move_assignable_v is_move_constructible_v is_nothrow_assignable_v is_nothrow_constructible_v is_nothrow_copy_assignable_v is_nothrow_copy_constructible_v is_nothrow_default_constructible_v is_nothrow_destructible_v is_nothrow_invocable_r_v is_nothrow_invocable_v is_nothro
                            
    3              0.000009     syntax keyword cppSTLfunction
                                        \ reinterpret_pointer_cast make_from_tuple make_optional any_cast
                            
    3              0.000009     syntax keyword cppSTLenum
                                        \ copy_options directory_options file_type perm_options perms
                            
                                " Note: There is std::filesystem::path::format and std::format() in <format>
    3              0.000014     syntax match cppSTLenum "\<format\>(\@!"
                            
                                " Note: these can be both member objects and methods
    3              0.000084     syntax match cppSTLvariable "\<\%(capacity\|free\|available\)\>(\@!"
                            
                                " Note: these keywords are very likely to coincide with user-defined variables
                                " syntax keyword cppSTLconstant
                                "         \ all mask unknown replace add remove nofollow none not_found regular directory symlink block character fifo socket unknown
    3              0.000003 endif
                            
                            
                            " C++20 extensions {{{1
    3              0.000008 if !exists('cpp_no_cpp20')
    3              0.000008     syntax keyword cppSTLnamespace ranges views
    3              0.000005     syntax keyword cppSTLconstant dynamic_extent
    3              0.000006     syntax keyword cppSTLvariable default_sentinel unreachable_sentinel
                            
    3              0.000055     syntax keyword cppSTLtype
                                        \ atomic_ref endian weak_ordering strong_ordering partial_ordering weak_equality strong_equality common_comparison_category contract_violation coroutine_traits coroutine_handle noop_coroutine_handle noop_coroutine_promise suspend_never suspend_always remove_cvref is_bounded_array is_layout_compatible is_unbounded_array is_nothrow_convertible has_strong_structural_equality is_pointer_interconvertible_base_of unwrap_reference unwrap_ref_decay basic_common_reference common_reference dangling ref_view filter_view transform_view iota_view join_view empty_view single_view split_view common_view reverse_view view_interface span basic_syncbuf basic_osyncstream syncbuf wsyncbuf osyncstream wosyncstream jthread latch barrier stop_token stop_source stop_callback counting_semaphore binary_semaphore source_location compare_three_way_result contiguous_iterator_tag incrementable_traits indirectly_readable_traits move_sentinel common_iterator counted_iterator projected type_identity
                            
    3              0.000020     syntax keyword cppSTLtypedef
                                        \ common_comparison_category_t remove_cvref_t unwrap_reference_t unwrap_ref_decay_t common_reference_t iterator_t sentinel_t safe_iterator_t safe_subrange_t compare_three_way_result_t iter_value_t iter_reference_t iter_difference_t iter_rvalue_reference_t iter_common_reference_t default_sentinel_t unreachable_sentinel_t indirect_result_t type_identity_t
                            
    3              0.000012     syntax keyword cppSTLfunction
                                        \ make_unique_default_init make_shared_default_init allocate_shared_default_init uses_allocator_construction_args make_obj_using_allocator is_corresponding_member subspan in_range is_pointer_interconvertible_with_class
                            
    3              0.000013     syntax keyword cppSTLbool
                                        \ is_bounded_array_v is_layout_compatible_v is_unbounded_array_v is_nothrow_convertible_v has_strong_structural_equality_v is_pointer_interconvertible_base_of_v disable_sized_sentinel_for disable_sized_range enable_borrowed_range enable_view
                            
    3              0.000063     syntax keyword cppSTLconcept
                                        \ assignable_from boolean common_reference_with common_with constructible_from convertible_to copy_constructible copyable default_constructible derived_from destructible equality_comparable equality_comparable_with equivalence_relation floating_point integral invocable movable move_constructible predicate regular regular_invocable relation same_as semiregular signed_integral strict_weak_order swappable swappable_with totally_ordered totally_ordered_with unsigned_integral default_initializable range sized_range view input_range output_range forward_range bidirectional_range random_access_range contiguous_range common_range viewable_range three_way_comparable three_way_comparable_with indirectly_readable indirectly_writable weakly_incrementable incrementable input_or_output_iterator sentinel_for sized_sentinel_for input_iterator output_iterator forward_iterator bidirectional_iterator random_access_iterator contiguous_iterator indirectly_unary_invocable indirectly_regular_unary_invocable indirect_un
    3              0.000002 endif
                            
                            
                            " Boost {{{1
    3              0.000005 if !exists('cpp_no_boost')
    3              0.000006     syntax keyword cppSTLnamespace boost
    3              0.000005     syntax keyword cppSTLfunction lexical_cast
    3              0.000002 endif
                            " }}}
                            
                            
                            " Default highlighting
    3              0.000028 hi def link cppSTLbool         Boolean
    3              0.000019 hi def link cppStatement       Statement
    3              0.000017 hi def link cppSTLfunction     Function
    3              0.000017 hi def link cppSTLdefine       Constant
    3              0.000016 hi def link cppSTLconstant     Constant
    3              0.000016 hi def link cppSTLnamespace    Constant
    3              0.000018 hi def link cppSTLexception    Type
    3              0.000023 hi def link cppSTLiterator     Type
    3              0.000017 hi def link cppSTLtype         Type
    3              0.000016 hi def link cppSTLtypedef      Typedef
    3              0.000015 hi def link cppSTLenum         Typedef
    3              0.000015 hi def link cppSTLios          Function
    3              0.000015 hi def link cppSTLconcept      Typedef
    3              0.000017 hi def link cppSTLvariable     Identifier
                            
                            " The keywords {inline, virtual, explicit, export, override, final} are
                            " standard C++ keywords and NOT types!
    3              0.000025 hi! def link cppModifier Statement
                            
                            
                            " Highlight all standard C++ keywords as Statement
    3              0.000009 if get(g:, 'cpp_simple_highlight', 0)
                                hi! def link cppStructure    Statement
                                hi! def link cppExceptions   Statement
                                hi! def link cppStorageClass Statement
    3              0.000005 endif

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim
Sourced 4 times
Total time:   0.001455
 Self time:   0.001455

count  total (s)   self (s)
    4              0.000021 scriptencoding utf-8
    4              0.000033 let s:is_vim = !has('nvim')
    4              0.000020 let s:clear_match_by_window = has('nvim-0.5.0') || has('patch-8.1.1084')
    4              0.000028 let s:prop_offset = get(g:, 'coc_text_prop_offset', 1000)
    4              0.000013 let s:namespace_map = {}
    4              0.000007 let s:ns_id = 1
                            
    4              0.000009 if has('nvim-0.5.0')
    4              0.000005   try
    4              0.000240     call getmatches(0)
                              catch /^Vim\%((\a\+)\)\=:E118/
                                let s:clear_match_by_window = 0
    4              0.000005   endtry
    4              0.000002 endif
                            
                            " Get namespaced coc highlights from range of bufnr
                            " start - 0 based start line index
                            " end - 0 based end line index, could be -1 for last line (exclusive)
    4              0.000015 function! coc#highlight#get(bufnr, key, start, end) abort
                              if !has('nvim-0.5.0') && !exists('*prop_list')
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list()'
                              endif
                              if !has_key(s:namespace_map, a:key) || !bufloaded(a:bufnr)
                                return {}
                              endif
                              let ns = coc#highlight#create_namespace(a:key)
                              let current = {}
                              if has('nvim-0.5.0')
                                let end = a:end == -1 ? [-1, -1] : [a:end, 0]
                                let markers = nvim_buf_get_extmarks(a:bufnr, ns, [a:start, 0], end, {'details': v:true})
                                for [_, row, start_col, details] in markers
                                  let delta = details['end_row'] - row
                                  if delta > 1 || (delta == 1 && details['end_col'] != 0)
                                    " Don't known neovim's api for multiple lines markers.
                                    continue
                                  endif
                                  let lines = getbufline(a:bufnr, row + 1)
                                  if empty(lines)
                                    " It's possible that markers exceeded last line.
                                    continue
                                  endif
                                  let text = lines[0]
                                  let curr = get(current, string(row), [])
                                  call add(curr, {
                                      \ 'hlGroup': details['hl_group'],
                                      \ 'lnum': row,
                                      \ 'colStart': start_col,
                                      \ 'colEnd': delta == 1 ? strlen(text) : details['end_col']
                                      \ })
                                  let current[string(row)] = curr
                                endfor
                              else
                                let id = s:prop_offset + ns
                                " we could only get textprops line by line
                                let end = a:end == -1 ? getbufinfo(a:bufnr)[0]['linecount'] : a:end
                                for line in range(a:start + 1, end)
                                  let items = []
                                  for prop in prop_list(line, {'bufnr': a:bufnr, 'id': id})
                                    " vim have support for cross line text props, but we're not using
                                    call add(items, {
                                          \ 'hlGroup': s:prop_type_hlgroup(prop['type']),
                                          \ 'lnum': line - 1,
                                          \ 'colStart': prop['col'] - 1,
                                          \ 'colEnd': prop['col'] - 1 + prop['length'] - (prop['end'] == 0 ? 1 : 0),
                                          \ })
                                  endfor
                                  if !empty(items)
                                    let current[string(line - 1)] = items
                                  endif
                                endfor
                              endif
                              return current
                            endfunction
                            
                            " Update highlights by check exists highlights.
    4              0.000009 function! coc#highlight#update_highlights(bufnr, key, highlights, ...) abort
                              if !bufloaded(a:bufnr)
                                return
                              endif
                              let start = get(a:, 1, 0)
                              let end = get(a:, 2, -1)
                              if empty(a:highlights)
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                                return
                              endif
                              let total = len(a:highlights)
                              " index list that exists with current highlights
                              let exists = []
                              let ns = coc#highlight#create_namespace(a:key)
                              let currIndex = 0
                              if has('nvim-0.5.0') || exists('*prop_list')
                                let current = coc#highlight#get(a:bufnr, a:key, start, end)
                                for lnum in sort(map(keys(current), 'str2nr(v:val)'), {a, b -> a - b})
                                  let items = current[lnum]
                                  let indexes = []
                                  let nextIndex = currIndex
                                  if currIndex != total
                                    for item in items
                                      for i in range(currIndex, total - 1)
                                        let hi = a:highlights[i]
                                        if hi['lnum'] > item['lnum']
                                          let nextIndex = i
                                          break
                                        endif
                                        if coc#helper#obj_equal(item, hi)
                                          call add(indexes, i)
                                          let nextIndex = max([nextIndex, i + 1])
                                        endif
                                      endfor
                                    endfor
                                  endif
                                  let currIndex = nextIndex
                                  " all highlights of current line exists, not clear.
                                  if len(indexes) == len(items)
                                    let exists = exists + indexes
                                  else
                                    if has('nvim')
                                      call nvim_buf_clear_namespace(a:bufnr, ns, lnum, lnum + 1)
                                    else
                                      call coc#api#call('buf_clear_namespace', [a:bufnr, ns, lnum, lnum + 1])
                                    endif
                                  endif
                                endfor
                              else
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                              endif
                              for i in range(0, total - 1)
                                if index(exists, i) == -1
                                  let hi = a:highlights[i]
                                  call coc#highlight#add_highlight(a:bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'])
                                endif
                              endfor
                            endfunction
                            
    4              0.000010 function! coc#highlight#get_highlights(bufnr, key) abort
                              if !has_key(s:namespace_map, a:key) || !bufloaded(a:bufnr)
                                return []
                              endif
                              let res = []
                              let ns = s:namespace_map[a:key]
                              if exists('*prop_list')
                                let lines = getbufline(a:bufnr, 1, '$')
                                let linecount = len(lines)
                                for line in range(1, linecount)
                                  for prop in prop_list(line, {'bufnr': a:bufnr, 'id': s:prop_offset + ns})
                                    if prop['start'] == 0 || prop['end'] == 0
                                      " multi line tokens are not supported; simply ignore it
                                      continue
                                    endif
                                    let text = lines[line - 1]
                                    call add(res, {
                                          \   'hlGroup': s:prop_type_hlgroup(prop['type']),
                                          \   'lnum': line - 1,
                                          \   'colStart': coc#helper#get_charactor(text, prop['col']),
                                          \   'colEnd': coc#helper#get_charactor(text, prop['col'] + prop['length'])
                                          \ })
                                  endfor
                                endfor
                              elseif has('nvim-0.5.0')
                                let markers = nvim_buf_get_extmarks(a:bufnr, ns, 0, -1, {'details': v:true})
                                let lines = getbufline(a:bufnr, 1, '$')
                                let total = len(lines)
                                for [_, line, start_col, details] in markers
                                  if line >= total
                                    " Could be markers exceed end of line
                                    continue
                                  endif
                                  let text = lines[line]
                                  let delta = details['end_row'] - line
                                  if delta > 1 || (delta == 1 && details['end_col'] != 0)
                                    " can't handle, single line only
                                    continue
                                  endif
                                  call add(res, {
                                        \   'hlGroup': details['hl_group'],
                                        \   'lnum': line,
                                        \   'colStart': coc#helper#get_charactor(text, start_col + 1),
                                        \   'colEnd': delta == 1 ? strchars(text) : coc#helper#get_charactor(text, details['end_col'] + 1)
                                        \ })
                                endfor
                              else
                                throw 'Get highlights requires neovim 0.5.0 or vim support prop_list'
                              endif
                              return res
                            endfunction
                            
                            " highlight LSP range,
    4              0.000008 function! coc#highlight#ranges(bufnr, key, hlGroup, ranges) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr) || !exists('*getbufline')
                                return
                              endif
                              let synmaxcol = getbufvar(a:bufnr, '&synmaxcol', 1000)
                              if synmaxcol == 0
                                let synmaxcol = 1000
                              endif
                              let synmaxcol = min([synmaxcol, 1000])
                              let srcId = coc#highlight#create_namespace(a:key)
                              for range in a:ranges
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  if start['character'] > synmaxcol || end['character'] > synmaxcol
                                    continue
                                  endif
                                  " TODO don't know how to count UTF16 code point, should work most cases.
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) : 0
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) : -1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call coc#highlight#add_highlight(bufnr, srcId, a:hlGroup, lnum - 1, colStart, colEnd)
                                endfor
                              endfor
                            endfunction
                            
    4              0.000011 function! coc#highlight#add_highlight(bufnr, src_id, hl_group, line, col_start, col_end) abort
                              if has('nvim')
                                call nvim_buf_add_highlight(a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end)
                              else
                                call coc#api#call('buf_add_highlight', [a:bufnr, a:src_id, a:hl_group, a:line, a:col_start, a:col_end])
                              endif
                            endfunction
                            
    4              0.000007 function! coc#highlight#clear_highlight(bufnr, key, start_line, end_line) abort
                              let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
                              if !bufloaded(bufnr)
                                return
                              endif
                              let src_id = coc#highlight#create_namespace(a:key)
                              if has('nvim')
                                call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
                              endif
                            endfunction
                            
                            " highlight buffer in winid with CodeBlock &HighlightItems
                            " export interface HighlightItem {
                            "   lnum: number // 0 based
                            "   hlGroup: string
                            "   colStart: number // 0 based
                            "   colEnd: number
                            " }
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    4              0.000008 function! coc#highlight#add_highlights(winid, codes, highlights) abort
                              " clear highlights
                              call coc#compat#execute(a:winid, 'syntax clear')
                              let bufnr = winbufnr(a:winid)
                              call coc#highlight#clear_highlight(bufnr, -1, 0, -1)
                              if !empty(a:codes)
                                call coc#highlight#highlight_lines(a:winid, a:codes)
                              endif
                              if !empty(a:highlights)
                                for item in a:highlights
                                  call coc#highlight#add_highlight(bufnr, -1, item['hlGroup'], item['lnum'], item['colStart'], item['colEnd'])
                                endfor
                              endif
                            endfunction
                            
                            
                            " Add highlights to line groups of winid, support hlGroup and filetype
                            " config should have startLine, endLine (1 based, end excluded) and filetype or hlGroup
                            " endLine should > startLine and endLine is excluded
                            "
                            " export interface CodeBlock {
                            "   filetype?: string
                            "   hlGroup?: string
                            "   startLine: number // 0 based
                            "   endLine: number
                            " }
    4              0.000006 function! coc#highlight#highlight_lines(winid, blocks) abort
                              let currwin = win_getid()
                              let switch = has('nvim') && currwin != a:winid
                              if switch
                                noa call nvim_set_current_win(a:winid)
                              endif
                              let defined = []
                              let region_id = 1
                              for config in a:blocks
                                let start = config['startLine'] + 1
                                let end = config['endLine'] == -1 ? len(getbufline(winbufnr(a:winid), 1, '$')) + 1 : config['endLine'] + 1
                                let filetype = get(config, 'filetype', '')
                                let hlGroup = get(config, 'hlGroup', '')
                                if !empty(hlGroup)
                                  call s:execute(a:winid, 'syntax region '.hlGroup.' start=/\%'.start.'l/ end=/\%'.end.'l/')
                                else
                                  let filetype = matchstr(filetype, '\v^\w+')
                                  if empty(filetype) || filetype == 'txt' || index(get(g:, 'coc_markdown_disabled_languages', []), filetype) != -1
                                    continue
                                  endif
                                  if index(defined, filetype) == -1
                                    call s:execute(a:winid, 'syntax include @'.toupper(filetype).' syntax/'.filetype.'.vim')
                                    if has('nvim')
                                      unlet! b:current_syntax
                                    elseif exists('*win_execute')
                                      call win_execute(a:winid, 'unlet! b:current_syntax')
                                    endif
                                    call add(defined, filetype)
                                  endif
                                  call s:execute(a:winid, 'syntax region CodeBlock'.region_id.' start=/\%'.start.'l/ end=/\%'.end.'l/ contains=@'.toupper(filetype).' keepend')
                                  let region_id = region_id + 1
                                endif
                              endfor
                              if switch
                                noa call nvim_set_current_win(currwin)
                              endif
                            endfunction
                            
                            " Copmpose hlGroups with foreground and background colors.
    4              0.000010 function! coc#highlight#compose_hlgroup(fgGroup, bgGroup) abort
                              let hlGroup = 'Fg'.a:fgGroup.'Bg'.a:bgGroup
                              if a:fgGroup == a:bgGroup
                                return a:fgGroup
                              endif
                              if hlexists(hlGroup)
                                return hlGroup
                              endif
                              let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'gui')
                              let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'gui')
                              if fg =~# '^#' || bg =~# '^#'
                                call s:create_gui_hlgroup(hlGroup, fg, bg, '')
                              else
                                let fg = synIDattr(synIDtrans(hlID(a:fgGroup)), 'fg', 'cterm')
                                let bg = synIDattr(synIDtrans(hlID(a:bgGroup)), 'bg', 'cterm')
                                call s:create_cterm_hlgroup(hlGroup, fg, bg, '')
                              endif
                              return hlGroup
                            endfunction
                            
                            " add matches for winid, use 0 for current window.
    4              0.000008 function! coc#highlight#match_ranges(winid, bufnr, ranges, hlGroup, priority) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
                              if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
                              endif
                              if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
                              endif
                              let ids = []
                              for range in a:ranges
                                let pos = []
                                let start = range['start']
                                let end = range['end']
                                for lnum in range(start['line'] + 1, end['line'] + 1)
                                  let arr = getbufline(bufnr, lnum)
                                  let line = empty(arr) ? '' : arr[0]
                                  if empty(line)
                                    continue
                                  endif
                                  let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
                                  let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
                                  if colStart == colEnd
                                    continue
                                  endif
                                  call add(pos, [lnum, colStart, colEnd - colStart])
                                endfor
                                if !empty(pos)
                                  let opts = s:clear_match_by_window ? {'window': a:winid} : {}
                                  let i = 1
                                  let l = []
                                  for p in pos
                                    call add(l, p)
                                    if i % 8 == 0
                                      let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                      call add(ids, id)
                                      let l = []
                                    endif
                                    let i += 1
                                  endfor
                                  if !empty(l)
                                    let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                    call add(ids, id)
                                  endif
                                endif
                              endfor
                              if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
                              endif
                              return ids
                            endfunction
                            
                            " Clear matches by hlGroup regexp.
    4              0.000006 function! coc#highlight#clear_match_group(winid, match) abort
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Clear matches by match ids, use 0 for current win.
    4              0.000006 function! coc#highlight#clear_matches(winid, ids)
                              let winid = a:winid == 0 ? win_getid() : a:winid
                              if empty(getwininfo(winid))
                                " not valid
                                return
                              endif
                              if s:clear_match_by_window
                                for id in a:ids
                                  try
                                    call matchdelete(id, winid)
                                  catch /^Vim\%((\a\+)\)\=:E803/
                                    " ignore
                                  endtry
                                endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  for id in a:ids
                                    try
                                      call matchdelete(id)
                                    catch /^Vim\%((\a\+)\)\=:E803/
                                      " ignore
                                    endtry
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
                              endif
                            endfunction
                            
                            " Sets the highlighting for the given group
    4              0.000014 function! s:create_gui_hlgroup(group, fg, bg, attr)
                              if a:fg != ""
                                exec "silent hi " . a:group . " guifg=" . a:fg . " ctermfg=" . coc#color#rgb2term(strpart(a:fg, 1))
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " guibg=" . a:bg . " ctermbg=" . coc#color#rgb2term(strpart(a:bg, 1))
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " gui=" . a:attr . " cterm=" . a:attr
                              endif
                            endfun
                            
    4              0.000007 function! s:create_cterm_hlgroup(group, fg, bg, attr) abort
                              if a:fg != ""
                                exec "silent hi " . a:group . " ctermfg=" . a:fg
                              endif
                              if a:bg != ""
                                exec "silent hi " . a:group . " ctermbg=" . a:bg
                              endif
                              if a:attr != ""
                                exec "silent hi " . a:group . " cterm=" . a:attr
                              endif
                            endfunction
                            
    4              0.000005 function! s:execute(winid, cmd) abort
                              if has('nvim')
                                execute 'silent! ' a:cmd
                              else
                                call win_execute(a:winid, a:cmd, 'silent!')
                              endif
                            endfunction
                            
    4              0.000005 function! s:prop_type_hlgroup(type) abort
                              if a:type=~# '^CocHighlight'
                                return a:type[12:]
                              endif
                              return prop_type_get(a:type)['highlight']
                            endfunction
                            
    4              0.000006 function! coc#highlight#create_namespace(key) abort
                              if type(a:key) == 0
                                return a:key
                              endif
                              if has_key(s:namespace_map, a:key)
                                return s:namespace_map[a:key]
                              endif
                              if has('nvim')
                                let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
                              endif
                              return s:namespace_map[a:key]
                            endfunction

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim
Sourced 1 time
Total time:   0.000471
 Self time:   0.000471

count  total (s)   self (s)
                            " illuminate.vim - Vim plugin for selectively illuminating other uses of current word
                            " Maintainer:	Adam P. Regasz-Rethy (RRethy) <rethy.spud@gmail.com>
                            " Version: 0.4
                            
    1              0.000011 let s:previous_match = ''
    1              0.000005 let s:enabled = 1
                            
    1              0.000026 let g:Illuminate_delay = get(g:, 'Illuminate_delay', 0)
    1              0.000013 let g:Illuminate_highlightUnderCursor = get(g:, 'Illuminate_highlightUnderCursor', 1)
    1              0.000012 let g:Illuminate_highlightPriority = get(g:, 'Illuminate_highlightPriority', -1)
                            
    1              0.000009 fun! illuminate#on_cursor_moved() abort
                              if !s:should_illuminate_file()
                                return
                              endif
                            
                              if s:previous_match !=# s:get_cur_word()
                                call s:remove_illumination()
                              elseif get(g:, 'Illuminate_highlightUnderCursor', 1) == 0 || hlexists('illuminatedCurWord')
                                call s:remove_illumination()
                                call s:illuminate()
                                return
                              else
                                return
                              endif
                            
                              " Any delay at or below 17 milliseconds gets counted as no delay
                              if !has('timers') || g:Illuminate_delay <= 17
                                call s:illuminate()
                                return
                              endif
                            
                              if exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                              endif
                            
                              let s:timer_id = timer_start(g:Illuminate_delay, function('s:illuminate'))
                            endf
                            
    1              0.000005 fun! illuminate#on_leaving_autocmds() abort
                              if s:should_illuminate_file()
                                call s:remove_illumination()
                              endif
                            endf
                            
    1              0.000004 fun! illuminate#on_cursor_moved_i() abort
                              if get(g:, 'Illuminate_insert_mode_highlight', 0)
                                call illuminate#on_cursor_moved()
                              endif
                            endf
                            
    1              0.000004 fun! illuminate#on_insert_entered() abort
                              if !get(g:, 'Illuminate_insert_mode_highlight', 0) && s:should_illuminate_file()
                                call s:remove_illumination()
                              endif
                            endf
                            
    1              0.000006 fun! illuminate#toggle_illumination(bufonly) abort
                              if a:bufonly
                                let b:illuminate_enabled = get(b:, 'illuminate_enabled', s:enabled)
                                if !b:illuminate_enabled
                                  call illuminate#enable_illumination(1)
                                else
                                  call illuminate#disable_illumination(1)
                                endif
                              else
                                if !s:enabled
                                  call illuminate#enable_illumination(0)
                                else
                                  call illuminate#disable_illumination(0)
                                endif
                              endif
                            endf
                            
    1              0.000005 fun! illuminate#disable_illumination(bufonly) abort
                              if a:bufonly
                                let b:illuminate_enabled = 0
                              else
                                let s:enabled = 0
                              endif
                              call s:remove_illumination()
                            endf
                            
    1              0.000004 fun! illuminate#enable_illumination(bufonly) abort
                              if a:bufonly
                                let b:illuminate_enabled = 1
                              else
                                let s:enabled = 1
                              endif
                              if s:should_illuminate_file()
                                call s:illuminate()
                              endif
                            endf
                            
    1              0.000007 fun! s:illuminate(...) abort
                              if !get(b:, 'illuminate_enabled', s:enabled)
                                return
                              endif
                            
                              call s:remove_illumination()
                            
                              if s:should_illuminate_word()
                                call s:match_word(s:get_cur_word())
                              endif
                              let s:previous_match = s:get_cur_word()
                            endf
                            
    1              0.000005 fun! s:match_word(word) abort
                              if (a:word ==# '\<\>')
                                return
                              endif
                              if g:Illuminate_highlightUnderCursor
                                if hlexists('illuminatedCurWord')
                                  let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
                                  let w:match_curword_id = matchadd('illuminatedCurWord', '\V\(\k\*\%#\k\*\)\&' . a:word, g:Illuminate_highlightPriority)
                                else
                                  let w:match_id = matchadd('illuminatedWord', '\V' . a:word, g:Illuminate_highlightPriority)
                                endif
                              else
                                let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
                              endif
                            endf
                            
    1              0.000004 fun! s:get_cur_word() abort
                              let line = getline('.')
                              let col = col('.') - 1
                              let left_part = strpart(line, 0, col + 1)
                              let right_part = strpart(line, col, col('$'))
                              let word = matchstr(left_part, '\k*$') . matchstr(right_part, '^\k*')[1:]
                            
                              return '\<' . escape(word, '/\') . '\>'
                            endf
                            
    1              0.000005 fun! s:remove_illumination() abort
                              if has('timers') && exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                                let s:timer_id = -1
                              endif
                            
                              if exists('w:match_id')
                                try
                                  call matchdelete(w:match_id)
                                catch /\v(E803|E802)/
                                endtry
                              endif
                            
                              if exists('w:match_curword_id')
                                try
                                  call matchdelete(w:match_curword_id)
                                catch /\v(E803|E802)/
                                endtry
                              endif
                            
                              let s:previous_match = ''
                            endf
                            
    1              0.000010 fun! s:should_illuminate_file() abort
                              let g:Illuminate_ftblacklist = get(g:, 'Illuminate_ftblacklist', [])
                              let g:Illuminate_ftwhitelist = get(g:, 'Illuminate_ftwhitelist', [])
                            
                              return !s:list_contains_pat(g:Illuminate_ftblacklist, &filetype)
                                    \ && (empty(g:Illuminate_ftwhitelist) || s:list_contains_pat(g:Illuminate_ftwhitelist, &filetype))
                            endf
                            
    1              0.000004 fun! s:should_illuminate_word() abort
                              let ft_hl_groups = get(g:, 'Illuminate_ftHighlightGroups', {})
                              let hl_groups_whitelist = get(ft_hl_groups, &filetype, [])
                              call extend(hl_groups_whitelist, get(ft_hl_groups, '*', []))
                              if empty(hl_groups_whitelist)
                                let hl_groups_blacklist = get(ft_hl_groups, &filetype.':blacklist', [])
                                call extend(hl_groups_blacklist, get(ft_hl_groups, '*:blacklist', []))
                                if empty(hl_groups_blacklist)
                                  return 1
                                else
                                  return index(hl_groups_blacklist, synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) < 0
                                        \ && index(hl_groups_blacklist, synIDattr(synID(line('.'), col('.'), 1), 'name')) < 0
                                endif
                              endif
                            
                              return index(ft_hl_groups[&filetype], synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) >= 0
                                    \ || index(ft_hl_groups[&filetype], synIDattr(synID(line('.'), col('.'), 1), 'name')) >= 0
                            endf
                            
    1              0.000005 fun! s:dict_has_key_pat(d, key) abort
                              for [k, v] in items(a:d)
                                if key =~# '^'.k.'$'
                                  return 1
                                endif
                              endfor
                              return 0
                            endfun
                            
    1              0.000005 fun! s:list_contains_pat(list, val) abort
                              for pat in a:list
                                if a:val =~# '^'.pat.'$'
                                  return 1
                                endif
                              endfor
                              return 0
                            endfun
                            
                            " vim: foldlevel=1 foldmethod=expr tabstop=2 softtabstop=2 shiftwidth=2

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-doge/autoload/doge/comment.vim
Sourced 1 time
Total time:   0.000165
 Self time:   0.000157

count  total (s)   self (s)
    1              0.000006 let s:save_cpo = &cpoptions
    1              0.000007 set cpoptions&vim
                            
    1   0.000019   0.000011 let s:comment_placeholder = doge#helpers#placeholder()
                            
                            " vint: next-line -ProhibitUnusedVariable
    1              0.000003 function! s:jump_forward() abort
                              let @/ = s:comment_placeholder
                              let l:next_pos = searchpos(s:comment_placeholder, 'nW')
                              let l:cpos = getpos('.')
                              let l:cpos[1] = l:next_pos[0]
                              let l:cpos[2] = l:next_pos[1]
                            
                              if (l:next_pos[0] > b:doge_interactive['lnum_comment_end_pos'] || l:next_pos[0] == 0)
                                \ && g:doge_comment_jump_wrap == v:true
                                " If we have more TODO items below the comment or we are at the last TODO
                                " inside the comment, then we'll go backward to the start position of the
                                " comment so we can continue to cycle.
                                return "\<Esc>:" . b:doge_interactive['lnum_comment_start_pos'] . "\<CR>^:call search('" . s:comment_placeholder . "')\<CR>gno\<C-g>"
                              endif
                            
                              " Check if the next pos we want to jump to is still inside the comment.
                              if l:next_pos[0] != 0 && l:next_pos[0] <= b:doge_interactive['lnum_comment_end_pos']
                                if mode() ==# 'i'
                                  return "\<C-o>:call setpos('.', " . string(l:cpos) . ")\<CR>\<C-o>gno\<C-g>"
                                elseif mode() ==# 's'
                                  return "\<Esc>:call setpos('.', " . string(l:cpos) . ")\<CR>gno\<C-g>"
                                elseif mode() ==# 'n'
                                  return ":call setpos('.', " . string(l:cpos) . ")\<CR>gno\<C-g>"
                                else
                                  return "viw\<C-g>"
                                endif
                              elseif expand('<cword>') ==# s:comment_placeholder && mode() ==# 'i'
                                return "\<C-o>viw\<C-g>"
                              endif
                            
                              " No more next TODOs found.
                              return 0
                            endfunction
                            
                            " vint: next-line -ProhibitUnusedVariable
    1              0.000002 function! s:jump_backward() abort
                              let @/ = s:comment_placeholder
                              let l:prev_pos = searchpos(s:comment_placeholder, 'bnW')
                              let l:cpos = getpos('.')
                              let l:cpos[1] = l:prev_pos[0]
                              let l:cpos[2] = l:prev_pos[1]
                            
                              if (l:prev_pos[0] < b:doge_interactive['lnum_comment_start_pos'] || l:prev_pos[0] == 0)
                                \ && g:doge_comment_jump_wrap == v:true
                                " If we have more TODO items above the comment or we are at the first TODO
                                " inside the comment, then we'll go forward to the end position of the
                                " comment so we can continue to cycle.
                                return "\<Esc>:" . b:doge_interactive['lnum_comment_end_pos'] . "\<CR>$:call search('" . s:comment_placeholder . "', 'b')\<CR>gno\<C-g>"
                              endif
                            
                              " Check if the prev pos we want to jump to is still inside the comment.
                              if l:prev_pos[0] != 0 && l:prev_pos[0] >= b:doge_interactive['lnum_comment_start_pos']
                                if mode() ==# 'i'
                                  return "\<C-o>:call setpos('.', " . string(l:cpos) . ")\<CR>\<C-o>gNo\<C-g>"
                                elseif mode() ==# 's'
                                  return "\<Esc>:call setpos('.', " . string(l:cpos) . ")\<CR>gno\<C-g>"
                                elseif mode() ==# 'n'
                                  return ":call setpos('.', " . string(l:cpos) . ")\<CR>gno\<C-g>"
                                else
                                  return "viW\<C-g>"
                                endif
                              elseif expand('<cword>') ==# s:comment_placeholder && mode() ==# 'i'
                                return "\<C-o>viw\<C-g>"
                              endif
                            
                              " No more previous TODOs found.
                              return 0
                            endfunction
                            
                            ""
                            " @public
                            " Jumps to the previous and next TODO item in the comment based on the b:doge_interactive
                            " variable. Requires @setting(g:doge_comment_interactive) to be enabled.
                            " The {direction} can be of the following values: 'forward' | 'backward'
    1              0.000003 function! doge#comment#jump(direction) abort
                              let l:regular_mapping = doge#helpers#keyseq(get(g:, 'doge_mapping_comment_jump_' . a:direction))
                            
                              if exists('b:doge_interactive')
                                " Quit interactive mode if the cursor is outside of the comment.
                                if line('.') < b:doge_interactive['lnum_comment_start_pos'] || line('.') > b:doge_interactive['lnum_comment_end_pos']
                                  call doge#deactivate()
                                  return l:regular_mapping
                                endif
                            
                                let l:todo_count = doge#helpers#count(
                                      \ s:comment_placeholder,
                                      \ b:doge_interactive['lnum_comment_start_pos'],
                                      \ b:doge_interactive['lnum_comment_end_pos']
                                      \ )
                                if l:todo_count > 0
                                  " We update the interactive comment info also when jumping which fixes the
                                  " scenario if a user is using visual mode in-between the jumping to maybe
                                  " delete some lines.
                                  call doge#comment#update_interactive_comment_info()
                            
                                  let l:jump_keyseq = call(printf('s:jump_%s', a:direction), [])
                                  if l:jump_keyseq != v:false
                                    return l:jump_keyseq
                                  endif
                                else
                                  " All the TODO items have been resolved, so we're done.
                                  call doge#deactivate()
                                endif
                              endif
                            
                              " If none of the above returned anything, we will return the key itself.
                              return l:regular_mapping
                            endfunction
                            
                            ""
                            " @public
                            " This function is trigged by the auto-command TextChangedI and will update the
                            " b:doge_interactive variable where needed. Requires
                            " @setting(g:doge_comment_interactive) to be enabled.
    1              0.000002 function! doge#comment#update_interactive_comment_info() abort
                              if exists('b:doge_interactive')
                                " Only update if the cursor is inside the comment.
                                " We add +1 to the lnum_comment_end_pos which covers the scenario if a user
                                " pressed ENTER while being on the last line of the comment.
                                if line('.') > b:doge_interactive['lnum_comment_start_pos'] && line('.') <= b:doge_interactive['lnum_comment_end_pos'] + 1
                                  " When filling in the TODO items the user might hit the ENTER key so we
                                  " constantly have to update the end position of the comment, because the
                                  " comment can get bigger.
                            
                                  " We will use a while loop because of languages like lua and ruby which
                                  " use single-line comments which gives us no separation if we have a lua
                                  " comment like this:
                                  "
                                  "   -- TODO
                                  "   -- @param arg1 TODO
                                  "   -- @param arg2 I can aplp
                                  "   -- @param arg3 TODO
                                  "   -- @param arg4 TODO
                                  "   function new_function(arg1, arg2, arg3, arg4)
                                  "   end
                                  "
                                  " So the idea is to just loop through every line until we come across a
                                  " non-comment line.
                                  let l:lnum_comment_end_pos = line('.')
                                  let l:comment_last_line = doge#helpers#trim(b:doge_interactive['comment'][-1])[0]
                                  while doge#helpers#trim(getline(l:lnum_comment_end_pos)) =~# printf('\m^%s', l:comment_last_line)
                                    let l:lnum_comment_end_pos += 1
                                  endwhile
                            
                                  " If we're still at the same line we're probably dealing with python
                                  " comments (or something equivalent) where it only has an opener and
                                  " closer and each comment line does not start with a comment leader, so
                                  " just search for the last line of the comment
                                  if l:lnum_comment_end_pos == line('.')
                                    let l:lnum_comment_end_pos = search(l:comment_last_line, 'nW')
                                  endif
                            
                                  let b:doge_interactive['lnum_comment_end_pos'] = l:lnum_comment_end_pos - 1
                                endif
                              endif
                            endfunction
                            
                            ""
                            " @public
                            " This function is trigged by the auto-commands InsertLeave and TextChanged and
                            " will deactivate doge when there are no more TODO items left. Requires
                            " @setting(g:doge_comment_interactive) to be enabled.
    1              0.000002 function! doge#comment#deactivate_when_done(...) abort
                              if exists('b:doge_interactive')
                                let l:pos = getcurpos()[1:2]
                                call cursor(b:doge_interactive['lnum_comment_start_pos'], 1)
                                if search(s:comment_placeholder, 'W', b:doge_interactive['lnum_comment_end_pos']) == v:false
                                  call doge#deactivate()
                                endif
                                call cursor(l:pos)
                              endif
                            endfunction
                            
    1              0.000006 let &cpoptions = s:save_cpo
    1              0.000004 unlet s:save_cpo

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/detect.vim
Sourced 1 time
Total time:   0.000459
 Self time:   0.000459

count  total (s)   self (s)
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000017 let s:cpo_save = &cpo
    1              0.000014 set cpo&vim
                            
                            " DO NOT EDIT CODE BELOW, IT IS GENERATED WITH MAKEFILE
                            
    1              0.000004 func! polyglot#detect#Inp(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              let line = getline(nextnonblank(1))
                              if line =~# '^\*'
                                set ft=abaqus | return
                              endif
                              for lnum in range(1, min([line("$"), 500]))
                                let line = getline(lnum)
                                if line =~? '^header surface data'
                                  set ft=trasys | return
                                endif
                              endfor
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Asa(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              if exists("g:filetype_asa")
                                let &ft = g:filetype_asa | return
                              endif
                              set ft=aspvbs | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#Asp(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              if exists("g:filetype_asp")
                                let &ft = g:filetype_asp | return
                              endif
                              for lnum in range(1, min([line("$"), 3]))
                                let line = getline(lnum)
                                if line =~? 'perlscript'
                                  set ft=aspperl | return
                                endif
                              endfor
                              set ft=aspvbs | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#H(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 200]))
                                let line = getline(lnum)
                                if line =~# '^\s*\(@\(interface\|class\|protocol\|property\|end\|synchronised\|selector\|implementation\)\(\<\|\>\)\|#import\s\+.\+\.h[">]\)'
                                  if exists('g:c_syntax_for_h')
                                    set ft=objc | return
                                  endif
                                  set ft=objcpp | return
                                endif
                              endfor
                              if exists('g:c_syntax_for_h')
                                set ft=c | return
                              endif
                              if exists('g:ch_syntax_for_h')
                                set ft=ch | return
                              endif
                              set ft=cpp | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#M(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              let saw_comment = 0
                              for lnum in range(1, min([line("$"), 100]))
                                let line = getline(lnum)
                                if line =~# '^\s*/\*'
                                  let saw_comment = 1
                                endif
                                if line =~# '^\s*\(@\(interface\|class\|protocol\|property\|end\|synchronised\|selector\|implementation\)\(\<\|\>\)\|#import\s\+.\+\.h[">]\)'
                                  set ft=objc | return
                                endif
                                if line =~# '^\s*%'
                                  if !has_key(g:polyglot_is_disabled, 'octave')
                                    set ft=octave | return
                                  endif
                                endif
                                if line =~# '^\s*%'
                                  if has_key(g:polyglot_is_disabled, 'octave')
                                    set ft=matlab | return
                                  endif
                                endif
                                if line =~# '^\s*(\*'
                                  set ft=mma | return
                                endif
                                if line =~? '^\s*\(\(type\|var\)\(\<\|\>\)\|--\)'
                                  set ft=murphi | return
                                endif
                              endfor
                              if saw_comment
                                set ft=objc | return
                              endif
                              if exists("g:filetype_m")
                                let &ft = g:filetype_m | return
                              endif
                              if !has_key(g:polyglot_is_disabled, 'octave')
                                set ft=octave | return
                              endif
                              if has_key(g:polyglot_is_disabled, 'octave')
                                set ft=matlab | return
                              endif
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Fs(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '^\(: \|new-device\)'
                                  set ft=forth | return
                                endif
                                if line =~# '^\s*\(#light\|import\|let\|module\|namespace\|open\|type\)'
                                  set ft=fsharp | return
                                endif
                                if line =~# '\s*\(#version\|precision\|uniform\|varying\|vec[234]\)'
                                  set ft=glsl | return
                                endif
                              endfor
                              if exists("g:filetype_fs")
                                let &ft = g:filetype_fs | return
                              endif
                              set ft=forth | return
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Re(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '^\s*#\%(\%(if\|ifdef\|define\|pragma\)\s\+\w\|\s*include\s\+[<"]\|template\s*<\)'
                                  set ft=cpp | return
                                endif
                                set ft=reason | return
                              endfor
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Idr(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 5]))
                                let line = getline(lnum)
                                if line =~# '^\s*--.*[Ii]dris \=1'
                                  set ft=idris | return
                                endif
                                if line =~# '^\s*--.*[Ii]dris \=2'
                                  set ft=idris2 | return
                                endif
                              endfor
                              for lnum in range(1, min([line("$"), 30]))
                                let line = getline(lnum)
                                if line =~# '^pkgs =.*'
                                  set ft=idris | return
                                endif
                                if line =~# '^depends =.*'
                                  set ft=idris2 | return
                                endif
                                if line =~# '^%language \(TypeProviders\|ElabReflection\)'
                                  set ft=idris | return
                                endif
                                if line =~# '^%language PostfixProjections'
                                  set ft=idris2 | return
                                endif
                                if line =~# '^%access .*'
                                  set ft=idris | return
                                endif
                              endfor
                              if exists("g:filetype_idr")
                                let &ft = g:filetype_idr | return
                              endif
                              set ft=idris2 | return
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Lidr(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 200]))
                                let line = getline(lnum)
                                if line =~# '^>\s*--.*[Ii]dris \=1'
                                  set ft=lidris | return
                                endif
                              endfor
                              set ft=lidris2 | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#Bas(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 5]))
                                let line = getline(lnum)
                                if line =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                  set ft=vb | return
                                endif
                              endfor
                              set ft=basic | return
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Pm(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              let line = getline(nextnonblank(1))
                              if line =~# 'XPM2'
                                set ft=xpm2 | return
                              endif
                              if line =~# 'XPM'
                                set ft=xpm | return
                              endif
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '^\s*\%(use\s\+v6\(\<\|\>\)\|\(\<\|\>\)module\(\<\|\>\)\|\(\<\|\>\)\%(my\s\+\)\=class\(\<\|\>\)\)'
                                  set ft=raku | return
                                endif
                                if line =~# '\(\<\|\>\)use\s\+\%(strict\(\<\|\>\)\|v\=5\.\)'
                                  set ft=perl | return
                                endif
                              endfor
                              if exists("g:filetype_pm")
                                let &ft = g:filetype_pm | return
                              endif
                              if polyglot#shebang#Detect() | return | endif
                              set ft=perl | return
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Pl(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              let line = getline(nextnonblank(1))
                              if line =~# '^[^#]*:-' || line =~# '^\s*\%(%\|/\*\)' || line =~# '\.\s*$'
                                set ft=prolog | return
                              endif
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '^\s*\%(use\s\+v6\(\<\|\>\)\|\(\<\|\>\)module\(\<\|\>\)\|\(\<\|\>\)\%(my\s\+\)\=class\(\<\|\>\)\)'
                                  set ft=raku | return
                                endif
                                if line =~# '\(\<\|\>\)use\s\+\%(strict\(\<\|\>\)\|v\=5\.\)'
                                  set ft=perl | return
                                endif
                              endfor
                              if exists("g:filetype_pl")
                                let &ft = g:filetype_pl | return
                              endif
                              if polyglot#shebang#Detect() | return | endif
                              set ft=perl | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#T(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 5]))
                                let line = getline(lnum)
                                if line =~# '^\.'
                                  set ft=nroff | return
                                endif
                              endfor
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '^\s*\%(use\s\+v6\(\<\|\>\)\|\(\<\|\>\)module\(\<\|\>\)\|\(\<\|\>\)\%(my\s\+\)\=class\(\<\|\>\)\)'
                                  set ft=raku | return
                                endif
                                if line =~# '\(\<\|\>\)use\s\+\%(strict\(\<\|\>\)\|v\=5\.\)'
                                  set ft=perl | return
                                endif
                              endfor
                              if exists("g:filetype_t")
                                let &ft = g:filetype_t | return
                              endif
                              if polyglot#shebang#Detect() | return | endif
                              set ft=perl | return
                            endfunc
                            
    1              0.000002 func! polyglot#detect#Tt2(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              for lnum in range(1, min([line("$"), 3]))
                                let line = getline(lnum)
                                if line =~? '<\%(!DOCTYPE HTML\|[%?]\|html\)'
                                  set ft=tt2html | return
                                endif
                              endfor
                              set ft=tt2 | return
                            endfunc
                            
    1              0.000001 func! polyglot#detect#Html(...)
                              if a:0 != 1 && did_filetype()
                                return
                              endif
                              let line = getline(nextnonblank(1))
                              if line =~# '^\(%\|<[%&].*>\)'
                                set ft=mason | return
                              endif
                              for lnum in range(1, min([line("$"), 50]))
                                let line = getline(lnum)
                                if line =~# '{%-\=\s*\(end.*\|extends\|block\|macro\|set\|if\|for\|include\|trans\|load\)\(\<\|\>\)\|{#\s\+'
                                  set ft=htmldjango | return
                                endif
                                if line =~# '\(\<\|\>\)DTD\s\+XHTML\s'
                                  set ft=xhtml | return
                                endif
                              endfor
                              set ft=html | return
                            endfunc
                            
                            " DO NOT EDIT CODE ABOVE, IT IS GENERATED WITH MAKEFILE
                            
    1              0.000010 let &cpo = s:cpo_save
    1              0.000004 unlet s:cpo_save

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/ft.vim
Sourced 1 time
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
                            " Vim functions for file type detection
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2020 Aug 17
                            
                            " These functions are moved here from runtime/filetype.vim to make startup
                            " faster.
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000008 let s:cpo_save = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 func polyglot#ft#Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    1              0.000001 func polyglot#ft#FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call polyglot#ft#FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    1              0.000001 func polyglot#ft#FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" or "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    1              0.000001 func polyglot#ft#FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
    1              0.000001 func polyglot#ft#ExCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              elseif match(lines, '^--\|^ifdef\>\|^include\>') > -1
                                setf euphoria3
                              else
                                setf elixir
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n <= line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                            	setf specman
                            	return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " Distinguish between HTML, XHTML and Django
    1              0.000001 func polyglot#ft#FThtml()
                              let n = 1
                              while n < 10 && n <= line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>\|{#\s\+'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf FALLBACK html
                            endfunc
                            
                            " Distinguish between standard IDL and MS-IDL
    1              0.000001 func polyglot#ft#FTidl()
                              let n = 1
                              while n < 50 && n <= line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Distinguish between "default" and Cproto prototype file. */
    1              0.000001 func polyglot#ft#ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTm()
                              let n = 1
                              let saw_comment = 0 " Whether we've seen a multiline comment leader.
                              while n < 100
                                let line = getline(n)
                                if line =~ '^\s*/\*'
                                  " /* ... */ is a comment in Objective C and Murphi, so we can't conclude
                                  " it's either of them yet, but track this as a hint in case we don't see
                                  " anything more definitive.
                                  let saw_comment = 1
                                endif
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                if line =~ '^\c\s*\(\(type\|var\)\>\|--\)'
                                  setf murphi
                                  return
                                endif
                                let n = n + 1
                              endwhile
                            
                              if saw_comment
                                " We didn't see anything definitive, but this looks like either Objective C
                                " or Murphi based on the comment leader. Assume the former as it is more
                                " common.
                                setf objc
                              elseif exists("g:filetype_m")
                                " Use user specified default filetype for .m
                                exe "setf " . g:filetype_m
                              else
                                " Default is matlab
                                setf matlab
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTmms()
                              let n = 1
                              while n < 20
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    1              0.000002 func polyglot#ft#FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTmm()
                              let n = 1
                              while n < 20
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|@import\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                " Pascal supports // comments but they're vary rarely used for file
                                " headers so assume POV-Ray
                                elseif lines =~ '^\s*\%({\|(\*\)' || lines =~? s:ft_pascal_keywords
                                  setf pascal
                                else
                                  call polyglot#ft#FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call polyglot#ft#FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
    1              0.000003 let s:ft_pascal_comments = '^\s*\%({\|(\*\|//\)'
    1              0.000002 let s:ft_pascal_keywords = '^\s*\%(program\|unit\|library\|uses\|begin\|procedure\|function\|const\|type\|var\)\>'
                            
    1              0.000001 func polyglot#ft#FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTpp()
                              if exists("g:filetype_pp")
                                exe "setf " . g:filetype_pp
                              else
                                let line = getline(nextnonblank(1))
                                if line =~ s:ft_pascal_comments || line =~? s:ft_pascal_keywords
                                  setf pascal
                                else
                                  setf puppet
                                endif
                              endif
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
    1              0.000002 func polyglot#ft#McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Called from filetype.vim and scripts.vim.
    1              0.000001 func polyglot#ft#SetFileTypeSH(name)
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call polyglot#ft#SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call polyglot#ft#SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call polyglot#ft#SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call polyglot#ft#SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    1              0.000001 func polyglot#ft#SetFileTypeShell(name)
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
    1              0.000001 func polyglot#ft#CSH()
                              if did_filetype()
                                " Filetype was already detected
                                return
                              endif
                              if exists("g:filetype_csh")
                                call polyglot#ft#SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call polyglot#ft#SetFileTypeShell("tcsh")
                              else
                                call polyglot#ft#SetFileTypeShell("csh")
                              endif
                            endfunc
                            
    1              0.000002 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    1              0.000001 func polyglot#ft#FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|\%(usr/\)\=lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                            	setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
    1              0.000001 func polyglot#ft#SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    1              0.000002 func polyglot#ft#FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              let save_cursor = getpos('.')
                              call cursor(1,1)
                              let has_use = search('^use\s\s*\k', 'c', 30)
                              call setpos('.', save_cursor)
                              if has_use
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "plain" or to g:tex_flavor, can be set in user's vimrc.
    1              0.000001 func polyglot#ft#FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'latex'
                                elseif format == 'plaintex'
                                  let format = 'plain'
                                endif
                              elseif expand('%') =~ 'tex/context/.*/.*.tex'
                                let format = 'context'
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTxml()
                              let n = 1
                              while n < 100 && n <= line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
    1              0.000001 func polyglot#ft#FTy()
                              let n = 1
                              while n < 100 && n <= line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
    1              0.000001 func polyglot#ft#Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            
                            " Restore 'cpoptions'
    1              0.000007 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buffer.vim
Sourced 1 time
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
                            " ============================================================================
                            " FileName: buffer.vim
                            " Author: voldikss <dyzplus@gmail.com>
                            " GitHub: https://github.com/voldikss
                            " ============================================================================
                            
    1              0.000008 function! floaterm#buffer#create_scratch_buf(...) abort
                              let bufnr = nvim_create_buf(v:false, v:true)
                              call nvim_buf_set_option(bufnr, 'buftype', 'nofile')
                              call nvim_buf_set_option(bufnr, 'buftype', 'nofile')
                              call nvim_buf_set_option(bufnr, 'bufhidden', 'wipe')
                              call nvim_buf_set_option(bufnr, 'swapfile', v:false)
                              call nvim_buf_set_option(bufnr, 'undolevels', -1)
                              let lines = get(a:, 1, v:null)
                              if type(lines) != 7
                                call nvim_buf_set_option(bufnr, 'modifiable', v:true)
                                call nvim_buf_set_lines(bufnr, 0, -1, v:false, lines)
                                call nvim_buf_set_option(bufnr, 'modifiable', v:false)
                              endif
                              return bufnr
                            endfunction
                            
    1              0.000002 function! floaterm#buffer#create_border_buf(options) abort
                              let repeat_width = a:options.width - 2
                              let repeat_height = a:options.height - 2
                              let title = a:options.title
                              let title_width = strdisplaywidth(title)
                              let borderchars = a:options.borderchars
                              let [c_top, c_right, c_bottom, c_left, c_topleft, c_topright, c_botright, c_botleft] = borderchars
                              let content = [c_topleft . title . repeat(c_top, repeat_width - title_width) . c_topright]
                              let content += repeat([c_left . repeat(' ', repeat_width) . c_right], repeat_height)
                              let content += [c_botleft . repeat(c_bottom, repeat_width) . c_botright]
                              return floaterm#buffer#create_scratch_buf(content)
                            endfunction
                            
    1              0.000002 function! floaterm#buffer#getlines(bufnr, length) abort
                              let lines = []
                              if a:bufnr == -1
                                for bufnr in floaterm#buflist#gather()
                                  let lnum = getbufinfo(bufnr)[0]['lnum']
                                  let lines += getbufline(bufnr, max([lnum - a:length, 0]), '$')
                                endfor
                              else
                                let lnum = getbufinfo(a:bufnr)[0]['lnum']
                                let lines += getbufline(a:bufnr, max([lnum - a:length, 0]), '$')
                              endif
                              return lines
                            endfunction

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buflist.vim
Sourced 1 time
Total time:   0.000171
 Self time:   0.000162

count  total (s)   self (s)
                            " vim:sw=2:
                            " ============================================================================
                            " FileName: buflist.vim
                            " Author: voldikss <dyzplus@gmail.com>
                            " GitHub: https://github.com/voldikss
                            " ============================================================================
                            
                            " ----------------------------------------------------------------------------
                            " Node type
                            " ----------------------------------------------------------------------------
                            
                            " @type
                            "   {
                            "     \'next': s:node,
                            "     \'prev': s:node,
                            "     \'bufnr': int
                            "   \}
    1              0.000004 let s:node = {}
                            
    1              0.000003 function! s:node.new(bufnr) dict abort
                              let node = deepcopy(self)
                              let node.bufnr = a:bufnr
                              return node
                            endfunction
                            
    1              0.000001 function! s:node.to_string() dict abort
                              return string(self.bufnr)
                            endfunction
                            
    1              0.000001 function! s:node.is_valid() dict abort
                              return bufexists(self.bufnr)
                            endfunction
                            
                            
                            " ----------------------------------------------------------------------------
                            " Linkedlist type and functions
                            " ----------------------------------------------------------------------------
                            
                            " @type
                            "   {
                            "     \'head': s:none,
                            "     \'index': s:node,
                            "     \'size': int
                            "   \}
    1              0.000001 let s:buflist = {}
    1   0.000019   0.000009 let s:buflist.head = s:node.new(-1)
    1              0.000002 let s:buflist.head.next = s:buflist.head
    1              0.000002 let s:buflist.head.prev = s:buflist.head
    1              0.000001 let s:buflist.index = s:buflist.head
    1              0.000001 let s:buflist.size = 0
                            
    1              0.000001 function! s:buflist.insert(node) dict abort
                              let a:node.prev = self.index
                              let a:node.next = self.index.next
                              let self.index.next.prev = a:node
                              let self.index.next = a:node
                              let self.index = a:node
                              let self.size += 1
                            endfunction
                            
    1              0.000001 function! s:buflist.remove(node) dict abort
                              if self.empty() || a:node == self.head
                                return v:false
                              endif
                              if bufexists(a:node.bufnr)
                                execute a:node.bufnr . 'bdelete!'
                              endif
                              let a:node.prev.next = a:node.next
                              let a:node.next.prev = a:node.prev
                              let self.index = a:node.next
                              let self.size -= 1
                              return v:true
                            endfunction
                            
    1              0.000001 function! s:buflist.empty() dict abort
                              " Method 1: use self.size
                              " return self.size == 0
                              " Method 2: only head node
                              return self.head.next == self.head
                            endfunction
                            
                            " Find next bufnr with bufexists(bufnr) == v:true
                            " If not found, return -1
                            " If bufexists(bufnr) != v:true, remove that node
    1              0.000001 function! s:buflist.next() dict abort
                              let node = self.index.next
                              while !node.is_valid()
                                call self.remove(node)
                                if self.empty()
                                  return -1
                                endif
                                let node = node.next
                              endwhile
                              let self.index = node
                              return node.bufnr
                            endfunction
                            
                            " Find prev bufnr with bufexists(bufnr) == v:true
                            " If not found, return -1
                            " If bufexists(bufnr) != v:true, remove that node
    1              0.000001 function! s:buflist.prev() dict abort
                              let node = self.index.prev
                              while !node.is_valid()
                                call self.remove(node)
                                if self.empty()
                                  return -1
                                endif
                                let node = node.prev
                              endwhile
                              let self.index = node
                              return node.bufnr
                            endfunction
                            
                            " Find current bufnr with bufexists(bufnr) == v:true
                            " If not found, find next and next
                            " If bufexists(bufnr) != v:true, remove that node
    1              0.000001 function! s:buflist.curr() dict abort
                              let node = self.index
                              while !node.is_valid()
                                call self.remove(node)
                                if self.empty()
                                  return -1
                                endif
                                let node = node.next
                              endwhile
                              let self.index = node
                              return node.bufnr
                            endfunction
                            
                            " Find the first bufnr with bufexists(bufnr) == v:true
                            " If bufexists(bufnr) != v:true, remove that node
    1              0.000001 function! s:buflist.first() dict abort
                              let node = self.head.next
                              while !node.is_valid()
                                call self.remove(node)
                                if self.empty()
                                  return -1
                                endif
                                let node = node.next
                              endwhile
                              let self.index = node
                              return node.bufnr
                            endfunction
                            
                            " Find the last bufnr with bufexists(bufnr) == v:true
                            " If bufexists(bufnr) != v:true, remove that node
    1              0.000001 function! s:buflist.last() dict abort
                              let node = self.head.prev
                              while !node.is_valid()
                                call self.remove(node)
                                if self.empty()
                                  return -1
                                endif
                                let node = node.prev
                              endwhile
                              let self.index = node
                              return node.bufnr
                            endfunction
                            
                            " Return buflist str, note that node.bufnr may not exist
    1              0.000001 function! s:buflist.to_string() dict abort
                              let str = '[-'
                              let curr = self.head
                              let str .= printf('(%s)', curr.to_string())
                              let curr = curr.next
                              while curr != self.head
                                let str .= printf('--(%s)', curr.to_string())
                                let curr = curr.next
                              endwhile
                              let str .= '-]'
                              let str .= ' current floaterm buffer number: ' . self.index.bufnr
                              return str
                            endfunction
                            
                            " For source extensions(vim-clap, denite)
                            " Return a list containing floaterm bufnr
                            " Every bufnr should exist
    1              0.000001 function! s:buflist.gather() dict abort
                              let candidates = []
                              let curr = self.head.next
                              while curr != self.head
                                if curr.is_valid()
                                  call add(candidates, curr.bufnr)
                                endif
                                let curr = curr.next
                              endwhile
                              return candidates
                            endfunction
                            
                            
                            " ----------------------------------------------------------------------------
                            " Wrap functions to allow to be involved
                            " ----------------------------------------------------------------------------
    1              0.000002 function! floaterm#buflist#add(bufnr) abort
                              let node = s:node.new(a:bufnr)
                              call s:buflist.insert(node)
                            endfunction
    1              0.000001 function! floaterm#buflist#next() abort
                              return s:buflist.next()
                            endfunction
    1              0.000001 function! floaterm#buflist#prev() abort
                              return s:buflist.prev()
                            endfunction
    1              0.000001 function! floaterm#buflist#curr() abort
                              return s:buflist.curr()
                            endfunction
    1              0.000001 function! floaterm#buflist#first() abort
                              return s:buflist.first()
                            endfunction
    1              0.000001 function! floaterm#buflist#last() abort
                              return s:buflist.last()
                            endfunction
    1              0.000001 function! floaterm#buflist#info() abort
                              echom s:buflist.to_string()
                            endfunction
    1              0.000001 function! floaterm#buflist#gather() abort
                              return s:buflist.gather()
                            endfunction
                            
                            
                            " ----------------------------------------------------------------------------
                            " UNIT TEST
                            " ----------------------------------------------------------------------------
    1              0.000001 function! floaterm#buflist#test() abort
                              let list = deepcopy(s:buflist)
                              echo list.index.bufnr
                              call list.insert(s:node.new(1))
                              echo list.index.bufnr
                              call list.insert(s:node.new(2))
                              echo list.index.bufnr
                              call list.insert(s:node.new(3))
                              echo list.index.bufnr
                              echo list.to_string()
                            endfunction
                            " call floaterm#buflist#test()
                            " ----------------------------------------------------------------------------

SCRIPT  /home/albertor/.config/nvim/autoload/plugged/loupe/autoload/loupe.vim
Sourced 1 time
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
                            " Copyright 2015-present Greg Hurrell. All rights reserved.
                            " Licensed under the terms of the BSD 2-clause license.
                            
                            ""
                            " @function loupe#hlmatch
                            "
                            " Apply highlighting to the current search match.
                            "
    1              0.000010 function! loupe#hlmatch() abort
                              ""
                              " @option g:LoupeHighlightGroup string IncSearch
                              " Specifies the |:highlight| group used to emphasize the match currently under
                              " the cursor for the current search pattern. Defaults to "IncSearch" (ie.
                              " |hl-IncSearch|). For example:
                              "
                              " ```
                              " let g:LoupeHighlightGroup='Error'
                              " ```
                              "
                              " To prevent any special highlighting from being applied, set this option to
                              " "" (ie. the empty string).
                              let l:highlight=get(g:, 'LoupeHighlightGroup', 'IncSearch')
                              if empty(l:highlight)
                                return
                              endif
                            
                              if has('autocmd')
                                augroup LoupeHightlightMatch
                                  autocmd!
                                augroup END
                              endif
                            
                              call loupe#private#clear_highlight()
                            
                              " \c case insensitive
                              " \%# current cursor position
                              " @/ current search pattern
                              let l:pattern='\c\%#' . @/
                            
                              if exists('*matchadd')
                                try
                                  let w:loupe_hlmatch=matchadd(l:highlight, l:pattern)
                                catch /.*/
                                  " Invalid search pattern.
                                endtry
                              endif
                            endfunction

FUNCTION  FugitiveExtractGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:256
Called 6 times
Total time:   0.002168
 Self time:   0.001458

count  total (s)   self (s)
    6   0.000035   0.000027   let path = s:Slash(a:path)
    6              0.000017   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
    6              0.000007   elseif empty(path)
                                return ''
    6              0.000020   elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
    6              0.000002   else
    6              0.000048     let path = fnamemodify(path, ':p:h:s?/$??')
    6              0.000003   endif
    6              0.000039   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    6              0.000012   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
    6              0.000002   endif
    6              0.000090   let root = resolve(path)
    6              0.000006   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
    6              0.000002   endif
    6              0.000006   let previous = ""
    6              0.000040   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    6   0.000080   0.000035   call s:Tree(env_git_dir)
   22              0.000025   while root !=# previous
   22              0.000076     if root =~# '\v^//%([^/]+/?)?$'
                                  break
   22              0.000006     endif
   22   0.000458   0.000124     if index(s:CeilingDirectories(), root) >= 0
                                  break
   22              0.000006     endif
   22              0.000058     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
   22              0.000034     elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
   22              0.000006     endif
   22              0.000139     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   22              0.000084     let type = getftype(dir)
   22   0.000152   0.000048     if type ==# 'dir' && FugitiveIsGitDir(dir)
    6              0.000004       return dir
   16              0.000019     elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
   16              0.000018     elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
   16   0.000288   0.000068     elseif FugitiveIsGitDir(root)
                                  return root
   16              0.000005     endif
   16              0.000015     let previous = root
   16              0.000030     let root = fnamemodify(root, ':h')
   16              0.000008   endwhile
                              return ''

FUNCTION  <SNR>69_sortByLength()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:467
Called 68 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   68              0.000196   return len(a:i2[0])-len(a:i1[0])

FUNCTION  coc#client#get_channel()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim:149
Called 565 times
Total time:   0.004373
 Self time:   0.004373

count  total (s)   self (s)
  565              0.001002   if s:is_vim
                                return a:client['channel']
  565              0.000384   endif
  565              0.001239   return a:client['chan_id']

FUNCTION  <SNR>192_list_contains_pat()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:193
Called 497 times
Total time:   0.006816
 Self time:   0.006816

count  total (s)   self (s)
  497              0.002148   for pat in a:list
                                if a:val =~# '^'.pat.'$'
                                  return 1
                                endif
  497              0.000774   endfor
  497              0.000750   return 0

FUNCTION  1()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:120
Called 3 times
Total time:   0.007565
 Self time:   0.000119

count  total (s)   self (s)
    3   0.000049   0.000023   let path = s:strip_trailing_new_line(a:path)
    3   0.000063   0.000024   call gitgutter#utility#setbufvar(a:buffer, 'path', path)
                            
    3              0.000011   if type(self.continuation) == type(function('tr'))
    3   0.007420   0.000040     call self.continuation()
                              else
                                call call(self.continuation.function, self.continuation.arguments)
    3              0.000004   endif

FUNCTION  6()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:14
Called 33 times
Total time:   0.005067
 Self time:   0.002792

count  total (s)   self (s)
   33              0.000131     let l:prependWorkingDir = 0
                            
   33   0.001017   0.000395     if nerdtree#runningWindows()
                                    let l:prependWorkingDir = a:pathStr !~# '^.:\(\\\|\/\)\?' && a:pathStr !~# '^\(\\\\\|\/\/\)'
   33              0.000043     else
   33              0.000324         let l:prependWorkingDir = a:pathStr !~# '^/'
   33              0.000039     endif
                            
   33              0.000128     let l:result = a:pathStr
                            
   33              0.000072     if l:prependWorkingDir
   26              0.000242         let l:result = getcwd()
                            
   26   0.001213   0.000319         if l:result[-1:] == nerdtree#slash()
                                        let l:result = l:result . a:pathStr
   26              0.000027         else
   26   0.001083   0.000325             let l:result = l:result . nerdtree#slash() . a:pathStr
   26              0.000023         endif
   33              0.000030     endif
                            
   33              0.000079     return l:result

FUNCTION  8()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:47
Called 160 times
Total time:   0.057691
 Self time:   0.010560

count  total (s)   self (s)
  160   0.003850   0.001468     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
  160              0.000187     if self.isExecutable
    4   0.000135   0.000037         let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
  160              0.000093     endif
                            
  160              0.000473     let self._bookmarkNames = []
  320   0.002691   0.001394     for i in g:NERDTreeBookmark.Bookmarks()
  160   0.044333   0.000978         if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
  160              0.000103         endif
  320              0.000305     endfor
  160              0.000588     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks ==# 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
  160              0.000097     endif
                            
  160              0.000218     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
  160              0.000087     endif
                            
  160              0.000183     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
  160              0.000081     endif

FUNCTION  9()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:74
Called 4 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    4              0.000070     if a:line =~# '\(.*' . g:NERDTreeNodeDelimiter . '\)\{2}'
                                    return a:line
    4              0.000003     else
    4              0.000012         return a:line . g:NERDTreeNodeDelimiter
                                endif

FUNCTION  illuminate#on_cursor_moved()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:12
Called 481 times
Total time:   0.203958
 Self time:   0.035928

count  total (s)   self (s)
  481   0.033209   0.007005   if !s:should_illuminate_file()
                                return
  481              0.000338   endif
                            
  481   0.029485   0.005597   if s:previous_match !=# s:get_cur_word()
  355   0.020590   0.003998     call s:remove_illumination()
  126              0.005191   elseif get(g:, 'Illuminate_highlightUnderCursor', 1) == 0 || hlexists('illuminatedCurWord')
                                call s:remove_illumination()
                                call s:illuminate()
                                return
  126              0.000111   else
  126              0.000130     return
  355              0.000234   endif
                            
                              " Any delay at or below 17 milliseconds gets counted as no delay
  355              0.001789   if !has('timers') || g:Illuminate_delay <= 17
  355   0.104546   0.003201     call s:illuminate()
  355              0.000380     return
                              endif
                            
                              if exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                              endif
                            
                              let s:timer_id = timer_start(g:Illuminate_delay, function('s:illuminate'))

FUNCTION  <SNR>177_process_removed()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:302
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000003   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
    3              0.000002   else
    3              0.000009     call add(a:modifications, [a:to_line, 'removed'])
    3              0.000001   endif

FUNCTION  <SNR>177_save_last_seen_change()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:415
Called 5 times
Total time:   0.000139
 Self time:   0.000059

count  total (s)   self (s)
    5   0.000136   0.000056   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter.vim:21
Called 20 times
Total time:   0.028961
 Self time:   0.001598

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   20   0.003961   0.000202   if gitgutter#utility#is_active(a:bufnr)
                            
   14              0.000065     if has('patch-7.4.1559')
   14              0.000101       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   14              0.000009     endif
   14   0.006373   0.000144     let how = s:setup_path(a:bufnr, l:Callback)
   14              0.000042     if [how] == ['async']  " avoid string-to-number conversion if how is a number
    3              0.000002       return
   11              0.000006     endif
                            
   11   0.000340   0.000110     if a:force || s:has_fresh_changes(a:bufnr)
                            
    5              0.000006       let diff = 'NOT SET'
    5              0.000003       try
    5   0.017249   0.000104         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    5              0.000005       endtry
                            
    5              0.000015       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    5              0.000002       endif
                            
   11              0.000006     endif
   17              0.000010   endif

FUNCTION  <SNR>84_ProjectionistDetect()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:364
Called 3 times
Total time:   0.002190
 Self time:   0.000130

count  total (s)   self (s)
    3   0.000028   0.000021   let file = s:Slash(get(g:, 'projectionist_file', ''))
    3   0.001137   0.000017   let dir = FugitiveExtractGitDir(file)
    3              0.000016   let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
    3              0.000004   if empty(base)
    3   0.000034   0.000012     let base = s:Tree(dir)
    3              0.000001   endif
    3              0.000003   if !empty(base)
    3              0.000006     if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
    3              0.000001     endif
    3   0.000927   0.000016     let file = FugitiveCommonDir(dir) . '/info/projections.json'
    3              0.000018     if filereadable(file)
                                  call projectionist#append(base, file)
    3              0.000001     endif
    3              0.000001   endif

FUNCTION  <SNR>156_get_files_with_create_directory()
    Defined: ~/.config/nvim/autoload/plugged/fzf-preview.vim/autoload/fzf_preview/remote/mr.vim:16
Called 14 times
Total time:   0.002655
 Self time:   0.002655

count  total (s)   self (s)
   14              0.000144   if !isdirectory(g:fzf_preview_cache_directory)
                                call mkdir(g:fzf_preview_cache_directory, 'p')
   14              0.000010   endif
                            
   14              0.000014   try
   14              0.002309     let files = readfile(a:cache_path)
                              catch
                                let files = []
   14              0.000017   endtry
                            
   14              0.000024   return files

FUNCTION  <SNR>99_persist()
    Defined: ~/.config/nvim/autoload/plugged/vim-obsession/plugin/obsession.vim:69
Called 9 times
Total time:   0.000484
 Self time:   0.000484

count  total (s)   self (s)
    9              0.000032   if exists('g:SessionLoad')
                                return ''
    9              0.000006   endif
    9              0.000029   let sessionoptions = &sessionoptions
    9              0.000020   if exists('g:this_obsession')
                                try
                                  set sessionoptions-=blank sessionoptions-=options sessionoptions+=tabpages
                                  exe s:doautocmd_user('ObsessionPre')
                                  execute 'mksession! '.fnameescape(g:this_obsession)
                                  let body = readfile(g:this_obsession)
                                  call insert(body, 'let g:this_session = v:this_session', -3)
                                  call insert(body, 'let g:this_obsession = v:this_session', -3)
                                  if type(get(g:, 'obsession_append')) == type([])
                                    for line in g:obsession_append
                                      call insert(body, line, -3)
                                    endfor
                                  endif
                                  call writefile(body, g:this_obsession)
                                  let g:this_session = g:this_obsession
                                  exe s:doautocmd_user('Obsession')
                                catch /^Vim(mksession):E11:/
                                  return ''
                                catch
                                  unlet g:this_obsession
                                  let &l:readonly = &l:readonly
                                  return 'echoerr '.string(v:exception)
                                finally
                                  let &sessionoptions = sessionoptions
                                endtry
    9              0.000005   endif
    9              0.000010   return ''

FUNCTION  <SNR>159_convert()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:338
Called 609 times
Total time:   0.453420
 Self time:   0.013516

count  total (s)   self (s)
  609              0.002186   if !has_key(s:lightline.component_expand, a:name)
  394              0.001345     return [[[a:name], 0, a:index, a:index]]
  215              0.000156   else
  215              0.000928     let type = get(s:lightline.component_type, a:name, a:index)
  215              0.000969     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
  215   0.446683   0.006780     return filter(map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
                              endif

FUNCTION  <SNR>177_process_hunk()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:240
Called 24 times
Total time:   0.005375
 Self time:   0.001545

count  total (s)   self (s)
   24              0.000038   let modifications = []
   24              0.000042   let from_line  = a:hunk[0]
   24              0.000035   let from_count = a:hunk[1]
   24              0.000032   let to_line    = a:hunk[2]
   24              0.000031   let to_count   = a:hunk[3]
                            
   24   0.000194   0.000135   if s:is_added(from_count, to_count)
   14   0.002358   0.000105     call s:process_added(modifications, from_count, to_count, to_line)
   14   0.000823   0.000123     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   10   0.000087   0.000057   elseif s:is_removed(from_count, to_count)
    3   0.000047   0.000021     call s:process_removed(modifications, from_count, to_count, to_line)
    3   0.000154   0.000022     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    7   0.000065   0.000038   elseif s:is_modified(from_count, to_count)
    6   0.000148   0.000048     call s:process_modified(modifications, from_count, to_count, to_line)
    6   0.000353   0.000052     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    1   0.000009   0.000007   elseif s:is_modified_and_added(from_count, to_count)
    1   0.000115   0.000010     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    1   0.000065   0.000009     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    1   0.000070   0.000031     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
                              elseif s:is_modified_and_removed(from_count, to_count)
                                call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   24              0.000011   endif
   24              0.000028   return modifications

FUNCTION  251()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:311
Called 24 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   24              0.000046     return g:NERDTreeMinimalUI

FUNCTION  255()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:364
Called 1 time
Total time:   0.000430
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000010     let win = winnr()
    1              0.000008     let self._screenState = {}
    1              0.000002     try
    1   0.000294   0.000019         call g:NERDTree.CursorToTreeWin()
    1              0.000015         let self._screenState['oldPos'] = getpos('.')
    1              0.000009         let self._screenState['oldTopLine'] = line('w0')
    1              0.000016         let self._screenState['oldWindowSize'] = winnr('$')==1 ? g:NERDTreeWinSize : winwidth('')
    1   0.000065   0.000021         call nerdtree#exec(win . 'wincmd w', 1)
                                catch
    1              0.000002     endtry

FUNCTION  <SNR>17_LoadIndent()
    Defined: /usr/share/nvim/runtime/indent.vim:13
Called 3 times
Total time:   0.002921
 Self time:   0.002832

count  total (s)   self (s)
    3              0.000010     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    3              0.000002     endif
    3              0.000010     let s = expand("<amatch>")
    3              0.000005     if s != ""
    3              0.000005       if exists("b:did_indent")
                            	unlet b:did_indent
    3              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    6              0.000019       for name in split(s, '\.')
    3   0.001530   0.001441         exe 'runtime! indent/' . name . '.vim'
    3              0.001299         exe 'runtime! indent/' . name . '.lua'
    6              0.000006       endfor
    3              0.000002     endif

FUNCTION  <SNR>59_DebugIndent()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:141
Called 36 times
Total time:   0.000511
 Self time:   0.000410

count  total (s)   self (s)
   36   0.000396   0.000295   call call('s:Debug', a:000)
   36              0.000097   let s:debug_indent += 1

FUNCTION  <SNR>82_unc_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:169
Called 8 times
Total time:   0.000339
 Self time:   0.000053

count  total (s)   self (s)
    8   0.000335   0.000049   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>154_can_diffoff()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:5345
Called 11 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   11              0.000160   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  FugitiveWorkTree()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:182
Called 3 times
Total time:   0.000151
 Self time:   0.000030

count  total (s)   self (s)
    3   0.000144   0.000022   let tree = s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))
    3              0.000004   if tree isnot# 0 || a:0 > 1
    3              0.000002     return tree
                              else
                                return ''
                              endif

FUNCTION  coc#highlight#create_namespace()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim:510
Called 3 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000016   if type(a:key) == 0
                                return a:key
    3              0.000002   endif
    3              0.000015   if has_key(s:namespace_map, a:key)
    2              0.000008     return s:namespace_map[a:key]
    1              0.000001   endif
    1              0.000006   if has('nvim')
    1              0.000008     let s:namespace_map[a:key] = nvim_create_namespace('coc-'.a:key)
                              else
                                let s:namespace_map[a:key] = s:ns_id
                                let s:ns_id = s:ns_id + 1
    1              0.000001   endif
    1              0.000003   return s:namespace_map[a:key]

FUNCTION  <SNR>76_get_buffer_paths()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:197
Called 629 times
Total time:   0.206837
 Self time:   0.206837

count  total (s)   self (s)
  629              0.000993   if (!s:smart_path)
                                return map(copy(a:buffers), 'bufname(v:val)')
  629              0.000321   endif
                            
  629              0.001089   let l:smart_buffers = []
  629              0.001253   let l:buffer_count_per_tail = {}
                            
 3102              0.004122   for l:buffer in a:buffers
 2473              0.004165     let l:smart_buffer = {}
 2473              0.006185     let l:name = bufname(l:buffer)
                            
 2473              0.004500     if strlen(l:name)
 2473              0.043298       let l:smart_buffer.path = fnamemodify(l:name, ':p:~:.')
                            
 2473              0.008257       let sep = strridx(l:smart_buffer.path, s:dirsep)
 2473              0.007080       if sep != -1 && l:smart_buffer.path[sep :] ==# s:dirsep
                                    let sep = strridx(l:smart_buffer.path, s:dirsep, sep - 1)
 2473              0.001669       endif
                            
                                  " On Windows consider UNIX directory separators as well because
                                  " for example neovim converts \ to / upon :mksession
                            
 2473              0.006504       if sep == -1 && has('win32')
                                    let sep = strridx(l:smart_buffer.path, '/')
                                    if sep != -1 && l:smart_buffer.path[sep :] ==# '/'
                                      let sep = strridx(l:smart_buffer.path, sep - 1)
                                    endif
 2473              0.001403       endif
                            
 2473              0.004293       let l:smart_buffer.sep = sep
 2473              0.007602       let l:smart_buffer.label = l:smart_buffer.path[l:smart_buffer.sep + 1:]
 2473              0.013966       let l:buffer_count_per_tail[l:smart_buffer.label] = get(l:buffer_count_per_tail, l:smart_buffer.label, 0) + 1
                                else
                                  let l:smart_buffer.path = l:name
                                  let l:smart_buffer.label = l:name
 2473              0.001292     endif
                            
 2473              0.006823     call add(l:smart_buffers, l:smart_buffer)
 3102              0.003058   endfor
                            
  629              0.004807   while len(filter(l:buffer_count_per_tail, 'v:val > 1'))
                                let [ambiguous, l:buffer_count_per_tail] = [l:buffer_count_per_tail, {}]
                            
                                for l:smart_buffer in l:smart_buffers
                                  if strlen(l:smart_buffer.path)
                                    if -1 < l:smart_buffer.sep && has_key(ambiguous, l:smart_buffer.label)
                                      let l:smart_buffer.sep = strridx(l:smart_buffer.path, s:dirsep, l:smart_buffer.sep - 1)
                                      let l:smart_buffer.label = l:smart_buffer.path[l:smart_buffer.sep + 1:]
                                    endif
                                    let l:buffer_count_per_tail[l:smart_buffer.label] = get(l:buffer_count_per_tail, l:smart_buffer.label, 0) + 1
                                  endif
                                endfor
  629              0.000700   endwhile
                            
  629              0.004328   return map(l:smart_buffers, 'v:val.label')

FUNCTION  <SNR>76_get_buffer_name()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:55
Called 835 times
Total time:   0.122253
 Self time:   0.078346

count  total (s)   self (s)
  835              0.001810   let l:name = a:path
  835              0.001385   if l:name ==# ''
                                let l:name = s:unnamed
  835              0.000575   else
  835              0.006253     let l:name = fnamemodify(l:name, s:filename_modifier)
  835              0.001018     if s:shorten_path
  835              0.002173       let l:name = pathshorten(l:name)
  835              0.000460     endif
  835              0.000395   endif
                            
  835   0.025611   0.006290   let l:icon = s:get_icon(a:buffer)
  835   0.020997   0.006517   let l:number = s:get_number(a:i, a:buffer)
  835              0.001768   if l:number != '' && l:icon != ''
                                if s:icon_position ==? 'first'
                                  let l:name = l:icon . ' ' . l:number . l:name
                                elseif s:icon_position ==? 'right'
                                  let l:name = l:number . l:name . ' ' . l:icon
                                else
                                  let l:name = l:number . l:icon . ' ' . l:name
                                endif
  835              0.001068   elseif l:number != ''
                                let l:name = l:number . l:name
  835              0.000832   elseif l:icon != ''
                                let l:name = s:icon_position ==? 'right' ?  (l:name . ' ' . l:icon) : (l:icon . ' ' . l:name)
  835              0.000383   endif
                            
  835   0.015779   0.005673   if s:is_read_only(a:buffer)
                                let l:name .= s:read_only
  835              0.000369   endif
  835              0.004612   if getbufvar(a:buffer, '&mod')
    2              0.000004     let l:name .= s:modified
  835              0.000345   endif
                            
  835              0.004854   let l:name = repeat(' ', s:margin_left) . l:name . repeat(' ', s:margin_right)
                            
  835              0.001970   let l:len = len(l:name)
  835              0.004826   let l:name = substitute(l:name, '%', '%%', 'g')
  835              0.001124   if s:component_is_raw
                                let l:name = ' ' . l:name . ' '
  835              0.000343   endif
  835              0.000693   if s:clickable
                                return ['%' . string(a:i) . '@lightline#bufferline#_click_handler@' . l:name . '%X', l:len]
  835              0.000424   else
  835              0.001910     return [l:name, l:len]
                              endif

FUNCTION  <SNR>58_VimNavigate()
    Defined: ~/.config/nvim/autoload/plugged/vim-kitty-navigator/plugin/kitty_navigator.vim:9
Called 5 times
Total time:   0.075690
 Self time:   0.000262

count  total (s)   self (s)
    5              0.000015   try
    5   0.075632   0.000204     execute 'wincmd ' . a:direction
                              catch
                                echohl ErrorMsg | echo 'E11: Invalid in command-line window; <CR> executes, CTRL-C quits: wincmd k' | echohl None
    5              0.000006   endtry

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 5 times
Total time:   0.005379
 Self time:   0.004241

count  total (s)   self (s)
    5              0.000018   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    5              0.000054     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    5   0.000116   0.000053     let modified_lines = s:handle_double_hunk(a:modified_lines)
    5   0.004855   0.003781     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    5              0.000013     if exists('*sign_placelist')
    5              0.000291       call sign_placelist(signs)
    5              0.000005       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  loupe#private#prepare_highlight()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe/private.vim:82
Called 1 time
Total time:   0.000768
 Self time:   0.000768

count  total (s)   self (s)
    1              0.000004   if has('autocmd')
    1              0.000008     augroup LoupeHightlightMatch
    1              0.000737       autocmd!
    1              0.000013       autocmd CursorMoved * :call loupe#hlmatch()
    1              0.000001     augroup END
    1              0.000001   endif
    1              0.000003   return a:result

FUNCTION  coc#highlight#match_ranges()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim:342
Called 1 time
Total time:   0.000169
 Self time:   0.000169

count  total (s)   self (s)
    1              0.000003   let winid = a:winid == 0 ? win_getid() : a:winid
    1              0.000003   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    1              0.000007   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    1              0.000000   endif
    1              0.000001   if !s:clear_match_by_window
                                let curr = win_getid()
                                if has('nvim')
                                  noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
                                endif
    1              0.000000   endif
    1              0.000001   let ids = []
    2              0.000002   for range in a:ranges
    1              0.000001     let pos = []
    1              0.000002     let start = range['start']
    1              0.000001     let end = range['end']
    2              0.000004     for lnum in range(start['line'] + 1, end['line'] + 1)
    1              0.000003       let arr = getbufline(bufnr, lnum)
    1              0.000003       let line = empty(arr) ? '' : arr[0]
    1              0.000001       if empty(line)
                                    continue
    1              0.000000       endif
    1              0.000006       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
    1              0.000005       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
    1              0.000001       if colStart == colEnd
                                    continue
    1              0.000000       endif
    1              0.000004       call add(pos, [lnum, colStart, colEnd - colStart])
    2              0.000001     endfor
    1              0.000001     if !empty(pos)
    1              0.000003       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
    1              0.000001       let i = 1
    1              0.000001       let l = []
    2              0.000002       for p in pos
    1              0.000002         call add(l, p)
    1              0.000001         if i % 8 == 0
                                      let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
                                      call add(ids, id)
                                      let l = []
    1              0.000000         endif
    1              0.000002         let i += 1
    2              0.000001       endfor
    1              0.000002       if !empty(l)
    1              0.000009         let id = matchaddpos(a:hlGroup, l, a:priority, -1, opts)
    1              0.000002         call add(ids, id)
    1              0.000000       endif
    1              0.000000     endif
    2              0.000002   endfor
    1              0.000001   if !s:clear_match_by_window
                                if has('nvim')
                                  noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
                                endif
    1              0.000000   endif
    1              0.000001   return ids

FUNCTION  coc#highlight#clear_highlight()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim:230
Called 3 times
Total time:   0.000247
 Self time:   0.000168

count  total (s)   self (s)
    3              0.000021   let bufnr = a:bufnr == 0 ? bufnr('%') : a:bufnr
    3              0.000010   if !bufloaded(bufnr)
                                return
    3              0.000003   endif
    3   0.000125   0.000046   let src_id = coc#highlight#create_namespace(a:key)
    3              0.000021   if has('nvim')
    3              0.000028     call nvim_buf_clear_namespace(a:bufnr, src_id, a:start_line, a:end_line)
                              else
                                call coc#api#call('buf_clear_namespace', [a:bufnr, src_id, a:start_line, a:end_line])
    3              0.000002   endif

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:139
Called 3 times
Total time:   0.005554
 Self time:   0.000174

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                            
    3   0.000050   0.000017   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    3   0.000519   0.000047   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args.' ls-files --error-unmatch --full-name -z -- '.gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    3   0.000027   0.000021   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
    3              0.000009     let handler = copy(s:set_path_handler)
    3              0.000005     let handler.continuation = a:continuation
    3   0.004925   0.000055     call gitgutter#async#execute(cmd, a:bufnr, handler)
    3              0.000007     return 'async'
                              endif
                            
                              let path = gitgutter#utility#system(cmd)
                              if v:shell_error
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', s:strip_trailing_new_line(path))
                              endif

FUNCTION  nerdtree#slash()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:47
Called 1200 times
Total time:   0.031848
 Self time:   0.019835

count  total (s)   self (s)
 1200   0.021648   0.009634     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
 1200              0.000793     endif
                            
 1200              0.001378     return '/'

FUNCTION  <SNR>154_TempReadPost()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:2482
Called 3 times
Total time:   0.000144
 Self time:   0.000065

count  total (s)   self (s)
    3   0.000096   0.000017   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if !has_key(dict, 'job')
                                  setlocal nobuflisted
                                endif
                                if get(dict, 'filetype', '') ==# 'git'
                                  call fugitive#MapJumps()
                                endif
                                if has_key(dict, 'filetype')
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<<,>>>>>>>>
                                if !&modifiable
                                  if empty(mapcheck('q', 'n'))
                                    nnoremap <buffer> <silent> q    :<C-U>echoerr "fugitive: q is removed in favor of gq (or :q)"<CR>
                                  endif
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
    3              0.000001   endif
    3              0.000002   return ''

FUNCTION  <SNR>69_ExpandMap()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:596
Called 4 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
    4              0.000009   let map = a:map
    4              0.000046   let map = substitute(map, '\(<Plug>\w\+\)', '\=maparg(submatch(1), "i")', 'g')
    4              0.000033   let map = substitute(map, '\(<Plug>([^)]*)\)', '\=maparg(submatch(1), "i")', 'g')
    4              0.000006   return map

FUNCTION  coc#float#check_related()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:809
Called 6 times
Total time:   0.001090
 Self time:   0.000356

count  total (s)   self (s)
    6              0.000026   let invalids = []
    6   0.000844   0.000110   let ids = coc#float#get_float_win_list(1)
    6              0.000014   for id in ids
                                let target = getwinvar(id, 'target_winid', 0)
                                if (target && index(ids, target) == -1) || getwinvar(id, 'kind', '') == 'pum'
                                  call add(invalids, id)
                                endif
    6              0.000008   endfor
    6              0.000014   if !s:popup_list_api
    6              0.000048     let s:popup_list = filter(ids, "index(invalids, v:val) == -1")
    6              0.000006   endif
    6              0.000015   for id in invalids
                                call coc#float#close(id)
    6              0.000006   endfor

FUNCTION  <SNR>177_is_added()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:273
Called 24 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   24              0.000049   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>181_enable_file()
    Defined: ~/.config/coc/extensions/node_modules/coc-fzf-preview/plugin/fzf_preview.vim:184
Called 14 times
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
   14              0.000095   if bufnr('%') != expand('<abuf>') || a:path == ''
                                return v:false
   14              0.000011   else
   14              0.000021     return v:true
                              endif

FUNCTION  coc#util#cursor()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:36
Called 39 times
Total time:   0.000882
 Self time:   0.000882

count  total (s)   self (s)
   39              0.000807   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  <SNR>175_on_exit_nvim()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:72
Called 8 times
Total time:   0.021487
 Self time:   0.000240

count  total (s)   self (s)
    8              0.000021   if !a:exit_code
    8   0.021449   0.000202     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    8              0.000004   endif

FUNCTION  lightline#update()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:13
Called 14 times
Total time:   0.035521
 Self time:   0.001249

count  total (s)   self (s)
   14   0.000231   0.000130   if s:skip() | return | endif
   14              0.000019   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
   14              0.000008   endif
   14              0.000037   if s:lightline.enable.statusline
   14              0.000042     let w = winnr()
   14   0.034530   0.000359     let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   41              0.000088     for n in range(1, winnr('$'))
   27              0.000356       call setwinvar(n, '&statusline', s[n!=w])
   41              0.000030     endfor
   14              0.000010   endif

FUNCTION  <SNR>118_activateDirNode()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:134
Called 4 times
Total time:   0.139961
 Self time:   0.000156

count  total (s)   self (s)
                            
    4   0.001668   0.000043     if a:directoryNode.isRoot() && a:directoryNode.isOpen
                                    call nerdtree#echo('cannot close tree root')
                                    return
    4              0.000003     endif
                            
    4   0.138257   0.000077     call a:directoryNode.activate((a:0 > 0) ? a:1 : {})

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:196
Called 5 times
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
    5              0.000130   let p = resolve(expand('#'.a:bufnr.':p'))
    5              0.000047   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    5              0.000012   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    5              0.000002   endif
    5              0.000008   return g:gitgutter_diff_base

FUNCTION  <SNR>59_store_orig_colorcolumn()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:388
Called 4 times
Total time:   0.000276
 Self time:   0.000265

count  total (s)   self (s)
                              " Store original settings, but not on VimResized / until we have
                              " entered the buffer again.
    4              0.000007   if ! g:diminactive_use_colorcolumn
                                call s:Debug('store_orig_colorcolumn: do not store: deactivated.')
    4              0.000002   endif
    4              0.000018   let orig_cc = gettabwinvar(a:tabnr, a:winnr, '&colorcolumn')
    4              0.000016   let saved_cc = gettabwinvar(a:tabnr, a:winnr, 'diminactive_stored_orig')
    4              0.000005   if saved_cc
                                    " \ || getbufvar(a:bufnr, 'diminactive_stored_orig')
                                call s:Debug('store_orig_colorcolumn: do not store. saved: '.saved_cc.'.')
                                return 0
    4              0.000002   endif
                            
    4   0.000064   0.000053   call s:Debug('store_orig_colorcolumn: &cc: '.orig_cc, {'t': a:tabnr, 'w': a:winnr, 'b': a:bufnr})
    4              0.000061   noautocmd call settabwinvar(a:tabnr, a:winnr, 'diminactive_orig_cc', orig_cc)
                              " Save it also for the buffer, which is required for 'new | only | b#'.
    4              0.000018   let s:buffer_cc[a:bufnr] = orig_cc
                            
    4              0.000043   noautocmd call settabwinvar(a:tabnr, a:winnr, 'diminactive_stored_orig', 1)
    4              0.000005   return 1

FUNCTION  <SNR>159_evaluate_expand()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:326
Called 215 times
Total time:   0.439904
 Self time:   0.012404

count  total (s)   self (s)
  215              0.000243   try
  215   0.425462   0.002945     let result = eval(a:component . '()')
  215              0.000649     if type(result) == 1 && result ==# ''
                                  return []
  215              0.000121     endif
                              catch
                                return []
  215              0.000196   endtry
  215   0.012263   0.007280   return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')

FUNCTION  coc#float#get_related()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:1205
Called 480 times
Total time:   0.007627
 Self time:   0.007627

count  total (s)   self (s)
  480              0.003316   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
  480              0.000623   endfor
  480              0.000601   return 0

FUNCTION  gitgutter#async#execute()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:16
Called 8 times
Total time:   0.018686
 Self time:   0.018442

count  total (s)   self (s)
    8   0.000265   0.000054   call gitgutter#debug#log('[async] '.a:cmd)
                            
    8              0.000036   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    8   0.000077   0.000044   let command = s:build_command(a:cmd)
                            
    8              0.000016   if has('nvim')
    8              0.018122     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    8              0.000011   endif

FUNCTION  <SNR>66_parent()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:218
Called 8 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    8              0.000015   return fnamemodify(a:dir, ':h')

FUNCTION  <SNR>76_sum()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:267
Called 414 times
Total time:   0.004723
 Self time:   0.004723

count  total (s)   self (s)
  414              0.000586   let l:sum = 0
 1026              0.001270   for l:value in a:list
  612              0.001060     let l:sum += l:value
 1026              0.000655   endfor
  414              0.000459   return l:sum

FUNCTION  <SNR>59_restore_colorcolumn()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:363
Called 14 times
Total time:   0.000869
 Self time:   0.000797

count  total (s)   self (s)
   14   0.000208   0.000172   call s:Debug('restore_colorcolumn: winbufnr: '.winbufnr(a:winnr), {'t': a:tabnr, 'w': a:winnr, 'b': a:bufnr})
   14              0.000054   if !gettabwinvar(a:tabnr, a:winnr, 'diminactive_stored_orig')
   10              0.000041     if !has_key(s:buffer_cc, a:bufnr)
    9   0.000063   0.000047       call s:Debug('restore_colorcolumn: nothing stored!')
    9              0.000005       return
    1              0.000001     end
    1   0.000016   0.000011     call s:Debug('restore_colorcolumn: using stored cc from buffer.')
    1              0.000006     let cc = s:buffer_cc[a:bufnr]
    4              0.000003   else
    4              0.000015     let cc = gettabwinvar(a:tabnr, a:winnr, 'diminactive_orig_cc')
    5              0.000003   endif
                            
                              " Set colorcolumn: falls back to "", which is required, when an existing
                              " buffer gets opened again in a new window: Vim then uses the last
                              " colorcolumn setting (which might come from our s:Leave!)
    5   0.000069   0.000054   call s:Debug('restore_colorcolumn: '.cc, {'t': a:tabnr, 'w': a:winnr})
    5              0.000150   noautocmd call settabwinvar(a:tabnr, a:winnr, '&colorcolumn', cc)
                            
                              " After restoring the original setting, pick up any user changes again.
    5              0.000107   noautocmd call settabwinvar(a:tabnr, a:winnr, 'diminactive_stored_orig', 0)
    5              0.000050   silent! unlet s:buffer_cc[a:bufnr]

FUNCTION  lightline#tabline()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:431
Called 215 times
Total time:   0.619974
 Self time:   0.008280

count  total (s)   self (s)
  215              0.001097   if !has_key(s:highlight, 'tabline')
                                call lightline#highlight('tabline')
  215              0.000132   endif
  215              0.001092   if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$') || s:columns != &columns
  215              0.000583     let s:tabnr = tabpagenr()
  215              0.000398     let s:tabcnt = tabpagenr('$')
  215              0.000463     let s:columns = &columns
  215   0.614868   0.003175     let s:tabline = s:line(1, 0)
  215              0.000138   endif
  215              0.000301   return s:tabline

FUNCTION  <SNR>192_illuminate()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:95
Called 355 times
Total time:   0.101345
 Self time:   0.019759

count  total (s)   self (s)
  355              0.001500   if !get(b:, 'illuminate_enabled', s:enabled)
                                return
  355              0.000206   endif
                            
  355   0.021212   0.003224   call s:remove_illumination()
                            
  355   0.016014   0.003683   if s:should_illuminate_word()
  355   0.045117   0.006166     call s:match_word(s:get_cur_word())
  355              0.000218   endif
  355   0.015852   0.003535   let s:previous_match = s:get_cur_word()

FUNCTION  <SNR>59_Debug()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:105
Called 115 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
  115              0.000189   if ! g:diminactive_debug
  115              0.000088     return
                              endif
                            
                              let winid = -1
                              let bufid = -1
                              if a:0 > 1
                                let idinfo = a:2
                                if has_key(idinfo, 'b')
                                  let bufid = DimInactiveBufId(idinfo['b'])
                                end
                                if has_key(idinfo, 'w')
                                  let winid = DimInactiveWinId(idinfo['w'], get(idinfo, 't', -1))
                                end
                              endif
                            
                              let msg ='diminactive: '
                              if s:debug_indent > 0
                                for _ in range(1, s:debug_indent)
                                  let msg .= '  '
                                endfor
                              endif
                              if a:0 > 1 && type(a:1) == type([])
                                let msg .= string(a:000)
                              else
                                let msg .= a:1
                              endif
                              if winid != -1
                                let msg .= ' ['.winid.']'
                              endif
                              if bufid != -1
                                let msg .= ' ['.bufid.']'
                              endif
                              echom msg

FUNCTION  <SNR>82_strip_trailing_new_line()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:232
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000023   return substitute(a:line, '[[:cntrl:]]$', '', '')

FUNCTION  <SNR>159_subseparator()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:296
Called 284 times
Total time:   0.016189
 Self time:   0.016189

count  total (s)   self (s)
  284              0.002448   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
  284              0.009756   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
  284              0.003471   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:102
Called 14 times
Total time:   0.000498
 Self time:   0.000166

count  total (s)   self (s)
   14   0.000492   0.000160   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>76_is_read_only()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:368
Called 835 times
Total time:   0.010106
 Self time:   0.010106

count  total (s)   self (s)
  835              0.003831     let l:modifiable = getbufvar(a:buffer, '&modifiable')
  835              0.002644     let l:readonly = getbufvar(a:buffer, '&readonly')
  835              0.003140     return (l:readonly || !l:modifiable) && getbufvar(a:buffer, '&filetype') !=# 'help'

FUNCTION  loupe#private#very_magic_slash()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe/private.vim:25
Called 1 time
Total time:   0.000155
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000010   if getcmdtype() != ':'
                                return a:slash
    1              0.000002   endif
                            
                              " For simplicity, only consider "/" typed at the end of the command-line.
    1              0.000006   let l:pos=getcmdpos()
    1              0.000003   let l:cmd=getcmdline()
    1              0.000005   if len(l:cmd) + 1 != l:pos
                                return a:slash
    1              0.000001   endif
                            
                              " Skip over ranges
    1              0.000002   while 1
    1   0.000098   0.000022     let l:stripped=s:strip_ranges(l:cmd)
    1              0.000002     if l:stripped ==# l:cmd
    1              0.000001       break
                                else
                                  let l:cmd=l:stripped
                                endif
    1              0.000001   endwhile
                            
    1              0.000005   if index(['g', 's', 'v'], l:cmd) != -1
                                return loupe#private#prepare_highlight(a:slash . '\v')
    1              0.000000   endif
                            
    1              0.000001   return a:slash

FUNCTION  17()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:244
Called 211 times
Total time:   0.007897
 Self time:   0.001200

count  total (s)   self (s)
  211              0.000333     if self.cachedDisplayString ==# ''
   26   0.006826   0.000128         call self.cacheDisplayString()
  211              0.000091     endif
                            
  211              0.000225     return self.cachedDisplayString

FUNCTION  18()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:253
Called 3 times
Total time:   0.193476
 Self time:   0.068484

count  total (s)   self (s)
    3   0.001426   0.000055     let l:bufname = self.str({'format': 'Edit'})
    3              0.000019     if bufname('%') !=# l:bufname
    3   0.192023   0.068401         exec 'edit ' . l:bufname
    3              0.000001     endif

FUNCTION  19()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:263
Called 33 times
Total time:   0.001696
 Self time:   0.001297

count  total (s)   self (s)
   33   0.000738   0.000339     if nerdtree#runningWindows()
                                    if a:fullpath =~# '^\(\\\\\|\/\/\)'
                                        "For network shares, the 'drive' consists of the first two parts of the path, i.e. \\boxname\share
                                        let self.drive = substitute(a:fullpath, '^\(\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\).*', '\1', '')
                                        let self.drive = substitute(self.drive, '/', '\', 'g')
                                    else
                                        let self.drive = substitute(a:fullpath, '\(^[a-zA-Z]:\).*', '\1', '')
                                    endif
   33              0.000031     else
   33              0.000193         let self.drive = ''
   33              0.000032     endif
                            

FUNCTION  <SNR>192_should_illuminate_word()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:165
Called 355 times
Total time:   0.012330
 Self time:   0.012330

count  total (s)   self (s)
  355              0.002162   let ft_hl_groups = get(g:, 'Illuminate_ftHighlightGroups', {})
  355              0.001896   let hl_groups_whitelist = get(ft_hl_groups, &filetype, [])
  355              0.002027   call extend(hl_groups_whitelist, get(ft_hl_groups, '*', []))
  355              0.000826   if empty(hl_groups_whitelist)
  355              0.001846     let hl_groups_blacklist = get(ft_hl_groups, &filetype.':blacklist', [])
  355              0.001578     call extend(hl_groups_blacklist, get(ft_hl_groups, '*:blacklist', []))
  355              0.000702     if empty(hl_groups_blacklist)
  355              0.000500       return 1
                                else
                                  return index(hl_groups_blacklist, synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) < 0 && index(hl_groups_blacklist, synIDattr(synID(line('.'), col('.'), 1), 'name')) < 0
                                endif
                              endif
                            
                              return index(ft_hl_groups[&filetype], synIDattr(synIDtrans(synID(line('.'), col('.'), 1)), 'name')) >= 0 || index(ft_hl_groups[&filetype], synIDattr(synID(line('.'), col('.'), 1), 'name')) >= 0

FUNCTION  <SNR>64_MagicString()
    Defined: ~/.config/nvim/autoload/plugged/loupe/plugin/loupe.vim:389
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000017   let s:magic=get(g:, 'LoupeVeryMagic', 1)
    1              0.000004   return s:magic ? '\v' : ''

FUNCTION  21()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:286
Called 8 times
Total time:   0.000213
 Self time:   0.000129

count  total (s)   self (s)
    8   0.000154   0.000071     if nerdtree#runningWindows()
                                    return " `\|\"#%&,?()\*^<>$"
    8              0.000007     endif
                            
    8              0.000024     return " \\`\|\"#%&,?()\*^<>[]{}$"

FUNCTION  24()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:331
Called 1347 times
Total time:   0.013607
 Self time:   0.013607

count  total (s)   self (s)
 1347              0.002491     if empty(self.pathSegments)
                                    return ''
 1347              0.000615     endif
 1347              0.002808     let toReturn = self.pathSegments[-1]
 1347              0.001995     if a:dirSlash && self.isDirectory
   49              0.000167         let toReturn = toReturn . '/'
 1347              0.000588     endif
 1347              0.001468     return toReturn

FUNCTION  25()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:344
Called 26 times
Total time:   0.002999
 Self time:   0.001972

count  total (s)   self (s)
   26              0.000040     let i = 0
  131              0.000242     while i < len(g:NERDTreeSortOrder)
  110   0.002167   0.001140         if g:NERDTreeSortOrder[i] !~? '\[\[-\?\(timestamp\|size\|extension\)\]\]' && self.getLastPathComponent(1) =~# g:NERDTreeSortOrder[i]
    5              0.000007             return i
  105              0.000046         endif
  105              0.000114         let i = i + 1
  126              0.000073     endwhile
                            
   21              0.000049     return index(g:NERDTreeSortOrder, '*')

FUNCTION  27()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:374
Called 80 times
Total time:   0.009568
 Self time:   0.006320

count  total (s)   self (s)
   80              0.000261     if !exists('self._sortKey') || g:NERDTreeSortOrder !=# g:NERDTreeOldSortOrder
                                    " Look for file metadata tags: [[timestamp]], [[extension]], [[size]]
   26              0.000042         let metadata = []
  156              0.000165         for tag in g:NERDTreeSortOrder
  130              0.000368             if tag =~? '\[\[-\?timestamp\]\]'
                                            let metadata += [self.isDirectory ? 0 : getftime(self.str()) * (tag =~# '-' ? -1 : 1)]
  130              0.000294             elseif tag =~? '\[\[-\?size\]\]'
                                            let metadata += [self.isDirectory ? 0 : getfsize(self.str()) * (tag =~# '-' ? -1 : 1)]
  130              0.000317             elseif tag =~? '\[\[extension\]\]'
                                            let extension = matchstr(self.getLastPathComponent(0), '[^.]\+\.\zs[^.]\+$')
                                            let metadata += [self.isDirectory ? '' : (extension ==# '' ? nr2char(str2nr('0x10ffff',16)) : extension)]
  130              0.000066             endif
  156              0.000095         endfor
                            
   26              0.000099         if g:NERDTreeSortOrder[0] =~# '\[\[.*\]\]'
                                        " Apply tags' sorting first if specified first.
                                        let self._sortKey = metadata + [self.getSortOrderIndex()]
   26              0.000017         else
                                        " Otherwise, do regex grouping first.
   26   0.003203   0.000204             let self._sortKey = [self.getSortOrderIndex()] + metadata
   26              0.000017         endif
                            
   26   0.000380   0.000132         let path = self.getLastPathComponent(0)
   26              0.000039         if !g:NERDTreeSortHiddenFirst
                                        let path = substitute(path, '^[._]', '', '')
   26              0.000014         endif
   26              0.000033         if !g:NERDTreeCaseSensitiveSort
   26              0.000066             let path = tolower(path)
   26              0.000014         endif
                            
   26              0.000163         call extend(self._sortKey, (g:NERDTreeNaturalSort ? self._splitChunks(path) : [path]))
   80              0.000037     endif
   80              0.000085     return self._sortKey

FUNCTION  29()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:432
Called 509 times
Total time:   0.007244
 Self time:   0.002722

count  total (s)   self (s)
  509   0.007141   0.002619     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:164
Called 8 times
Total time:   0.001018
 Self time:   0.000142

count  total (s)   self (s)
    8   0.000480   0.000090   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    8   0.000534   0.000048   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  fzf_preview#remote#util#uniq()
    Defined: ~/.config/nvim/autoload/plugged/fzf-preview.vim/autoload/fzf_preview/remote/util.vim:72
Called 14 times
Total time:   0.030767
 Self time:   0.030767

count  total (s)   self (s)
   14              0.000039   let result = []
 3430              0.002529   for item in a:list
 3416              0.018109     if index(result, item) == -1
 3402              0.005852       call add(result, item)
 3416              0.001517     endif
 3430              0.001665   endfor
   14              0.000025   return result

FUNCTION  110()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:13
Called 3 times
Total time:   0.200066
 Self time:   0.000151

count  total (s)   self (s)
    3   0.200061   0.000146     call self.open(a:0 ? a:1 : {})

FUNCTION  116()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:88
Called 148 times
Total time:   0.010175
 Self time:   0.001186

count  total (s)   self (s)
  148   0.010133   0.001145     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  117()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:102
Called 108 times
Total time:   0.025815
 Self time:   0.001035

count  total (s)   self (s)
  108   0.025781   0.001002     return self.path.str() ==# a:treenode.path.str()

FUNCTION  118()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:112
Called 4 times
Total time:   0.002195
 Self time:   0.000064

count  total (s)   self (s)
    4   0.002179   0.000048     if a:path.equals(self.path)
    3              0.000009         return self
    1              0.000000     endif
    1              0.000001     return {}

FUNCTION  nerdtree#compareNodes()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:102
Called 40 times
Total time:   0.011568
 Self time:   0.000318

count  total (s)   self (s)
   40   0.011555   0.000305     return nerdtree#compareNodePaths(a:n1.path, a:n2.path)

FUNCTION  32()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:484
Called 509 times
Total time:   0.018681
 Self time:   0.014031

count  total (s)   self (s)
  509              0.000831     let pat = a:pattern
  509              0.001553     if strpart(pat,len(pat)-8) ==# '[[path]]'
                                    let pat = strpart(pat,0, len(pat)-8)
                                    return self.str() =~# pat
  509              0.001314     elseif strpart(pat,len(pat)-7) ==# '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
  509              0.001133     elseif strpart(pat,len(pat)-8) ==# '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
  509              0.000222     endif
                            
  509   0.007504   0.002854     return self.getLastPathComponent(0) =~# pat

FUNCTION  36()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:556
Called 311 times
Total time:   0.091617
 Self time:   0.007588

count  total (s)   self (s)
  311   0.005589   0.002425     if nerdtree#runningWindows()
                                    return self.str() ==? a:path.str()
  311              0.000249     else
  311   0.084523   0.003657         return self.str() ==# a:path.str()
                                endif

FUNCTION  37()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:565
Called 33 times
Total time:   0.025123
 Self time:   0.003181

count  total (s)   self (s)
   33              0.001709     let l:newPath = copy(self)
                            
   33   0.022065   0.000711     call l:newPath.readInfoFromDisk(s:Path.AbsolutePathFor(a:pathStr))
                            
   33              0.000138     let l:newPath.cachedDisplayString = ''
   33   0.001035   0.000447     let l:newPath.flagSet = g:NERDTreeFlagSet.New()
                            
   33              0.000076     return l:newPath

FUNCTION  38()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:581
Called 66 times
Total time:   0.004737
 Self time:   0.004737

count  total (s)   self (s)
   66              0.002532     let tmp = resolve(a:path)
   66              0.002151     return tmp =~# '.\+/$' ? substitute(tmp, '/$', '', '') : tmp

FUNCTION  39()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:590
Called 33 times
Total time:   0.016287
 Self time:   0.007533

count  total (s)   self (s)
   33   0.002015   0.000319     call self.extractDriveLetter(a:fullpath)
                            
   33   0.001245   0.000369     let fullpath = s:Path.WinToUnixPath(a:fullpath)
                            
   33              0.000576     if getftype(fullpath) ==# 'fifo'
                                    throw 'NERDTree.InvalidFiletypeError: Cant handle FIFO files: ' . a:fullpath
   33              0.000034     endif
                            
   33              0.001278     let self.pathSegments = filter(split(fullpath, '/'), '!empty(v:val)')
                            
   33              0.000169     let self.isReadOnly = 0
   33              0.000307     if isdirectory(a:fullpath)
    9              0.000051         let self.isDirectory = 1
   24              0.000359     elseif filereadable(a:fullpath)
   24              0.000112         let self.isDirectory = 0
   24              0.000342         let self.isReadOnly = filewritable(a:fullpath) ==# 0
                                else
                                    throw 'NERDTree.InvalidArgumentsError: Invalid path = ' . a:fullpath
   33              0.000029     endif
                            
   33              0.000154     let self.isExecutable = 0
   33              0.000082     if !self.isDirectory
   24              0.000268         let self.isExecutable = getfperm(a:fullpath) =~# 'x'
   33              0.000034     endif
                            
                                "grab the last part of the path (minus the trailing slash)
   33   0.001194   0.000416     let lastPathComponent = self.getLastPathComponent(0)
                            
                                "get the path to the new node with the parent dir fully resolved
   33   0.003738   0.000663     let hardPath = s:Path.Resolve(self.strTrunk()) . '/' . lastPathComponent
                            
                                "if  the last part of the path is a symlink then flag it as such
   33   0.002778   0.000448     let self.isSymLink = (s:Path.Resolve(hardPath) !=# hardPath)
   33              0.000078     if self.isSymLink
                                    let self.symLinkDest = s:Path.Resolve(fullpath)
                            
                                    "if the link is a dir then slap a / on the end of its dest
                                    if isdirectory(self.symLinkDest)
                            
                                        "we always wanna treat MS windows shortcuts as files for
                                        "simplicity
                                        if hardPath !~# '\.lnk$'
                            
                                            let self.symLinkDest = self.symLinkDest . '/'
                                        endif
                                    endif
   33              0.000028     endif

FUNCTION  illuminate#on_insert_entered()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:52
Called 1 time
Total time:   0.000104
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000059   0.000016   if !get(g:, 'Illuminate_insert_mode_highlight', 0) && s:should_illuminate_file()
    1   0.000044   0.000009     call s:remove_illumination()
    1              0.000000   endif

FUNCTION  coc#util#get_complete_option()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:338
Called 1 time
Total time:   0.000230
 Self time:   0.000230

count  total (s)   self (s)
    1              0.000006   let pos = getcurpos()
    1              0.000004   let line = getline(pos[1])
    1              0.000013   let input = matchstr(strpart(line, 0, pos[2] - 1), '\k*$')
    1              0.000003   let col = pos[2] - strlen(input)
    1              0.000155   let synname = synIDattr(synID(pos[1], col, 1), 'name')
    1              0.000046   return { 'word': matchstr(strpart(line, col - 1), '^\k\+'), 'input': empty(input) ? '' : input, 'line': line, 'filetype': &filetype, 'filepath': expand('%:p'), 'bufnr': bufnr('%'), 'linenr': pos[1], 'colnr' : pos[2], 'col': col - 1, 'synname': synname, 'changedtick': b:changedtick, 'blacklist': get(b:, 'coc_suggest_blacklist', []),}

FUNCTION  120()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:157
Called 811 times
Total time:   0.001319
 Self time:   0.001319

count  total (s)   self (s)
  811              0.001111     return self._nerdtree

FUNCTION  122()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:173
Called 7 times
Total time:   0.078247
 Self time:   0.000501

count  total (s)   self (s)
                            
    7              0.000023     try
    7   0.020206   0.000183         let l:path = b:NERDTree.ui.getPath(line('.'))
                            
    7              0.000035         if empty(l:path)
                                        return {}
    7              0.000011         endif
                            
    7   0.057863   0.000140         return b:NERDTree.root.findNode(l:path)
                                catch
                                    return {}
    7              0.000017     endtry

FUNCTION  125()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:210
Called 26 times
Total time:   0.001362
 Self time:   0.000977

count  total (s)   self (s)
   26              0.000057     if a:path.isDirectory
    5   0.000439   0.000054         return g:NERDTreeDirNode.New(a:path, a:nerdtree)
   21              0.000023     else
   21              0.000440         let newTreeNode = copy(self)
   21              0.000074         let newTreeNode.path = a:path
   21              0.000069         let newTreeNode.parent = {}
   21              0.000072         let newTreeNode._nerdtree = a:nerdtree
   21              0.000044         return newTreeNode
                                endif

FUNCTION  126()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:223
Called 3 times
Total time:   0.199915
 Self time:   0.000187

count  total (s)   self (s)
    3              0.000020     let opts = a:0 ? a:1 : {}
    3   0.000710   0.000091     let opener = g:NERDTreeOpener.New(self.path, opts)
    3   0.199174   0.000064     call opener.open(self)

FUNCTION  FugitiveIsGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:191
Called 22 times
Total time:   0.000324
 Self time:   0.000324

count  total (s)   self (s)
   22              0.000136   let path = substitute(a:path, '[\/]$', '', '') . '/'
   22              0.000180   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:61
Called 9 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    9              0.000091     if !isdirectory(a:dir)
    9              0.000011         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  quick_scope#HighlightLineDelayCallback()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:37
Called 48 times
Total time:   0.221777
 Self time:   0.002985

count  total (s)   self (s)
   48   0.017028   0.001405   call quick_scope#UnhighlightLine()
   48   0.204601   0.001432   call quick_scope#HighlightLine(a:direction, a:targets)

FUNCTION  <SNR>82_exists_file()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:223
Called 14 times
Total time:   0.001196
 Self time:   0.000253

count  total (s)   self (s)
   14   0.001192   0.000249   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  41()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:648
Called 134 times
Total time:   0.141705
 Self time:   0.002717

count  total (s)   self (s)
  134   0.089577   0.001583     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
  134   0.052057   0.001063     call self.cacheDisplayString()

FUNCTION  43()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:698
Called 1166 times
Total time:   0.165567
 Self time:   0.080563

count  total (s)   self (s)
 1166              0.004302     let options = a:0 ? a:1 : {}
 1166              0.002131     let toReturn = ''
                            
 1166              0.003165     if has_key(options, 'format')
   34              0.000128         let format = options['format']
   34              0.000155         if has_key(self, '_strFor' . format)
   34   0.002365   0.000453             exec 'let toReturn = self._strFor' . format . '()'
                                    else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
   34              0.000030         endif
 1132              0.000762     else
 1132   0.079899   0.007405         let toReturn = self._str()
 1166              0.000911     endif
                            
 1166   0.019201   0.009947     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
 1166              0.000767     endif
                            
 1166              0.002815     if has_key(options, 'truncateTo')
    8              0.000033         let limit = options['truncateTo']
    8              0.000033         if strdisplaywidth(toReturn) > limit-1
  232              0.000910             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  224              0.000914                 let toReturn = substitute(toReturn, '^.', '', '')
  232              0.000148             endwhile
    8              0.000052             if len(split(toReturn, '/')) > 1
    8              0.000064                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
                                        else
                                            let toReturn = '<' . toReturn
    8              0.000005             endif
    8              0.000004         endif
 1166              0.000698     endif
                            
 1166              0.001884     return toReturn

FUNCTION  44()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:735
Called 23 times
Total time:   0.000442
 Self time:   0.000442

count  total (s)   self (s)
   23              0.000206     let toReturn = '/' . join(self.pathSegments, '/')
   23              0.000077     if self.isDirectory && toReturn !=# '/'
   23              0.000068         let toReturn  = toReturn . '/'
   23              0.000019     endif
   23              0.000042     return toReturn

FUNCTION  46()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:753
Called 3 times
Total time:   0.000981
 Self time:   0.000204

count  total (s)   self (s)
                            
                                " Make the path relative to the current working directory, if possible.
    3   0.000798   0.000065     let l:result = fnamemodify(self.str(), ':.')
                            
                                " On Windows, the drive letter may be removed by "fnamemodify()".  Add it
                                " back, if necessary.
    3   0.000094   0.000050     if nerdtree#runningWindows() && l:result[0] == nerdtree#slash()
                                    let l:result = self.drive . l:result
    3              0.000003     endif
                            
    3              0.000025     let l:result = fnameescape(l:result)
                            
    3              0.000012     if empty(l:result)
                                    let l:result = '.'
    3              0.000003     endif
                            
    3              0.000007     return l:result

FUNCTION  47()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:774
Called 8 times
Total time:   0.001470
 Self time:   0.000576

count  total (s)   self (s)
    8   0.000349   0.000075     let lead = nerdtree#slash()
                            
                                "if we are running windows then slap a drive letter on the front
    8   0.000164   0.000078     if nerdtree#runningWindows()
                                    let lead = self.drive . '\'
    8              0.000007     endif
                            
    8   0.000373   0.000135     let toReturn = lead . join(self.pathSegments, nerdtree#slash())
                            
    8   0.000174   0.000092     if !nerdtree#runningWindows()
    8   0.000327   0.000114         let toReturn = escape(toReturn, self._escChars())
    8              0.000008     endif
    8              0.000016     return toReturn

FUNCTION  48()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:793
Called 1132 times
Total time:   0.072494
 Self time:   0.033457

count  total (s)   self (s)
 1132   0.038373   0.008690     let l:separator = nerdtree#slash()
 1132              0.002782     let l:leader = l:separator
                            
 1132   0.018167   0.008814     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
 1132              0.000735     endif
                            
 1132              0.008362     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  49()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:806
Called 33 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
   33              0.000644     return self.drive . '/' . join(self.pathSegments[0:-2], '/')

FUNCTION  <SNR>159_expand()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:349
Called 484 times
Total time:   0.524058
 Self time:   0.070638

count  total (s)   self (s)
  484              0.000925   let components = []
  484              0.000644   let expanded = []
  484              0.000611   let indices = []
  484              0.000561   let prevtype = ''
  484              0.000712   let previndex = -1
  484              0.000567   let xs = []
  484   0.465045   0.011625   call map(deepcopy(a:components), 'map(v:val, "extend(xs, s:convert(v:val, ''" . v:key . "''))")')
 1499              0.003660   for [component, expand, type, index] in xs
 1015              0.001646     if prevtype !=# type
  945              0.004750       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
  945              0.000708       endfor
  945              0.002146       call add(indices, type)
  945              0.001715       call add(components, [])
  945              0.001465       call add(expanded, [])
 1015              0.000733     endif
 1015              0.002776     call extend(components[-1], component)
 1015              0.004982     call extend(expanded[-1], repeat([expand], len(component)))
 1015              0.001554     let prevtype = type
 1015              0.001405     let previndex = index
 1499              0.001264   endfor
  484              0.002977   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
  484              0.000352   endfor
  484              0.002281   call add(indices, string(len(a:components)))
  484              0.001105   return [components, expanded, indices]

FUNCTION  131()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:262
Called 4 times
Total time:   0.003292
 Self time:   0.000122

count  total (s)   self (s)
    4   0.003207   0.000037     let ln = self.getNerdtree().ui.getLineNum(self)
    4              0.000004     if ln != -1
    4              0.000004         if a:isJump
                                        mark '
    4              0.000002         endif
    4              0.000014         call cursor(ln, col('.'))
                                else
                                    if a:recurseUpward
                                        let node = self
                                        while node != {} && self.getNerdtree().ui.getLineNum(node) ==# -1
                                            let node = node.parent
                                            call node.open()
                                        endwhile
                                        call self._nerdtree.render()
                                        call node.putCursorHere(a:isJump, 0)
                                    endif
    4              0.000002     endif

FUNCTION  133()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:288
Called 95 times
Total time:   0.089990
 Self time:   0.000995

count  total (s)   self (s)
   95   0.089949   0.000955     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  135()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:310
Called 8 times
Total time:   0.123580
 Self time:   0.000069

count  total (s)   self (s)
    8   0.123577   0.000066     return self._renderToString(0, 0)

FUNCTION  138()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:24
Called 4 times
Total time:   0.138180
 Self time:   0.000176

count  total (s)   self (s)
    4              0.000023     let l:options = (a:0 > 0) ? a:1 : {}
                            
    4   0.076385   0.000049     call self.toggleOpen(l:options)
                            
                                " Note that we only re-render the NERDTree for this node if we did NOT
                                " create a new node and render it in a new window or tab.  In the latter
                                " case, rendering the NERDTree for this node could overwrite the text of
                                " the new NERDTree!
    4              0.000017     if !has_key(l:options, 'where') || empty(l:options['where'])
    4   0.058416   0.000040         call self.getNerdtree().render()
    4   0.003320   0.000028         call self.putCursorHere(0, 0)
    4              0.000002     endif

FUNCTION  139()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:45
Called 26 times
Total time:   0.000434
 Self time:   0.000434

count  total (s)   self (s)
   26              0.000151     call add(self.children, a:treenode)
   26              0.000092     let a:treenode.parent = self
                            
   26              0.000045     if a:inOrder
                                    call self.sortChildren()
   26              0.000024     endif

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:205
Called 5 times
Total time:   0.001055
 Self time:   0.000432

count  total (s)   self (s)
    5              0.000013   let hunks = []
   29              0.000066   for line in split(a:diff, '\n')
   24   0.000820   0.000198     let hunk_info = gitgutter#diff#parse_hunk(line)
   24              0.000035     if len(hunk_info) == 4
   24              0.000046       call add(hunks, hunk_info)
   24              0.000011     endif
   29              0.000017   endfor
    5              0.000006   return hunks

FUNCTION  <SNR>84_Slash()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:359
Called 15 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
   15              0.000018     return a:path

FUNCTION  51()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:833
Called 33 times
Total time:   0.000876
 Self time:   0.000479

count  total (s)   self (s)
   33   0.000752   0.000355     if !nerdtree#runningWindows()
   33              0.000088         return a:pathstr
                                endif
                            
                                let toReturn = a:pathstr
                            
                                "remove the x:\ of the front
                                let toReturn = substitute(toReturn, '^.*:\(\\\|/\)\?', '/', '')
                            
                                "remove the \\ network share from the front
                                let toReturn = substitute(toReturn, '^\(\\\\\|\/\/\)[^\\\/]*\(\\\|\/\)[^\\\/]*\(\\\|\/\)\?', '/', '')
                            
                                "convert all \ chars to /
                                let toReturn = substitute(toReturn, '\', '/', 'g')
                            
                                return toReturn

FUNCTION  nerdtree#compareNodePaths()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:107
Called 40 times
Total time:   0.011250
 Self time:   0.001682

count  total (s)   self (s)
   40   0.005310   0.000182     let sortKey1 = a:p1.getSortKey()
   40   0.004616   0.000176     let sortKey2 = a:p2.getSortKey()
   40              0.000046     let i = 0
   78              0.000300     while i < min([len(sortKey1), len(sortKey2)])
                                    " Compare chunks upto common length.
                                    " If chunks have different type, the one which has
                                    " integer type is the lesser.
   78              0.000227         if type(sortKey1[i]) ==# type(sortKey2[i])
   78              0.000141             if sortKey1[i] <# sortKey2[i]
   38              0.000034                 return - 1
   40              0.000084             elseif sortKey1[i] ># sortKey2[i]
    2              0.000003                 return 1
   38              0.000018             endif
                                    elseif type(sortKey1[i]) ==# v:t_number
                                        return -1
                                    elseif type(sortKey2[i]) ==# v:t_number
                                        return 1
   38              0.000016         endif
   38              0.000044         let i = i + 1
   38              0.000025     endwhile
                            
                                " Keys are identical upto common length.
                                " The key which has smaller chunks is the lesser one.
                                if len(sortKey1) < len(sortKey2)
                                    return -1
                                elseif len(sortKey1) > len(sortKey2)
                                    return 1
                                else
                                    return 0
                                endif

FUNCTION  142()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:86
Called 26 times
Total time:   0.002598
 Self time:   0.000727

count  total (s)   self (s)
   26   0.001850   0.000413     let newTreeNode = g:NERDTreeFileNode.New(a:path, self.getNerdtree())
   26   0.000677   0.000243     call self.addChild(newTreeNode, a:inOrder)
   26              0.000050     return newTreeNode

FUNCTION  143()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:95
Called 63 times
Total time:   0.049217
 Self time:   0.002762

count  total (s)   self (s)
   63              0.000089     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   63              0.000071     let l:label = ''
   63   0.043802   0.000296     let l:cascade = self.getCascade()
  126              0.000171     for l:dirNode in l:cascade
   63   0.001977   0.000344         let l:next = l:dirNode.path.displayString()
   63              0.000295         let l:label .= l:label ==# '' ? l:next : substitute(l:next,'^.','','')
  126              0.000087     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   63              0.000273     let l:symbol = (l:cascade[-1].isOpen ? g:NERDTreeDirArrowCollapsible : g:NERDTreeDirArrowExpandable )
   63              0.000185     let l:symbol .= (g:NERDTreeDirArrowExpandable ==# '' ? '' : ' ')
   63   0.001696   0.000381     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   63              0.000136     return l:symbol . l:flags . l:label

FUNCTION  144()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:120
Called 59 times
Total time:   0.130818
 Self time:   0.023781

count  total (s)   self (s)
   59   0.029233   0.000676     if a:path.equals(self.path)
    4              0.000008         return self
   55              0.000052     endif
   55   0.024256   0.001355     if stridx(a:path.str(), self.path.str(), 0) ==# -1
   36              0.000100         return {}
   19              0.000021     endif
                            
   19              0.000068     if self.path.isDirectory
   56              0.000302         for i in self.children
   56   0.002727   0.000531             let retVal = i.findNode(a:path)
   56              0.000212             if retVal !=# {}
   19              0.000059                 return retVal
   37              0.000043             endif
   37              0.000062         endfor
                                endif
                                return {}

FUNCTION  147()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:180
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000013     return len(self.children)

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:231
Called 5 times
Total time:   0.005743
 Self time:   0.000368

count  total (s)   self (s)
    5              0.000013   let modified_lines = []
   29              0.000035   for hunk in a:hunks
   24   0.005642   0.000267     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   29              0.000020   endfor
    5              0.000007   return modified_lines

FUNCTION  <SNR>177_process_modified_and_added()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:319
Called 1 time
Total time:   0.000105
 Self time:   0.000105

count  total (s)   self (s)
    1              0.000001   let offset = 0
   17              0.000017   while offset < a:from_count
   16              0.000015     let line_number = a:to_line + offset
   16              0.000028     call add(a:modifications, [line_number, 'modified'])
   16              0.000011     let offset += 1
   17              0.000006   endwhile
    4              0.000003   while offset < a:to_count
    3              0.000003     let line_number = a:to_line + offset
    3              0.000006     call add(a:modifications, [line_number, 'added'])
    3              0.000002     let offset += 1
    4              0.000001   endwhile

FUNCTION  <SNR>181_mru_append()
    Defined: ~/.config/coc/extensions/node_modules/coc-fzf-preview/plugin/fzf_preview.vim:172
Called 14 times
Total time:   0.039361
 Self time:   0.000760

count  total (s)   self (s)
   14   0.000296   0.000125   if s:enable_file(a:path)
   14   0.039010   0.000580     call fzf_preview#remote#mr#append(a:path, fzf_preview#remote#mr#mru_file_path())
   14              0.000032   endif

FUNCTION  270()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:23
Called 160 times
Total time:   0.001461
 Self time:   0.001461

count  total (s)   self (s)
  160              0.000695     if !exists('s:refreshListenersMap')
                                    let s:refreshListenersMap = {}
  160              0.000118     endif
  160              0.000270     return s:refreshListenersMap

FUNCTION  152()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:272
Called 8 times
Total time:   0.006835
 Self time:   0.002914

count  total (s)   self (s)
                            
                                " Construct a path specification such that globpath() will return
                                " relative pathnames, if possible.
    8   0.001646   0.000139     if self.path.str() ==# getcwd()
                                    let l:pathSpec = ','
    8              0.000007     else
    8   0.002552   0.000226         let l:pathSpec = escape(fnamemodify(self.path.str({'format': 'Glob'}), ':.'), ',')
                            
                                    " On Windows, the drive letter may be removed by "fnamemodify()".
    8   0.000199   0.000111         if nerdtree#runningWindows() && l:pathSpec[0] == nerdtree#slash()
                                        let l:pathSpec = self.path.drive . l:pathSpec
    8              0.000008         endif
    8              0.000008     endif
                            
    8              0.000030     let l:globList = []
                            
                                " See ':h version7.txt' and ':h version8.txt' for details on the
                                " development of the glob() and globpath() functions.
    8              0.000049     if v:version > 704 || (v:version ==# 704 && has('patch654'))
    8              0.001270         let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1, 0)
                                elseif v:version ==# 704 && has('patch279')
                                    let l:globList = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore, 1)
                                elseif v:version > 702 || (v:version ==# 702 && has('patch051'))
                                    let l:globString = globpath(l:pathSpec, a:pattern, !g:NERDTreeRespectWildIgnore)
                                    let l:globList = split(l:globString, "\n")
                                else
                                    let l:globString = globpath(l:pathSpec, a:pattern)
                                    let l:globList = split(l:globString, "\n")
    8              0.000008     endif
                            
                                " If a:all is false, filter '.' and '..' from the output.
    8              0.000020     if !a:all
    4              0.000013         let l:toRemove = []
                            
    8              0.000031         for l:file in l:globList
    8              0.000048             let l:tail = fnamemodify(l:file, ':t')
                            
                                        " If l:file has a trailing slash, then its :tail will be ''. Use
                                        " :h to drop the slash and the empty string after it; then use :t
                                        " to get the directory name.
    8              0.000022             if l:tail ==# ''
                                            let l:tail = fnamemodify(l:file, ':h:t')
    8              0.000008             endif
                            
    8              0.000031             if l:tail ==# '.' || l:tail ==# '..'
    8              0.000045                 call add(l:toRemove, l:file)
    8              0.000027                 if len(l:toRemove) ==# 2
    4              0.000006                     break
    4              0.000004                 endif
    4              0.000004             endif
    8              0.000017         endfor
                            
   12              0.000026         for l:file in l:toRemove
    8              0.000054             call remove(l:globList, index(l:globList, l:file))
   12              0.000014         endfor
    8              0.000008     endif
                            
    8              0.000020     return l:globList

FUNCTION  154()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:349
Called 4 times
Total time:   0.003346
 Self time:   0.000029

count  total (s)   self (s)
    4   0.003344   0.000027     return len(self.getVisibleChildren())

FUNCTION  155()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:358
Called 122 times
Total time:   0.061295
 Self time:   0.007105

count  total (s)   self (s)
  122              0.000200     let toReturn = []
  631              0.000708     for i in self.children
  509   0.057768   0.003578         if i.path.ignore(self.getNerdtree()) ==# 0
  493              0.001087             call add(toReturn, i)
  509              0.000249         endif
  631              0.000372     endfor
  122              0.000120     return toReturn

FUNCTION  157()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:382
Called 96 times
Total time:   0.076532
 Self time:   0.003503

count  total (s)   self (s)
   96              0.000164     if g:NERDTreeCascadeSingleChildDir ==# 0
                                    return 0
   96              0.000045     endif
                            
   96   0.024231   0.000389     if self.isRoot()
    8              0.000008         return 0
   88              0.000034     endif
                            
   88              0.000110     if self.path.isSymLink
                                    return 0
   88              0.000032     endif
                            
  176   0.001111   0.000596     for i in g:NERDTreeBookmark.Bookmarks()
   88   0.017995   0.000420         if i.path.equals(self.path)
                                        return 0
   88              0.000045         endif
  176              0.000137     endfor
                            
   88   0.031594   0.000497     let c = self.getVisibleChildren()
   88              0.000255     return len(c) ==# 1 && c[0].path.isDirectory

FUNCTION  158()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:413
Called 4 times
Total time:   0.064643
 Self time:   0.001878

count  total (s)   self (s)
                                "remove all the current child nodes
    4              0.000014     let self.children = []
                            
    4   0.006990   0.000155     let files = self._glob('*', 1) + self._glob('.*', 0)
                            
    4              0.000030     if !a:silent && len(files) > g:NERDTreeNotificationThreshold
                                    call nerdtree#echo('Please wait, caching a large dir ...')
    4              0.000004     endif
                            
    4              0.000014     let invalidFilesFound = 0
   30              0.000065     for i in files
   26              0.000035         try
   26   0.018678   0.000353             let path = g:NERDTreePath.New(i)
   26   0.002846   0.000248             call self.createChild(path, 0)
   26   0.023498   0.000511             call g:NERDTreePathNotifier.NotifyListeners('init', path, self.getNerdtree(), {})
                                    catch /^NERDTree.\(InvalidArguments\|InvalidFiletype\)Error/
                                        let invalidFilesFound += 1
   26              0.000041         endtry
   30              0.000030     endfor
                            
    4              0.000022     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder
    4   0.011918   0.000031     call self.sortChildren()
                            
    4   0.000151   0.000033     call nerdtree#echo('')
                            
    4              0.000009     if invalidFilesFound
                                    call nerdtree#echoWarning(invalidFilesFound . ' file(s) could not be loaded into the NERD tree')
    4              0.000003     endif
    4   0.000051   0.000035     return self.getChildCount()

FUNCTION  159()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:451
Called 5 times
Total time:   0.000385
 Self time:   0.000385

count  total (s)   self (s)
    5              0.000012     if a:path.isDirectory !=# 1
                                    throw 'NERDTree.InvalidArgumentsError: A TreeDirNode object must be instantiated with a directory Path object.'
    5              0.000004     endif
                            
    5              0.000255     let newTreeNode = copy(self)
    5              0.000018     let newTreeNode.path = a:path
                            
    5              0.000013     let newTreeNode.isOpen = 0
    5              0.000014     let newTreeNode.children = []
                            
    5              0.000014     let newTreeNode.parent = {}
    5              0.000015     let newTreeNode._nerdtree = a:nerdtree
                            
    5              0.000009     return newTreeNode

FUNCTION  doge#comment#update_interactive_comment_info()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/comment.vim:121
Called 7 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
    7              0.000015   if exists('b:doge_interactive')
                                " Only update if the cursor is inside the comment.
                                " We add +1 to the lnum_comment_end_pos which covers the scenario if a user
                                " pressed ENTER while being on the last line of the comment.
                                if line('.') > b:doge_interactive['lnum_comment_start_pos'] && line('.') <= b:doge_interactive['lnum_comment_end_pos'] + 1
                                  " When filling in the TODO items the user might hit the ENTER key so we
                                  " constantly have to update the end position of the comment, because the
                                  " comment can get bigger.
                            
                                  " We will use a while loop because of languages like lua and ruby which
                                  " use single-line comments which gives us no separation if we have a lua
                                  " comment like this:
                                  "
                                  "   -- TODO
                                  "   -- @param arg1 TODO
                                  "   -- @param arg2 I can aplp
                                  "   -- @param arg3 TODO
                                  "   -- @param arg4 TODO
                                  "   function new_function(arg1, arg2, arg3, arg4)
                                  "   end
                                  "
                                  " So the idea is to just loop through every line until we come across a
                                  " non-comment line.
                                  let l:lnum_comment_end_pos = line('.')
                                  let l:comment_last_line = doge#helpers#trim(b:doge_interactive['comment'][-1])[0]
                                  while doge#helpers#trim(getline(l:lnum_comment_end_pos)) =~# printf('\m^%s', l:comment_last_line)
                                    let l:lnum_comment_end_pos += 1
                                  endwhile
                            
                                  " If we're still at the same line we're probably dealing with python
                                  " comments (or something equivalent) where it only has an opener and
                                  " closer and each comment line does not start with a comment leader, so
                                  " just search for the last line of the comment
                                  if l:lnum_comment_end_pos == line('.')
                                    let l:lnum_comment_end_pos = search(l:comment_last_line, 'nW')
                                  endif
                            
                                  let b:doge_interactive['lnum_comment_end_pos'] = l:lnum_comment_end_pos - 1
                                endif
    7              0.000003   endif

FUNCTION  <SNR>7_detect_indent()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:2929
Called 10 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
   10              0.000032     if &buftype ==# 'help'
                                  return
   10              0.000006     endif
                            
                                " Do not autodetect indent if language or user sets it
   10              0.000031     if &l:shiftwidth != s:default_shiftwidth
   10              0.000010       return
                                endif
                            
                                let b:sleuth_culprit = expand("<afile>:p")
                                if s:guess(getline(1, 128))
                                  return
                                endif
                                if s:guess(getline(1, 1024))
                                  return
                                endif
                                let pattern = polyglot#sleuth#GlobForFiletype(&filetype)
                                if len(pattern) == 0
                                  return
                                endif
                                let pattern = '{' . pattern . ',.git,.svn,.hg}'
                                let dir = expand('%:p:h')
                                let level = 3
                                while isdirectory(dir) && dir !=# fnamemodify(dir, ':h') && level > 0
                                  " Ignore files from homedir and root 
                                  if dir == expand('~') || dir == '/'
                                    unlet b:sleuth_culprit
                                    return
                                  endif
                                  for neighbor in glob(dir . '/' . pattern, 0, 1)[0:level]
                                    let b:sleuth_culprit = neighbor
                                    " Do not consider directories above .git, .svn or .hg
                                    if fnamemodify(neighbor, ":h:t")[0] == "."
                                      let level = 0
                                      continue
                                    endif
                                    if neighbor !=# expand('%:p') && filereadable(neighbor)
                                      if s:guess(readfile(neighbor, '', 32))
                                        return
                                      endif
                                    endif
                                  endfor
                            
                                  let dir = fnamemodify(dir, ':h')
                                  let level -= 1
                                endwhile
                            
                                let b:sleuth_culprit = "default"

FUNCTION  76()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:30
Called 7 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    7              0.000085     return get(s:keyMaps, a:key . a:scope, {})

FUNCTION  quick_scope#HighlightLineDelay()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:44
Called 495 times
Total time:   0.022767
 Self time:   0.022767

count  total (s)   self (s)
  495              0.003227   if g:qs_enable && g:qs_delay > 0
  495              0.003162     call timer_stop(s:timer)
  495              0.006639     let Cb = function('quick_scope#HighlightLineDelayCallback', [a:direction, a:targets])
  495              0.003157     let s:timer = timer_start(g:qs_delay, Cb)
                              else
                                call quick_scope#UnhighlightLine()
                                call quick_scope#HighlightLine(a:direction, a:targets)
  495              0.000485   endif

FUNCTION  FugitiveVimPath()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:342
Called 9 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    9              0.000030   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
    9              0.000006   else
    9              0.000013     return a:path
                              endif

FUNCTION  NERDTreeRender()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/plugin/NERD_tree.vim:187
Called 4 times
Total time:   0.071501
 Self time:   0.000034

count  total (s)   self (s)
    4   0.071499   0.000032     call nerdtree#renderView()

FUNCTION  indent_guides#highlight_colors()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:94
Called 17 times
Total time:   0.000185
 Self time:   0.000185

count  total (s)   self (s)
   17              0.000025   if s:auto_colors
                                if has('gui_running') || has('nvim')
                                  call indent_guides#gui_highlight_colors()
                                else
                                  call indent_guides#basic_highlight_colors()
                                endif
   17              0.000008   endif

FUNCTION  160()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:472
Called 4 times
Total time:   0.072692
 Self time:   0.000423

count  total (s)   self (s)
    4              0.000017     let l:options = a:0 ? a:1 : {}
                            
                                " If special options were specified, process them and return.
    4              0.000025     if has_key(l:options, 'where') && !empty(l:options['where'])
                                    let l:opener = g:NERDTreeOpener.New(self.path, l:options)
                                    call l:opener.open(self)
                                    return 0
    4              0.000003     endif
                            
                                " Open any ancestors of this node that render within the same cascade.
    4              0.000013     let l:parent = self.parent
    4   0.001652   0.000047     while !empty(l:parent) && !l:parent.isRoot()
    3   0.006111   0.000090         if index(l:parent.getCascade(), self) >= 0
                                        let l:parent.isOpen = 1
                                        let l:parent = l:parent.parent
    3              0.000004         else
    3              0.000006             break
                                    endif
    4              0.000007     endwhile
                            
    4              0.000013     let self.isOpen = 1
                            
    4              0.000014     let l:numChildrenCached = 0
    4              0.000014     if empty(self.children)
    4   0.064708   0.000065         let l:numChildrenCached = self._initChildren(0)
    4              0.000003     endif
                            
    4              0.000006     return l:numChildrenCached

FUNCTION  161()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:507
Called 4 times
Total time:   0.076198
 Self time:   0.000160

count  total (s)   self (s)
    4              0.000015     let opts = a:0 ? a:1 : {}
    4              0.000010     let level = 0
                            
    4              0.000010     let node = self
    4              0.000013     while node.path.isDirectory
    4   0.072727   0.000035         call node.open(opts)
    4              0.000010         let level += 1
    4   0.003373   0.000027         if node.getVisibleChildCount() ==# 1
                                        let node = node.getChildByIndex(0, 1)
    4              0.000003         else
    4              0.000004             break
                                    endif
    4              0.000005     endwhile
    4              0.000005     return level

FUNCTION  167()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:599
Called 39 times
Total time:   0.364184
 Self time:   0.117634

count  total (s)   self (s)
   39   0.053649   0.000621     call self.path.refreshFlags(self.getNerdtree())
  169              0.000544     for i in self.children
  130   0.090857   0.000867         call i.refreshFlags()
  169              0.000145     endfor

FUNCTION  <SNR>82_abs_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:205
Called 52 times
Total time:   0.002481
 Self time:   0.002481

count  total (s)   self (s)
   52              0.001663   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   52              0.000603   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   52              0.000143   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  CocActionAsync()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:82
Called 6 times
Total time:   0.002925
 Self time:   0.000313

count  total (s)   self (s)
    6   0.002904   0.000292   return s:AsyncRequest(a:name, a:000)

FUNCTION  gitgutter#debug#log()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 13 times
Total time:   0.000383
 Self time:   0.000383

count  total (s)   self (s)
   13              0.000023   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   13              0.000007   endif

FUNCTION  NERDTreeWebDevIconsRefreshListener()
    Defined: ~/.config/nvim/autoload/plugged/vim-devicons/plugin/webdevicons.vim:604
Called 160 times
Total time:   0.095436
 Self time:   0.024461

count  total (s)   self (s)
  160              0.000447   let path = a:event.subject
  160              0.000523   let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
  160              0.000450   let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
  160   0.003449   0.001620   let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
  160              0.000908   let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
  160   0.003567   0.001815   let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
  160              0.000642   if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
                                let prePadding .= ' '
  160              0.000102   endif
                            
  160              0.000266   if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
  116   0.043680   0.002073     let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
   44              0.000177   elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
   44              0.000113     let directoryOpened = 0
                            
   44              0.000260     if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
   44              0.000035     endif
                            
   44              0.000135     if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
   44              0.000116       if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
   44              0.000041       else
                                    " the folder is not open
   44              0.000082         if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
   44              0.000038         else
                                      " We have a regular folder
   44   0.021776   0.001164           let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
   44              0.000039         endif
   44              0.000030       endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
   44              0.000033     endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
  160              0.000101   endif
                            
  160   0.002451   0.001415   call path.flagSet.clearFlags('webdevicons')
                            
  160              0.000332   if flag !=? ''
  160   0.005338   0.001198     call path.flagSet.addFlag('webdevicons', flag)
  160              0.000098   endif
                            

FUNCTION  80()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:68
Called 7 times
Total time:   0.340565
 Self time:   0.000358

count  total (s)   self (s)
    7              0.000162     let l:Callback = type(self.callback) ==# type(function('tr')) ? self.callback : function(self.callback)
    7              0.000014     if a:0
    7   0.340349   0.000142         call l:Callback(a:1)
                                else
                                    call l:Callback()
    7              0.000003     endif

FUNCTION  81()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/key_map.vim:87
Called 7 times
Total time:   0.420178
 Self time:   0.001152

count  total (s)   self (s)
                            
                                "required because clicking the command window below another window still
                                "invokes the <LeftRelease> mapping - but changes the window cursor
                                "is in first
                                "
                                "TODO: remove this check when the vim bug is fixed
    7   0.000308   0.000184     if !g:NERDTree.ExistsForBuf()
                                    return {}
    7              0.000026     endif
                            
    7   0.078599   0.000352     let node = g:NERDTreeFileNode.GetSelected()
    7              0.000035     if !empty(node)
                            
                                    "try file node
    7              0.000024         if !node.path.isDirectory
    3   0.000135   0.000093             let km = s:KeyMap.FindFor(a:key, 'FileNode')
    3              0.000012             if !empty(km)
    3   0.200485   0.000061                 return km.invoke(node)
                                        endif
    4              0.000004         endif
                            
                                    "try dir node
    4              0.000009         if node.path.isDirectory
    4   0.000144   0.000094             let km = s:KeyMap.FindFor(a:key, 'DirNode')
    4              0.000013             if !empty(km)
    4   0.140193   0.000051                 return km.invoke(node)
                                        endif
                                    endif
                            
                                    "try generic node
                                    let km = s:KeyMap.FindFor(a:key, 'Node')
                                    if !empty(km)
                                        return km.invoke(node)
                                    endif
                            
                                endif
                            
                                "try bookmark
                                let bm = g:NERDTreeBookmark.GetSelected()
                                if !empty(bm)
                                    let km = s:KeyMap.FindFor(a:key, 'Bookmark')
                                    if !empty(km)
                                        return km.invoke(bm)
                                    endif
                                endif
                            
                                "try all
                                let km = s:KeyMap.FindFor(a:key, 'all')
                                if !empty(km)
                                    return km.invoke()
                                endif

FUNCTION  86()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/bookmark.vim:35
Called 248 times
Total time:   0.001813
 Self time:   0.001813

count  total (s)   self (s)
  248              0.000821     if !exists('g:NERDTreeBookmarks')
                                    let g:NERDTreeBookmarks = []
  248              0.000129     endif
  248              0.000424     return g:NERDTreeBookmarks

FUNCTION  FugitiveGitDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:13
Called 6 times
Total time:   0.000208
 Self time:   0.000201

count  total (s)   self (s)
    6              0.000008   if v:version < 704
                                return ''
    6              0.000015   elseif !a:0 || type(a:1) == type(0) && a:1 < 0
                                if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
                                let dir = get(b:, 'git_dir', '')
                                if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|terminal\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                elseif (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                  return b:git_dir
                                endif
                                return dir =~# s:bad_git_dir ? '' : dir
    6              0.000009   elseif type(a:1) == type(0)
                                if a:1 == bufnr('') && (!exists('b:git_dir') || b:git_dir =~# s:bad_git_dir) && empty(&buftype)
                                  let b:git_dir = FugitiveExtractGitDir(expand('%:p'))
                                endif
                                let dir = getbufvar(a:1, 'git_dir')
                                return dir =~# s:bad_git_dir ? '' : dir
    6              0.000007   elseif type(a:1) == type('')
    6   0.000050   0.000043     return substitute(s:Slash(a:1), '/$', '', '')
                              elseif type(a:1) == type({})
                                return get(a:1, 'git_dir', '')
                              else
                                return ''
                              endif

FUNCTION  <SNR>159_term()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:244
Called 16 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   16              0.000088   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''

FUNCTION  171()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:665
Called 4 times
Total time:   0.011887
 Self time:   0.000318

count  total (s)   self (s)
    4              0.000016     if count(g:NERDTreeSortOrder, '*') < 1
                                    call add(g:NERDTreeSortOrder, '*')
    4              0.000002     endif
    4              0.000018     let CompareFunc = function('nerdtree#compareNodes')
    4   0.011820   0.000252     call sort(self.children, CompareFunc)
    4              0.000018     let g:NERDTreeOldSortOrder = g:NERDTreeSortOrder

FUNCTION  172()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:676
Called 4 times
Total time:   0.076337
 Self time:   0.000138

count  total (s)   self (s)
    4              0.000018     let opts = a:0 ? a:1 : {}
    4              0.000011     if self.isOpen ==# 1
                                    call self.close()
    4              0.000004     else
    4              0.000015         if g:NERDTreeCascadeOpenSingleChildDir ==# 0
                                        call self.open(opts)
    4              0.000004         else
    4   0.076242   0.000043             call self.openAlong(opts)
    4              0.000002         endif
    4              0.000002     endif

FUNCTION  175()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:42
Called 6 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    6              0.000018     if self._keepopen
    6              0.000012         return
                                endif
                            
                                if (a:newtab && self._where ==# 't') || !a:newtab
                                    call g:NERDTree.Close()
                                endif

FUNCTION  177()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:70
Called 3 times
Total time:   0.002000
 Self time:   0.000258

count  total (s)   self (s)
    3   0.000056   0.000037     if b:NERDTree.isWinTree()
                                    if self._where ==# 'v'
                                        call self._newVSplit()
                                    elseif self._where ==# 'h'
                                        call self._newSplit()
                                    elseif self._where ==# 't'
                                        tabnew
                                    endif
    3              0.000003     else
    3   0.000049   0.000031         call self._checkToCloseTree(1)
                            
    3              0.000009         if self._where ==# 'v'
                                        call self._newVSplit()
    3              0.000008         elseif self._where ==# 'h'
                                        call self._newSplit()
    3              0.000006         elseif self._where ==# 't'
                                        tabnew
    3              0.000006         elseif self._where ==# 'p'
    3   0.001714   0.000027             call self._previousWindow()
    3              0.000003         endif
                            
    3   0.000054   0.000036         call self._checkToCloseTree(0)
    3              0.000003     endif

FUNCTION  178()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:102
Called 6 times
Total time:   0.001295
 Self time:   0.000578

count  total (s)   self (s)
                                "gotta split if theres only one window (i.e. the NERD tree)
    6              0.000027     if winnr('$') ==# 1
                                    return 0
    6              0.000008     endif
                            
    6              0.000030     let oldwinnr = winnr()
    6   0.000551   0.000136     call nerdtree#exec(a:winnumber . 'wincmd p', 1)
    6              0.000106     let specialWindow = getbufvar('%', '&buftype') !=# '' || getwinvar('%', '&previewwindow')
    6              0.000030     let modified = &modified
    6   0.000417   0.000114     call nerdtree#exec(oldwinnr . 'wincmd p', 1)
                            
                                "if its a special window e.g. quickfix or another explorer plugin then we
                                "have to split
    6              0.000017     if specialWindow
                                    return 0
    6              0.000007     endif
                            
    6              0.000013     if &hidden
    6              0.000011         return 1
                                endif
                            
                                return !modified || self._bufInWindows(winbufnr(a:winnumber)) >= 2

FUNCTION  illuminate#on_cursor_moved_i()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:46
Called 7 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    7              0.000058   if get(g:, 'Illuminate_insert_mode_highlight', 0)
                                call illuminate#on_cursor_moved()
    7              0.000008   endif

FUNCTION  doge#helpers#placeholder()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/helpers.vim:63
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000004   if !has_key(a:, 1)
    1              0.000002     return '\(\[TODO:[[:alnum:]-]\+\]\|TODO\)'
                              else
                                return printf('[TODO:%s]', a:1)
                              endif

FUNCTION  nerdtree#echo()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:219
Called 4 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
    4              0.000053     redraw
    4              0.000062     echomsg empty(a:msg) ? '' : ('NERDTree: ' . a:msg)

FUNCTION  <SNR>66_match()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:145
Called 52 times
Total time:   0.001040
 Self time:   0.000535

count  total (s)   self (s)
   52              0.000055   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
   52              0.000045   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
   52              0.000039   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
   52              0.000017   else
   52   0.000682   0.000177     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:88
Called 5 times
Total time:   0.000226
 Self time:   0.000037

count  total (s)   self (s)
    5   0.000221   0.000032   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  179()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:138
Called 3 times
Total time:   0.000619
 Self time:   0.000474

count  total (s)   self (s)
    3              0.000112     let l:newOpener = copy(self)
                            
    3   0.000143   0.000089     let l:newOpener._keepopen = nerdtree#has_opt(a:opts, 'keepopen')
    3              0.000023     let l:newOpener._nerdtree = b:NERDTree
    3              0.000019     let l:newOpener._path = a:path
    3              0.000045     let l:newOpener._reuse = has_key(a:opts, 'reuse') ? a:opts['reuse'] : ''
    3   0.000117   0.000076     let l:newOpener._stay = nerdtree#has_opt(a:opts, 'stay')
    3              0.000032     let l:newOpener._where = has_key(a:opts, 'where') ? a:opts['where'] : ''
                            
    3   0.000094   0.000044     call l:newOpener._saveCursorPos()
                            
    3              0.000013     return l:newOpener

FUNCTION  182()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:209
Called 3 times
Total time:   0.199109
 Self time:   0.000105

count  total (s)   self (s)
    3              0.000014     if self._path.isDirectory
                                    call self._openDirectory(a:target)
                                    return
    3              0.000005     endif
                            
    3   0.199050   0.000045     call self._openFile()

FUNCTION  183()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:219
Called 3 times
Total time:   0.199005
 Self time:   0.000280

count  total (s)   self (s)
    3              0.000035     if !self._stay && self._keepopen && get(b:, 'NERDTreeZoomed', 0)
                                    call b:NERDTree.ui.toggleZoom()
    3              0.000005     endif
                            
    3   0.003289   0.000041     if self._reuseWindow()
                                    return
    3              0.000003     endif
                            
    3   0.002047   0.000047     call self._gotoTargetWin()
                            
    3              0.000008     if self._stay
                                    silent call self._path.edit()
                                    call self._restoreCursorPos()
                                    return
    3              0.000003     endif
                            
    3   0.193528   0.000051     call self._path.edit()

FUNCTION  185()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:261
Called 3 times
Total time:   0.001687
 Self time:   0.000277

count  total (s)   self (s)
    3   0.000867   0.000060     if !self._isWindowUsable(winnr('#')) && self._firstUsableWindow() ==# -1
                                    call self._newSplit()
    3              0.000004     else
    3              0.000005         try
    3   0.000539   0.000051             if !self._isWindowUsable(winnr('#'))
                                            call nerdtree#exec(self._firstUsableWindow() . 'wincmd w', 1)
    3              0.000005             else
    3   0.000157   0.000042                 call nerdtree#exec('wincmd p', 1)
    3              0.000003             endif
                                    catch /^Vim\%((\a\+)\)\=:E37/
                                        call g:NERDTree.CursorToTreeWin()
                                        throw 'NERDTree.FileAlreadyOpenAndModifiedError: '. self._path.str() .' is already open and modified.'
                                    catch /^Vim\%((\a\+)\)\=:/
                                        echo v:exception
    3              0.000005         endtry
    3              0.000003     endif

FUNCTION  187()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:290
Called 3 times
Total time:   0.003248
 Self time:   0.001115

count  total (s)   self (s)
    3              0.000019     if empty(self._reuse)
                                    return 0
    3              0.000004     endif
                            
                                "check the current tab for the window
    3   0.001664   0.000815     let winnr = bufwinnr('^' . self._path.str() . '$')
    3              0.000020     if winnr !=# -1
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    call self._checkToCloseTree(0)
                                    return 1
    3              0.000004     endif
                            
    3              0.000017     if self._reuse ==# 'currenttab'
                                    return 0
    3              0.000004     endif
                            
                                "check other tabs
    3   0.001350   0.000066     let tabnr = self._path.tabnr()
    3              0.000007     if tabnr
                                    call self._checkToCloseTree(1)
                                    call nerdtree#exec(tabnr . 'tabnext', 1)
                                    let winnr = bufwinnr('^' . self._path.str() . '$')
                                    call nerdtree#exec(winnr . 'wincmd w', 0)
                                    return 1
    3              0.000004     endif
                            
    3              0.000005     return 0

FUNCTION  <SNR>177_is_modified()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 7 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    7              0.000022   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>59_set_syntax()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:227
Called 9 times
Total time:   0.000630
 Self time:   0.000493

count  total (s)   self (s)
    9   0.000207   0.000092   call s:DebugIndent('set_syntax: set:'.a:s, {'b': a:b})
    9              0.000036   let orig_syntax = getbufvar(a:b, '_diminactive_orig_syntax')
    9              0.000009   if a:s
    9              0.000019     if !empty(orig_syntax)
                                  call s:Debug('Restoring orig_syntax: '.orig_syntax, {'b': a:b})
                                  call setbufvar(a:b, '&syntax', orig_syntax)
                                  call setbufvar(a:b, '_diminactive_orig_syntax', '')
    9              0.000008     else
    9   0.000094   0.000072       call s:Debug('set_syntax: nothing to restore!', {'b': a:b})
    9              0.000005     endif
                              else
                                if !empty(orig_syntax)
                                  call s:Debug('set_syntax: off: should be off already!')
                                else
                                  let syntax = getbufvar(a:b, '&syntax')
                                  if syntax !=# 'off'
                                    call s:Debug('set_syntax: storing')
                                    call setbufvar(a:b, '_diminactive_orig_syntax', syntax)
                                    call setbufvar(a:b, '&syntax', 'off')
                                  else
                                    call s:Debug('set_syntax: already off!')
                                  endif
                                endif
    9              0.000004   endif
    9              0.000017   let s:debug_indent -= 1

FUNCTION  <SNR>131_Highlight_Matching_Pair()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:40
Called 505 times
Total time:   0.099479
 Self time:   0.093480

count  total (s)   self (s)
                              " Remove any previous match.
  505   0.010385   0.004387   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  505              0.002687   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  505              0.000288   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  505              0.001601   let c_lnum = line('.')
  505              0.001288   let c_col = col('.')
  505              0.000759   let before = 0
                            
  505              0.001612   let text = getline(c_lnum)
  505              0.010899   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  505              0.001321   if empty(matches)
                                let [c_before, c] = ['', '']
  505              0.000441   else
  505              0.002953     let [c_before, c] = matches[1:2]
  505              0.000380   endif
  505              0.008613   let plist = split(&matchpairs, '.\zs[:,]')
  505              0.002419   let i = index(plist, c)
  505              0.000799   if i < 0
                                " not found, in Insert mode try character before the cursor
  467              0.002508     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   14              0.000028       let before = strlen(c_before)
   14              0.000014       let c = c_before
   14              0.000023       let i = index(plist, c)
  467              0.000384     endif
  467              0.000582     if i < 0
                                  " not found, nothing to do
  467              0.000510       return
                                endif
   38              0.000027   endif
                            
                              " Figure out the arguments for searchpairpos().
   38              0.000066   if i % 2 == 0
   16              0.000033     let s_flags = 'nW'
   16              0.000056     let c2 = plist[i + 1]
   22              0.000016   else
   22              0.000044     let s_flags = 'nbW'
   22              0.000051     let c2 = c
   22              0.000073     let c = plist[i - 1]
   38              0.000026   endif
   38              0.000068   if c == '['
                                let c = '\['
                                let c2 = '\]'
   38              0.000021   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   38              0.000061   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
   38              0.000028   endif
                            
   38              0.000360   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
   38              0.000026   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
   38              0.000225     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   38              0.000047     try
   38              0.009139       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
   38              0.000041     endtry
   38              0.000026   endif
                            
                              " Limit the search to lines visible in the window.
   38              0.000160   let stoplinebottom = line('w$')
   38              0.000108   let stoplinetop = line('w0')
   38              0.000077   if i % 2 == 0
   16              0.000047     let stopline = stoplinebottom
   22              0.000019   else
   22              0.000062     let stopline = stoplinetop
   38              0.000024   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   38              0.000208   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
   38              0.000025   else
   38              0.000241     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   38              0.000024   endif
   38              0.000037   try
   38              0.022049     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
   38              0.000044   endtry
                            
   38              0.000072   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
   38              0.000023   endif
                            
                              " If a match is found setup match highlighting.
   38              0.000162   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   22              0.000088     if exists('*matchaddpos')
   22              0.001169       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
   22              0.000013     endif
   22              0.000064     let w:paren_hl_on = 1
   38              0.000022   endif

FUNCTION  <SNR>158_get_highlight_patterns()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:224
Called 92 times
Total time:   0.192082
 Self time:   0.177152

count  total (s)   self (s)
                              " Keeps track of the number of occurrences for each target
   92              0.000332   let occurrences = {}
                            
                              " Use 'count_proxy' to account for [count]f when highlight on keys mode is
                              " used, otherwise just use assume 1
   92              0.000355   if !exists('g:qs_highlight_on_keys')
   92              0.000197     let count_proxy = 1
                              else
                                let count_proxy = v:count1
   92              0.000077   endif
                            
                              " Patterns to match the characters that will be marked with primary and
                              " secondary highlight groups, respectively
   92              0.000451   let [patt_p, patt_s] = ['', '']
                            
                              " Indicates whether this is the first word under the cursor. We don't want
                              " to highlight any characters in it.
   92              0.000247   let is_first_word = 1
                            
                              " We want to skip the first char as this is the char the cursor is at
   92              0.000155   let is_first_char = 1
                            
                              " The position of a character in a word that will be given a highlight. A
                              " value of 0 indicates there is no character to highlight.
   92              0.000339   let [hi_p, hi_s] = [0, 0]
                            
                              " The (next) characters that will be given a highlight. Used by
                              " save_chars_with_secondary_highlights() to see whether an extra highlight
                              " should be triggered if g:qs_highlight_on_keys is active.
   92              0.000347   let [char_p, char_s] = ['', '']
                            
                              " If 1, we're looping forwards from the cursor to the end of the line;
                              " otherwise, we're looping from the cursor to the beginning of the line.
   92              0.000411   let direction = a:cursor < a:end ? 1 : 0
                            
                              " find the character index i and the byte index c
                              " of the current cursor position
   92              0.000149   let c = 1
   92              0.000134   let i = 0
   92              0.000157   let char = ''
 1372              0.001569   while c != a:cursor
 1280              0.005575     let char = matchstr(a:line, '.', byteidx(a:line, i))
 1280              0.002162     let c += len(char)
 1280              0.001165     let i += 1
 1372              0.000828   endwhile
                            
                              " reposition cursor to end of the char's composing bytes
   92              0.000158   if !direction
   51              0.000558     let c += len(matchstr(a:line, '.', byteidx(a:line, i))) - 1
   92              0.000082   endif
                            
                              " catch cases where multibyte chars may result in c not exactly equal to
                              " a:end
 1867              0.005311   while (direction && c <= a:end || !direction && c >= a:end)
                            
 1775              0.012373     let char = matchstr(a:line, '.', byteidx(a:line, i))
                            
                                " Skips the first char as it is the char the cursor is at
 1775              0.002199     if is_first_char
                            
   92              0.000192       let is_first_char = 0
                            
                                " Don't consider the character for highlighting, but mark the position
                                " as the start of a new word.
                                " use '\k' to check against keyword characters (see :help 'iskeyword' and
                                " :help /\k)
 1683              0.006923     elseif char !~# '\k' || empty(char)
  772              0.000983       if !is_first_word
  690   0.023413   0.010471         let [patt_p, patt_s] = s:add_to_highlight_patterns([patt_p, patt_s], [hi_p, hi_s])
  772              0.000511       endif
                            
                                  " We've reached a new word, so reset any highlights.
  772              0.002079       let [hi_p, hi_s] = [0, 0]
  772              0.002149       let [char_p, char_s] = ['', '']
                            
  772              0.001250       let is_first_word = 0
  911              0.004281     elseif index(a:targets, g:qs_ignorecase ? tolower(char) : char) != -1
  877              0.000998       if g:qs_ignorecase
                                    " When g:qs_ignorecase is set, make char_i the lowercase of char
                                    let char_i = tolower(char)
  877              0.000477       else
  877              0.001271         let char_i = char
  877              0.000458       endif
                                  " Do all counting based on char_i in case we are doing ignorecase
  877              0.002051       if has_key(occurrences, char_i)
  264              0.000535         let occurrences[char_i] += 1
  613              0.000330       else
  613              0.001469         let occurrences[char_i] = 1
  877              0.000456       endif
                            
  877              0.001002       if !is_first_word
  712              0.002179         let char_occurrences = get(occurrences, char_i)
                                    " Below use char instead of char_i so that highlights get placed on the
                                    " correct character regardless of ignorecase
                            
                                    " If the search is forward, we want to be greedy; otherwise, we
                                    " want to be reluctant. This prioritizes highlighting for
                                    " characters at the beginning of a word.
                                    "
                                    " If this is the first occurrence of the letter in the word,
                                    " mark it for a highlight.
                                    " If we are looking backwards, c will point to the end of the
                                    " composing bytes so we adjust accordingly
                                    " eg. with a multibyte char of length 3, c will point to the
                                    " 3rd byte. Minus (len(char) - 1) to adjust to 1st byte
  712              0.002528         if char_occurrences == count_proxy && ((direction == 1 && hi_p == 0) || direction == 0)
  229              0.000822           let hi_p = c - (1 - direction) * (len(char) - 1)
  229              0.000316           let char_p = char
  483              0.001724         elseif char_occurrences == (count_proxy + 1) && ((direction == 1 && hi_s == 0) || direction == 0)
  107              0.000340           let hi_s = c - (1 - direction) * (len(char)- 1)
  107              0.000133           let char_s = char
  712              0.000411         endif
  877              0.000439       endif
 1775              0.000919     endif
                            
                                " update i to next character
                                " update c to next byteindex
 1775              0.002205     if direction == 1
  995              0.001471       let i += 1
  995              0.002431       let c += strlen(char)
  780              0.000435     else
  780              0.000910       let i -= 1
  780              0.001648       let c -= strlen(char)
 1775              0.000944     endif
 1867              0.001828   endwhile
                            
   92   0.003968   0.001980   let [patt_p, patt_s] = s:add_to_highlight_patterns([patt_p, patt_s], [hi_p, hi_s])
                            
   92              0.000348   if exists('g:qs_highlight_on_keys')
                                call s:save_chars_with_secondary_highlights([char_p, char_s])
   92              0.000066   endif
                            
   92              0.000217   return [patt_p, patt_s]

FUNCTION  AutoPairsDefaultPairs()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:20
Called 4 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
    4              0.000011   if exists('b:autopairs_defaultpairs')
                                return b:autopairs_defaultpairs
    4              0.000003   end
    4              0.000033   let r = copy(g:AutoPairs)
    4              0.000047   let allPairs = { 'vim': {'\v^\s*\zs"': ''}, 'rust': {'\w\zs<': '>', '&\zs''': ''}, 'php': {'<?': '?>//k]', '<?php': '?>//k]'} }
   16              0.000052   for [filetype, pairs] in items(allPairs)
   12              0.000025     if &filetype == filetype
                                  for [open, close] in items(pairs)
                                    let r[open] = close
                                  endfor
   12              0.000007     end
   16              0.000013   endfor
    4              0.000010   let b:autopairs_defaultpairs = r
    4              0.000005   return r

FUNCTION  FugitiveDetect()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:313
Called 3 times
Total time:   0.001112
 Self time:   0.000064

count  total (s)   self (s)
    3              0.000004   if v:version < 704
                                return ''
    3              0.000001   endif
    3              0.000007   if exists('b:git_dir') && b:git_dir =~# '^$\|' . s:bad_git_dir
                                unlet b:git_dir
    3              0.000001   endif
    3              0.000003   if !exists('b:git_dir')
    3   0.001065   0.000017     let b:git_dir = FugitiveExtractGitDir(a:path)
    3              0.000001   endif
    3              0.000019   if empty(b:git_dir) || !exists('#User#Fugitive')
    3              0.000002     return ''
                              endif
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                doautocmd <nomodeline> User Fugitive
                              elseif &modelines > 0
                                let modelines = &modelines
                                try
                                  set modelines=0
                                  doautocmd User Fugitive
                                finally
                                  let &modelines = modelines
                                endtry
                              else
                                doautocmd User Fugitive
                              endif
                              return ''

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 5 times
Total time:   0.000101
 Self time:   0.000048

count  total (s)   self (s)
    5   0.000097   0.000044   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>93_StopHL()
    Defined: ~/.config/nvim/autoload/plugged/vim-cool/plugin/cool.vim:76
Called 2 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000007     if !v:hlsearch || mode() isnot 'n'
    1              0.000001         return
    1              0.000001     else
    1              0.000007         silent call feedkeys("\<Plug>(StopHL)", 'm')
    1              0.000001     endif

FUNCTION  <SNR>159_normalize()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:316
Called 645 times
Total time:   0.004983
 Self time:   0.004983

count  total (s)   self (s)
  645              0.001171   if type(a:result) == 3
  645              0.003506     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
                              elseif type(a:result) == 1
                                return [a:result]
                              else
                                return [string(a:result)]
                              endif

FUNCTION  AutoPairsInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:471
Called 4 times
Total time:   0.007680
 Self time:   0.005228

count  total (s)   self (s)
    4              0.000012   let b:autopairs_loaded  = 1
    4              0.000013   if !exists('b:autopairs_enabled')
    4              0.000008     let b:autopairs_enabled = 1
    4              0.000002   end
                            
    4              0.000009   if !exists('b:AutoPairs')
    4   0.000346   0.000050     let b:AutoPairs = AutoPairsDefaultPairs()
    4              0.000003   end
                            
    4              0.000011   if !exists('b:AutoPairsMoveCharacter')
    4              0.000012     let b:AutoPairsMoveCharacter = g:AutoPairsMoveCharacter
    4              0.000002   end
                            
    4              0.000008   let b:autopairs_return_pos = 0
    4              0.000011   let b:autopairs_saved_pair = [0, 0]
    4              0.000007   let b:AutoPairsList = []
                            
                              " buffer level map pairs keys
                              " n - do not map the first charactor of closed pair to close key
                              " m - close key jumps through multi line
                              " s - close key jumps only in the same line
   40              0.000107   for [open, close] in items(b:AutoPairs)
   36              0.000090     let o = open[-1:-1]
   36              0.000059     let c = close[0]
   36              0.000122     let opt = {'mapclose': 1, 'multiline':1}
   36              0.000078     let opt['key'] = c
   36              0.000049     if o == c
   24              0.000048       let opt['multiline'] = 0
   36              0.000020     end
   36              0.000293     let m = matchlist(close, '\v(.*)//(.*)$')
   36              0.000085     if len(m) > 0 
                                  if m[2] =~ 'n'
                                    let opt['mapclose'] = 0
                                  end
                                  if m[2] =~ 'm'
                                    let opt['multiline'] = 1
                                  end
                                  if m[2] =~ 's'
                                    let opt['multiline'] = 0
                                  end
                                  let ks = matchlist(m[2], '\vk(.)')
                                  if len(ks) > 0
                                    let opt['key'] = ks[1]
                                    let c = opt['key']
                                  end
                                  let close = m[1]
   36              0.000019     end
   36   0.001817   0.000311     call AutoPairsMap(o)
   36              0.000119     if o != c && c != '' && opt['mapclose']
   12   0.000525   0.000086       call AutoPairsMap(c)
   36              0.000024     end
   36              0.000173     let b:AutoPairsList += [[open, close, opt]]
   40              0.000037   endfor
                            
                              " sort pairs by length, longer pair should have higher priority
    4   0.000567   0.000356   let b:AutoPairsList = sort(b:AutoPairsList, "s:sortByLength")
                            
   40              0.000040   for item in b:AutoPairsList
   36              0.000073     let [open, close, opt] = item
   36              0.000055     if open == "'" && open == close
    4              0.000009       let item[0] = '\v(^|\W)\zs'''
   36              0.000016     end
   40              0.000022   endfor
                            
                            
   36              0.000094   for key in split(b:AutoPairsMoveCharacter, '\s*')
   32              0.000159     let escaped_key = substitute(key, "'", "''", 'g')
   32              0.000835     execute 'inoremap <silent> <buffer> <M-'.key."> <C-R>=AutoPairsMoveCharacter('".escaped_key."')<CR>"
   36              0.000044   endfor
                            
                              " Still use <buffer> level mapping for <BS> <SPACE>
    4              0.000006   if g:AutoPairsMapBS
                                " Use <C-R> instead of <expr> for issue #14 sometimes press BS output strange words
    4              0.000069     execute 'inoremap <buffer> <silent> <BS> <C-R>=AutoPairsDelete()<CR>'
    4              0.000003   end
                            
    4              0.000005   if g:AutoPairsMapCh
    4              0.000064     execute 'inoremap <buffer> <silent> <C-h> <C-R>=AutoPairsDelete()<CR>'
    4              0.000003   endif
                            
    4              0.000006   if g:AutoPairsMapSpace
                                " Try to respect abbreviations on a <SPACE>
    4              0.000007     let do_abbrev = ""
    4              0.000014     if v:version == 703 && has("patch489") || v:version > 703
    4              0.000006       let do_abbrev = "<C-]>"
    4              0.000002     endif
    4              0.000073     execute 'inoremap <buffer> <silent> <SPACE> '.do_abbrev.'<C-R>=AutoPairsSpace()<CR>'
    4              0.000002   end
                            
    4              0.000008   if g:AutoPairsShortcutFastWrap != ''
    4              0.000068     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutFastWrap.' <C-R>=AutoPairsFastWrap()<CR>'
    4              0.000002   end
                            
    4              0.000007   if g:AutoPairsShortcutBackInsert != ''
    4              0.000066     execute 'inoremap <buffer> <silent> '.g:AutoPairsShortcutBackInsert.' <C-R>=AutoPairsBackInsert()<CR>'
    4              0.000002   end
                            
    4              0.000006   if g:AutoPairsShortcutToggle != ''
                                " use <expr> to ensure showing the status when toggle
    4              0.000062     execute 'inoremap <buffer> <silent> <expr> '.g:AutoPairsShortcutToggle.' AutoPairsToggle()'
    4              0.000078     execute 'noremap <buffer> <silent> '.g:AutoPairsShortcutToggle.' :call AutoPairsToggle()<CR>'
    4              0.000002   end
                            
    4              0.000007   if g:AutoPairsShortcutJump != ''
    4              0.000070     execute 'inoremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' <ESC>:call AutoPairsJump()<CR>a'
    4              0.000071     execute 'noremap <buffer> <silent> ' . g:AutoPairsShortcutJump. ' :call AutoPairsJump()<CR>'
    4              0.000002   end
                            
    4              0.000007   if &keymap != ''
                                let l:imsearch = &imsearch
                                let l:iminsert = &iminsert
                                let l:imdisable = &imdisable
                                execute 'setlocal keymap=' . &keymap
                                execute 'setlocal imsearch=' . l:imsearch
                                execute 'setlocal iminsert=' . l:iminsert
                                if l:imdisable
                                  execute 'setlocal imdisable'
                                else
                                  execute 'setlocal noimdisable'
                                end
    4              0.000002   end
                            

FUNCTION  <SNR>82_is_file_buffer()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:63
Called 20 times
Total time:   0.000118
 Self time:   0.000118

count  total (s)   self (s)
   20              0.000109   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>82_winshell()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:68
Called 5 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    5              0.000025   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>158_apply_highlight_patterns()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:180
Called 92 times
Total time:   0.004282
 Self time:   0.004282

count  total (s)   self (s)
   92              0.000342   let [patt_p, patt_s] = a:patterns
   92              0.000263   if !empty(patt_p)
                                " Highlight columns corresponding to matched characters.
                                "
                                " Ignore the leading | in the primary highlights string.
   53              0.002010     call matchadd(g:qs_hi_group_primary, '\v%' . line('.') . 'l(' . patt_p[1:] . ')', g:qs_hi_priority)
   92              0.000090   endif
   92              0.000329   if !empty(patt_s) && g:qs_second_highlight
    7              0.000089     call matchadd(g:qs_hi_group_secondary, '\v%' . line('.') . 'l(' . patt_s[1:] . ')', g:qs_hi_priority)
   92              0.000068   endif

FUNCTION  214()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:20
Called 320 times
Total time:   0.003319
 Self time:   0.003319

count  total (s)   self (s)
  320              0.001281     if !has_key(self._flags, a:scope)
   27              0.000147         let self._flags[a:scope] = []
  320              0.000227     endif
  320              0.000969     return self._flags[a:scope]

FUNCTION  215()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:28
Called 33 times
Total time:   0.000588
 Self time:   0.000588

count  total (s)   self (s)
   33              0.000351     let newObj = copy(self)
   33              0.000133     let newObj._flags = {}
   33              0.000074     return newObj

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 7 times
Total time:   0.000340
 Self time:   0.000123

count  total (s)   self (s)
    7   0.000176   0.000046   let summary = gitgutter#hunk#summary(a:bufnr)
    7              0.000013   let summary[1] += a:count
    7   0.000140   0.000052   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  241()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:159
Called 7 times
Total time:   0.020023
 Self time:   0.005435

count  total (s)   self (s)
    7              0.000113     let line = getline(a:ln)
                            
    7   0.000938   0.000123     let rootLine = self.getRootLineNum()
                            
    7              0.000033     if a:ln ==# rootLine
                                    return self.nerdtree.root.path
    7              0.000011     endif
                            
    7   0.000185   0.000150     if line ==# s:UI.UpDirLine()
                                    return self.nerdtree.root.path.getParent()
    7              0.000010     endif
                            
    7              0.000029     if a:ln < rootLine
                                    return {}
    7              0.000008     endif
                            
    7   0.000797   0.000119     let indent = self._indentLevelFor(line)
                            
                                " remove the tree parts and the leading space
    7   0.000463   0.000123     let curFile = self._stripMarkup(line)
                            
    7              0.000024     let dir = ''
    7              0.000027     let lnum = a:ln
   49              0.000144     while lnum > 0
   49              0.000169         let lnum = lnum - 1
   49              0.000270         let curLine = getline(lnum)
   49   0.002279   0.000649         let curLineStripped = self._stripMarkup(curLine)
                            
                                    " have we reached the top of the tree?
   49              0.000167         if lnum ==# rootLine
    7   0.001656   0.000194             let dir = self.nerdtree.root.path.str({'format': 'UI'}) . dir
    7              0.000016             break
   42              0.000052         endif
   42              0.000354         if curLineStripped =~# '/$'
   41   0.003362   0.000534             let lpindent = self._indentLevelFor(curLine)
   41              0.000153             if lpindent < indent
   12              0.000045                 let indent = indent - 1
                            
   12              0.000155                 let dir = substitute (curLineStripped,'^\\', '', '') . dir
   12              0.000036                 continue
   29              0.000039             endif
   30              0.000037         endif
   37              0.000078     endwhile
    7              0.000098     let curFile = self.nerdtree.root.path.drive . dir . curFile
    7   0.006963   0.000165     let toReturn = g:NERDTreePath.New(curFile)
    7              0.000020     return toReturn

FUNCTION  <SNR>76_select_buffers()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:288
Called 207 times
Total time:   0.011873
 Self time:   0.007149

count  total (s)   self (s)
  207              0.001517   let [l:before_names, l:current_names, l:after_names] = [a:before[0], a:current[0], a:after[0]]
  207              0.001118   let [l:before_lengths, l:current_lengths, l:after_lengths] = [a:before[1], a:current[1], a:after[1]]
                            
                              " The current buffer is always displayed
  207              0.000830   let l:width = &columns - l:current_lengths[:0][0]
                            
                              " Display all buffers if there is enough space to display them
  207   0.007316   0.002593   if s:sum(l:before_lengths) + s:sum(l:after_lengths) <= l:width
  207              0.000581     return [l:before_names, l:current_names, l:after_names]
                              endif
                            
                              " Try to fit as many buffers as possible
                              let [l:before, l:current, l:after] = s:select_fitting_buffers(l:before_names, l:current_names, l:after_names, l:before_lengths, l:after_lengths, l:width)
                            
                              " See on which side buffers did not fit
                              let l:more_before = len(l:before_names) > len(l:before)
                              let l:more_after = len(l:after_names) > len(l:after)
                            
                              if l:more_before && l:more_after
                                " Buffers on both sides don't fit. Recompute, but account for s:more_buffers to be visible on both sides
                                let [l:before, l:current, l:after] = s:select_fitting_buffers(l:before_names, l:current_names, l:after_names, l:before_lengths, l:after_lengths, l:width - s:more_buffers_width*2)
                                let l:before = [s:more_buffers] + l:before
                                let l:after += [s:more_buffers]
                              elseif l:more_before || l:more_after
                                " Buffers on one side don't fit. Recompute, but account for s:more_buffers to be visible on that side
                                let [l:before, l:current, l:after] = s:select_fitting_buffers(l:before_names, l:current_names, l:after_names, l:before_lengths, l:after_lengths, l:width - s:more_buffers_width)
                                " With s:more_buffers visible it is possible that buffers on another side don't fit anymore
                                let l:more_before = len(l:before_names) > len(l:before)
                                let l:more_after = len(l:after_names) > len(l:after)
                                if l:more_before && l:more_after
                                  " Indeed, buffers on both sides don't fit now. Recompute, but account for s:more_buffers to be visible on both sides
                                  let [l:before, l:current, l:after] = s:select_fitting_buffers(l:before_names, l:current_names, l:after_names, l:before_lengths, l:after_lengths, l:width - s:more_buffers_width*2)
                                  " Now add s:more_buffers on both sides
                                  let l:before = [s:more_buffers] + l:before
                                  let l:after += [s:more_buffers]
                                elseif l:more_before
                                  " Buffers on the left side don't fit, add s:more_buffers to the left
                                  let l:before = [s:more_buffers] + l:before
                                elseif l:more_after
                                  " Buffers on the right side don't fit, add s:more_buffers to the right
                                  let l:after += [s:more_buffers]
                                end
                              endif
                            
                              return [l:before, l:current, l:after]

FUNCTION  nerdtree#runningWindows()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:202
Called 2777 times
Total time:   0.026333
 Self time:   0.026333

count  total (s)   self (s)
 2777              0.025196     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>93_StartHL()
    Defined: ~/.config/nvim/autoload/plugged/vim-cool/plugin/cool.vim:28
Called 480 times
Total time:   0.016658
 Self time:   0.016644

count  total (s)   self (s)
  480              0.002237     if !v:hlsearch || mode() isnot 'n'
  290              0.000384         return
  190              0.000105     endif
  190              0.001845     let [pos, rpos] = [winsaveview(), getpos('.')]
  190              0.002369     silent! exe "keepjumps go".(line2byte('.')+col('.')-(v:searchforward ? 2 : 0))
  190              0.000161     try
  190              0.003999         silent keepjumps norm! n
  189              0.000907         if getpos('.') != rpos
                                        throw 0
  189              0.000117         endif
    1              0.000012     catch /^\%(0$\|Vim\%(\w\|:Interrupt$\)\@!\)/
    1   0.000020   0.000006         call <SID>StopHL()
    1              0.000001         return
  190              0.000234     finally
  190              0.000750         call winrestview(pos)
  190              0.000190     endtry
  189              0.000725     if !get(g:,'CoolTotalMatches') || !exists('*reltimestr')
  189              0.000154         return
                                endif
                                exe "silent! norm! :let g:cool_char=nr2char(screenchar(screenrow(),1))\<cr>"
                                let cool_char = remove(g:,'cool_char')
                                if cool_char !~ '[/?]'
                                    return
                                endif
                                let [f, ws, now, noOf] = [0, &wrapscan, reltime(), [0,0]]
                                set nowrapscan
                                try
                                    while f < 2
                                        if reltimestr(reltime(now))[:-6] =~ '[1-9]'
                                            " time >= 100ms
                                            return
                                        endif
                                        let noOf[v:searchforward ? f : !f] += 1
                                        try
                                            silent exe "keepjumps norm! ".(f ? 'n' : 'N')
                                        catch /^Vim[^)]\+):E38[45]\D/
                                            call setpos('.',rpos)
                                            let f += 1
                                        endtry
                                    endwhile
                                finally
                                    call winrestview(pos)
                                    let &wrapscan = ws
                                endtry
                                redraw|echo cool_char.@/ 'match' noOf[0] 'of' noOf[0] + noOf[1] - 1

FUNCTION  <SNR>163_has_fresh_changes()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter.vim:162
Called 11 times
Total time:   0.000230
 Self time:   0.000114

count  total (s)   self (s)
   11   0.000225   0.000110   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  coc#float#nvim_win_enter()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:1125
Called 5 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    5              0.000026   let kind = getwinvar(a:winid, 'kind', '')
    5              0.000016   if kind == 'buttons' || kind == 'close'
                                if empty(maparg('<LeftRelease>', 'n'))
                                  nnoremap <buffer><silent> <LeftRelease> :call coc#float#nvim_float_click()<CR>
                                endif
    5              0.000003   endif

FUNCTION  <SNR>66_root()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:117
Called 4 times
Total time:   0.002347
 Self time:   0.000840

count  total (s)   self (s)
    4   0.000490   0.000040   let dir = s:current()
                            
                              " breadth-first search
   12              0.000009   while 1
   60              0.000063     for pattern in g:rooter_patterns
   52              0.000079       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
   52              0.000017       else
   52              0.000085         let [p, exclude] = [pattern, 0]
   52              0.000016       endif
   52   0.001237   0.000197       if s:match(dir, p)
    4              0.000006         if exclude
                                      break
    4              0.000004         else
    4              0.000006           return dir
                                    endif
   48              0.000013       endif
   56              0.000021     endfor
                            
    8   0.000058   0.000041     let [current, dir] = [dir, s:parent(dir)]
   13              0.000016     if current == dir | break | endif
    8              0.000004   endwhile
                            
                              return ''

FUNCTION  coc#float#get_float_win_list()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:606
Called 7 times
Total time:   0.000930
 Self time:   0.000930

count  total (s)   self (s)
    7              0.000021   let res = []
    7              0.000048   let all = get(a:, 1, 0)
    7              0.000017   if s:is_vim
                                if s:popup_list_api
                                  return filter(popup_list(), 'popup_getpos(v:val)["visible"]'.(all ? '' : '&& getwinvar(v:val, "float", 0)'))
                                endif
                                return filter(s:popup_list, 's:popup_visible(v:val)')
    7              0.000089   elseif has('nvim') && exists('*nvim_win_get_config')
    7              0.000023     let res = []
   21              0.000092     for i in range(1, winnr('$'))
   14              0.000060       let id = win_getid(i)
   14              0.000139       let config = nvim_win_get_config(id)
   14              0.000086       if empty(config) || empty(config['relative'])
   14              0.000028         continue
                                  endif
                                  " ignore border & button window & others
                                  if !all && !getwinvar(id, 'float', 0)
                                    continue
                                  endif
                                  call add(res, id)
    7              0.000016     endfor
    7              0.000016     return res
                              endif
                              return []

FUNCTION  <SNR>66_cd()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:224
Called 12 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   12              0.000086   if a:dir == getcwd() | return | endif
                              execute g:rooter_cd_cmd fnameescape(a:dir)
                              if !g:rooter_silent_chdir | redraw | echo 'cwd: '.a:dir | endif
                              if exists('#User#RooterChDir')
                                execute 'doautocmd' s:nomodeline 'User RooterChDir'
                              endif

FUNCTION  <SNR>154_Slash()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:123
Called 3 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    3              0.000003     return a:path

FUNCTION  coc#rpc#ready()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/rpc.vim:32
Called 565 times
Total time:   0.005728
 Self time:   0.005728

count  total (s)   self (s)
  565              0.003406   if empty(s:client) || s:client['running'] == 0
                                return 0
  565              0.000370   endif
  565              0.000590   return 1

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim:405
Called 6 times
Total time:   0.001726
 Self time:   0.001726

count  total (s)   self (s)
    6              0.000035   let winid = a:winid == 0 ? win_getid() : a:winid
    6              0.000057   if empty(getwininfo(winid))
                                " not valid
                                return
    6              0.000007   endif
    6              0.000011   if s:clear_match_by_window
    6              0.001316     let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
    7              0.000020     for item in arr
    1              0.000004       call matchdelete(item['id'], winid)
    7              0.000009     endfor
                              else
                                let curr = win_getid()
                                let switch = exists('*nvim_set_current_win') && curr != winid
                                if switch
                                  noa call nvim_set_current_win(a:winid)
                                endif
                                if win_getid() == winid
                                  let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
                                  for item in arr
                                    call matchdelete(item['id'])
                                  endfor
                                endif
                                if switch
                                  noa call nvim_set_current_win(curr)
                                endif
    6              0.000003   endif

FUNCTION  <SNR>177_process_added()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 14 times
Total time:   0.002253
 Self time:   0.002253

count  total (s)   self (s)
   14              0.000017   let offset = 0
  400              0.000385   while offset < a:to_count
  386              0.000475     let line_number = a:to_line + offset
  386              0.000754     call add(a:modifications, [line_number, 'added'])
  386              0.000328     let offset += 1
  400              0.000163   endwhile

FUNCTION  fugitive#CommonDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:335
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000004   if empty(a:dir)
                                return ''
    3              0.000001   endif
    3              0.000006   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
    3              0.000001   endif
    3              0.000005   return s:commondirs[a:dir]

FUNCTION  FugitiveCommonDir()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:174
Called 3 times
Total time:   0.000911
 Self time:   0.000053

count  total (s)   self (s)
    3   0.000131   0.000023   let dir = FugitiveGitDir(a:0 ? a:1 : -1)
    3              0.000003   if empty(dir)
                                return ''
    3              0.000001   endif
    3   0.000770   0.000019   return fugitive#Find('.git/refs/..', dir)

FUNCTION  <SNR>190_strip_ranges()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe/private.vim:54
Called 1 time
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    1              0.000004   let l:cmdline=a:cmdline
                            
                              " All the range tokens may be followed (several times) by '+' or '-' and an
                              " optional number.
    1              0.000001   let l:modifier='\([+-]\d*\)*'
                            
                              " Range tokens as specified in `:h cmdline-ranges`.
    1              0.000016   let l:cmdline=substitute(l:cmdline, '^\d\+' . l:modifier, '', '') " line number
    1              0.000005   let l:cmdline=substitute(l:cmdline, '^\.' . l:modifier, '', '') " current line
    1              0.000004   let l:cmdline=substitute(l:cmdline, '^$' . l:modifier, '', '') " last line in file
    1              0.000004   let l:cmdline=substitute(l:cmdline, '^%' . l:modifier, '', '') " entire file
    1              0.000005   let l:cmdline=substitute(l:cmdline, "^'[a-z]\\c" . l:modifier, '', '') " mark t (or T)
    1              0.000004   let l:cmdline=substitute(l:cmdline, "^'[<>]" . l:modifier, '', '') " visual selection marks
    1              0.000005   let l:cmdline=substitute(l:cmdline, '^/[^/]\+/' . l:modifier, '', '') " /{pattern}/
    1              0.000004   let l:cmdline=substitute(l:cmdline, '^?[^?]\+?' . l:modifier, '', '') " ?{pattern}?
    1              0.000004   let l:cmdline=substitute(l:cmdline, '^\\/' . l:modifier, '', '') " \/ (next match of previous pattern)
    1              0.000003   let l:cmdline=substitute(l:cmdline, '^\\?' . l:modifier, '', '') " \? (last match of previous pattern)
    1              0.000003   let l:cmdline=substitute(l:cmdline, '^\\&' . l:modifier, '', '') " \& (last match of previous substitution)
                            
                              " Separators (see: `:h :,` and `:h :;`).
    1              0.000003   let l:cmdline=substitute(l:cmdline, '^,', '', '') " , (separator)
    1              0.000002   let l:cmdline=substitute(l:cmdline, '^;', '', '') " ; (separator)
                            
    1              0.000002   return l:cmdline

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:73
Called 35 times
Total time:   0.000576
 Self time:   0.000550

count  total (s)   self (s)
   35              0.000445   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   30              0.000033     return a:arg
    5   0.000049   0.000022   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    5              0.000002   else
    5              0.000011     return shellescape(a:arg)
                              endif

FUNCTION  indent_guides#exclude_filetype()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:279
Called 17 times
Total time:   0.000558
 Self time:   0.000558

count  total (s)   self (s)
   34              0.000245   for ft in split(&ft, '\.')
   17              0.000107     if index(g:indent_guides_exclude_filetypes, ft) > -1
                                  return 1
   17              0.000013     end
   34              0.000044   endfor
   17              0.000022   return 0

FUNCTION  lightline#mode()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:213
Called 1925 times
Total time:   0.008762
 Self time:   0.008762

count  total (s)   self (s)
 1925              0.007829   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>154_Tree()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:360
Called 3 times
Total time:   0.000169
 Self time:   0.000018

count  total (s)   self (s)
    3   0.000168   0.000017   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  gitgutter#async#available()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 8 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    8              0.000013   return s:available

FUNCTION  AutoPairsMap()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:445
Called 48 times
Total time:   0.001945
 Self time:   0.001945

count  total (s)   self (s)
                              " | is special key which separate map command from text
   48              0.000095   let key = a:key
   48              0.000067   if key == '|'
                                let key = '<BAR>'
   48              0.000026   end
   48              0.000263   let escaped_key = substitute(key, "'", "''", 'g')
                              " use expr will cause search() doesn't work
   48              0.001365   execute 'inoremap <buffer> <silent> '.key." <C-R>=AutoPairsInsert('".escaped_key."')<CR>"

FUNCTION  <SNR>192_match_word()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:108
Called 355 times
Total time:   0.024709
 Self time:   0.024709

count  total (s)   self (s)
  355              0.001017   if (a:word ==# '\<\>')
   71              0.000073     return
  284              0.000185   endif
  284              0.000590   if g:Illuminate_highlightUnderCursor
  284              0.011015     if hlexists('illuminatedCurWord')
                                  let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
                                  let w:match_curword_id = matchadd('illuminatedCurWord', '\V\(\k\*\%#\k\*\)\&' . a:word, g:Illuminate_highlightPriority)
  284              0.000255     else
  284              0.006342       let w:match_id = matchadd('illuminatedWord', '\V' . a:word, g:Illuminate_highlightPriority)
  284              0.000284     endif
                              else
                                let w:match_id = matchadd('illuminatedWord', '\V\(\k\*\%#\k\*\)\@\!\&' . a:word, g:Illuminate_highlightPriority)
  284              0.000178   endif

FUNCTION  <SNR>76_get_number()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:120
Called 835 times
Total time:   0.014480
 Self time:   0.014480

count  total (s)   self (s)
  835              0.001167   if s:show_number == 1
                                return a:buffer . s:number_separator
  835              0.000986   elseif s:show_number == 2
                                return s:get_from_number_map(a:i + 1). s:number_separator
  835              0.000780   elseif s:show_number == 3
                                return a:buffer . s:ordinal_separator . s:get_from_number_map(a:i + 1) . s:number_separator
  835              0.000728   elseif s:show_number == 4
                                return s:get_from_number_map(a:i + 1) . s:ordinal_separator . a:buffer . s:number_separator
  835              0.000385   endif
                            
  835              0.000676   return ''

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:216
Called 24 times
Total time:   0.000622
 Self time:   0.000622

count  total (s)   self (s)
   24              0.000256   let matches = matchlist(a:line, s:hunk_re)
   24              0.000044   if len(matches) > 0
   24              0.000063     let from_line  = str2nr(matches[1])
   24              0.000068     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   24              0.000046     let to_line    = str2nr(matches[3])
   24              0.000058     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   24              0.000061     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  <SNR>159_skip()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:30
Called 14 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
   14              0.000089     return win_gettype() ==# 'popup' || win_gettype() ==# 'autocmd'

FUNCTION  WebDevIconsGetFileTypeSymbol()
    Defined: ~/.config/nvim/autoload/plugged/vim-devicons/plugin/webdevicons.vim:493
Called 160 times
Total time:   0.038936
 Self time:   0.037224

count  total (s)   self (s)
  160              0.000322   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
  160              0.000117   else
  160              0.000832     let fileNodeExtension = fnamemodify(a:1, ':e')
  160              0.000605     let fileNode = fnamemodify(a:1, ':t')
  160              0.000238     if a:0 > 1
   44              0.000123       let isDirectory = a:2
  116              0.000094     else
  116              0.000200       let isDirectory = 0
  160              0.000108     endif
  160              0.000098   endif
                            
  160              0.000470   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
  160              0.000498     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  160              0.000594     let fileNodeExtension = tolower(fileNodeExtension)
  160              0.000492     let fileNode = tolower(fileNode)
                            
 1600              0.004976     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 1440              0.011190       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
 1440              0.000764       endif
 1600              0.001143     endfor
                            
  160              0.000593     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  160              0.000689       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
   16              0.000069         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
  144              0.001641       elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
   96              0.000396         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
   48              0.000092       elseif isDirectory == 1
   44              0.000152         let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  160              0.000112       endif
  160              0.000100     endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
  160              0.000105   endif
                            
  160   0.003995   0.002283   let artifactFix = s:DevIconsGetArtifactFix()
                            
  160              0.000410   return symbol . artifactFix
                            

FUNCTION  <SNR>82_dir()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:214
Called 22 times
Total time:   0.001689
 Self time:   0.000329

count  total (s)   self (s)
   22   0.001682   0.000322   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  lightline#bufferline#buffers()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:423
Called 215 times
Total time:   0.422517
 Self time:   0.016116

count  total (s)   self (s)
  215   0.028764   0.001959   let l:buffers = s:filtered_buffers()
  215              0.001058   let l:current_index = index(l:buffers, bufnr('%'))
  215              0.000334   if l:current_index == -1
    8   0.003813   0.000086     return [s:get_buffer_names(l:buffers, 0, len(l:buffers))[0], [], []]
  207              0.000098   endif
  207   0.153811   0.002470   let l:before = s:get_buffer_names(l:buffers, 0, l:current_index)
  207   0.111232   0.002683   let l:current = s:get_buffer_names(l:buffers, l:current_index, l:current_index + 1)
  207   0.106893   0.002786   let l:after = s:get_buffer_names(l:buffers, l:current_index + 1, len(l:buffers))
  207              0.000298   if s:right_aligned == 1
                                return s:select_buffers(l:after, l:current, l:before)
  207              0.000109   else
  207   0.014166   0.002293     return s:select_buffers(l:before, l:current, l:after)
                              endif

FUNCTION  188()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/opener.vim:321
Called 3 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    3              0.000027     let self._bufnr = bufnr('')
    3              0.000019     let self._tabnr = tabpagenr()

FUNCTION  coc#util#check_refresh()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:62
Called 4 times
Total time:   0.000272
 Self time:   0.000272

count  total (s)   self (s)
    4              0.000112   if !bufloaded(a:bufnr)
                                return 0
    4              0.000011   endif
    4              0.000035   if getbufvar(a:bufnr, 'coc_diagnostic_disable', 0)
                                return 0
    4              0.000004   endif
    4              0.000028   if get(g: , 'EasyMotion_loaded', 0)
                                return EasyMotion#is_active() != 1
    4              0.000004   endif
    4              0.000009   return 1

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 5 times
Total time:   0.017145
 Self time:   0.000945

count  total (s)   self (s)
    5   0.000105   0.000030   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    5              0.000002   endif
                            
    5   0.000092   0.000026   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    5              0.000002   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    5              0.000005   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    5              0.000013   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    5              0.000011   let s:counter = (s:counter + 1) % 20
    5              0.000011   let buff_file .= '.'.s:counter
                            
    5   0.000256   0.000030   let extension = gitgutter#utility#extension(a:bufnr)
    5              0.000008   if !empty(extension)
    5              0.000010     let buff_file .= '.'.extension
    5              0.000002   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    5   0.000994   0.000149   call s:write_buffer(a:bufnr, buff_file)
                            
    5              0.000007   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    5              0.000015     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    5              0.000011     let from_file .= '.'.s:counter
                            
    5              0.000008     if !empty(extension)
    5              0.000008       let from_file .= '.'.extension
    5              0.000002     endif
                            
                                " Write file from index to temporary file.
    5   0.000493   0.000124     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    5              0.000027     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    5              0.000002   endif
                            
                              " Call git-diff.
    5              0.000014   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    5              0.000004   if s:c_flag
    5              0.000008     let cmd .= ' -c "diff.autorefreshindex=0"'
    5              0.000006     let cmd .= ' -c "diff.noprefix=false"'
    5              0.000006     let cmd .= ' -c "core.safecrlf=false"'
    5              0.000002   endif
    5              0.000019   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    5              0.000011   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    5   0.000141   0.000036     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    5              0.000002   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    5              0.000008   let cmd .= ' || exit 0'
                            
    5              0.000007   let cmd .= ')'
                            
    5   0.000719   0.000033   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    5   0.000042   0.000031   if g:gitgutter_async && gitgutter#async#available()
    5   0.013941   0.000126     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    5              0.000014     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  indent_guides#init_script_vars()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:184
Called 17 times
Total time:   0.003103
 Self time:   0.001802

count  total (s)   self (s)
   17              0.000098   if &l:shiftwidth > 0 && &l:expandtab
   17              0.000050     let s:indent_size = &l:shiftwidth
                              else
                                let s:indent_size = &l:tabstop
   17              0.000011   endif
   17   0.000410   0.000209   let s:guide_size  = indent_guides#calculate_guide_size()
   17   0.001290   0.000191   let s:hi_normal   = indent_guides#capture_highlight('Normal')
                            
                              " remove 'font=<value>' from the s:hi_normal string (only seems to happen on Vim startup in Windows)
   17              0.000243   let s:hi_normal = substitute(s:hi_normal, ' font=[A-Za-z0-9:]\+', "", "")
                            
                              " shortcuts to the global variables - this makes the code easier to read
   17              0.000054   let s:debug             = g:indent_guides_debug
   17              0.000045   let s:indent_levels     = g:indent_guides_indent_levels
   17              0.000044   let s:auto_colors       = g:indent_guides_auto_colors
   17              0.000058   let s:color_hex_pat     = g:indent_guides_color_hex_pattern
   17              0.000052   let s:color_hex_bg_pat  = g:indent_guides_color_hex_guibg_pattern
   17              0.000056   let s:color_name_bg_pat = g:indent_guides_color_name_guibg_pattern
   17              0.000039   let s:start_level       = g:indent_guides_start_level
                            
                              " str2float not available in vim versions <= 7.1
   17              0.000055   if has('float')
   17              0.000126     let s:change_percent = g:indent_guides_color_change_percent / str2float('100.0')
                              else
                                let s:change_percent = g:indent_guides_color_change_percent / 100.0
   17              0.000011   endif
                            
   17              0.000020   if s:debug
                                echo 's:indent_size = '       . s:indent_size
                                echo 's:guide_size = '        . s:guide_size
                                echo 's:hi_normal = '         . s:hi_normal
                                echo 's:indent_levels = '     . s:indent_levels
                                echo 's:auto_colors = '       . s:auto_colors
                                echo 's:change_percent = '    . string(s:change_percent)
                                echo 's:color_hex_pat = '     . s:color_hex_pat
                                echo 's:color_hex_bg_pat = '  . s:color_hex_bg_pat
                                echo 's:color_name_bg_pat = ' . s:color_name_bg_pat
                                echo 's:start_level = '       . s:start_level
   17              0.000009   endif

FUNCTION  <SNR>175_build_command()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:43
Called 8 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    8              0.000015   if has('unix')
    8              0.000014     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  fzf_preview#remote#mr#mru_file_path()
    Defined: ~/.config/nvim/autoload/plugged/fzf-preview.vim/autoload/fzf_preview/remote/mr.vim:8
Called 14 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
   14              0.000047   return g:fzf_preview_cache_directory . '/mru'

FUNCTION  <SNR>84_Tree()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:200
Called 12 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   12              0.000015   let dir = a:path
   12              0.000031   if dir =~# '/\.git$'
    6              0.000015     return len(dir) ==# 5 ? '/' : dir[0:-6]
    6              0.000005   elseif dir ==# ''
    6              0.000003     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  let wt_config = filter(copy(config),'v:val =~# "^\\s*worktree *="')
                                  if len(wt_config) == 1
                                    let worktree = FugitiveVimPath(matchstr(wt_config[0], '= *\zs.*'))
                                  else
                                    call filter(config,'v:val =~# "^\\s*bare *= *false *$"')
                                    if len(config)
                                      let s:worktree_for_dir[dir] = 0
                                    endif
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  nerdtree#has_opt()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:170
Called 1172 times
Total time:   0.009349
 Self time:   0.009349

count  total (s)   self (s)
 1172              0.008909     return has_key(a:options, a:name) && a:options[a:name] ==# 1

FUNCTION  <SNR>16_LoadFTPlugin()
    Defined: /usr/share/nvim/runtime/ftplugin.vim:14
Called 3 times
Total time:   0.030284
 Self time:   0.015765

count  total (s)   self (s)
    3              0.000018     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    3              0.000003     endif
                            
    3              0.000013     let s = expand("<amatch>")
    3              0.000006     if s != ""
    3              0.000033       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    3              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    6              0.000022       for name in split(s, '\.')
    3   0.022571   0.008052         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    3              0.007555         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    6              0.000008       endfor
    3              0.000002     endif

FUNCTION  <SNR>78_dopopd()
    Defined: ~/.config/nvim/autoload/plugged/fzf/plugin/fzf.vim:585
Called 5 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    5              0.000018   if !exists('w:fzf_pushd')
    5              0.000006     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd

FUNCTION  222()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:93
Called 5 times
Total time:   0.001305
 Self time:   0.000243

count  total (s)   self (s)
    5   0.000469   0.000063     call g:NERDTree.MustBeOpen()
    5   0.000828   0.000172     call nerdtree#exec(g:NERDTree.GetWinNum() . 'wincmd w', a:0 >0 ? a:1 : 1)

FUNCTION  223()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:100
Called 115 times
Total time:   0.000467
 Self time:   0.000467

count  total (s)   self (s)
  115              0.000417     return exists('b:NERDTree')

FUNCTION  31()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:453
Called 509 times
Total time:   0.053511
 Self time:   0.022776

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  509   0.002508   0.001743     if a:nerdtree.ui.isIgnoreFilterEnabled()
 1018              0.001340         for i in g:NERDTreeIgnore
  509   0.020604   0.001922             if self._ignorePatternMatches(i)
                                            return 1
  509              0.000249             endif
 1018              0.000671         endfor
                            
  509   0.005026   0.002298         for l:Callback in g:NERDTree.PathFilters()
                                        let l:Callback = type(l:Callback) ==# type(function('tr')) ? l:Callback : function(l:Callback)
                                        if l:Callback({'path': self, 'nerdtree': a:nerdtree})
                                           return 1
                                        endif
  509              0.000368         endfor
  509              0.000241     endif
                            
                                "dont show hidden files unless instructed to
  509   0.011255   0.003308     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   16              0.000015         return 1
  493              0.000210     endif
                            
  493   0.002711   0.002097     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
  493              0.000192     endif
                            
  493              0.000339     return 0

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 50 times
Total time:   0.000767
 Self time:   0.000767

count  total (s)   self (s)
   50              0.000092   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   50              0.000135   let ggvars = getbufvar(buffer, 'gitgutter')
   50              0.000106   if type(ggvars) == type('')
    4              0.000006     unlet ggvars
    4              0.000006     let ggvars = {}
    4              0.000012     call setbufvar(buffer, 'gitgutter', ggvars)
   50              0.000024   endif
   50              0.000146   let ggvars[a:varname] = a:val

FUNCTION  <SNR>76_tabpage_filter()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:146
Called 835 times
Total time:   0.005939
 Self time:   0.005939

count  total (s)   self (s)
  835              0.001864   if s:filter_by_tabpage && tabpagenr('$') > 1
                                return index(tabpagebuflist(tabpagenr()), a:i) != -1
  835              0.000464   endif
  835              0.000683   return 1

FUNCTION  nerdtree#closeTreeOnOpen()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:34
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000030     return g:NERDTreeQuitOnOpen == 1 || g:NERDTreeQuitOnOpen == 3

FUNCTION  <SNR>19_SynSet()
    Defined: /usr/share/nvim/runtime/syntax/synload.vim:33
Called 3 times
Total time:   0.022352
 Self time:   0.005645

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    3              0.000012   syn clear
    3              0.000008   if exists("b:current_syntax")
                                unlet b:current_syntax
    3              0.000002   endif
                            
    3              0.000009   let s = expand("<amatch>")
    3              0.000004   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    3              0.000004   elseif s == "OFF"
                                let s = ""
    3              0.000001   endif
                            
    3              0.000003   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    6              0.000020     for name in split(s, '\.')
    3              0.000006       if !empty(name)
    3   0.019809   0.003102         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    3              0.002417         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    3              0.000002       endif
    6              0.000004     endfor
    3              0.000002   endif

FUNCTION  <SNR>73_notify()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/client.vim:189
Called 565 times
Total time:   0.056428
 Self time:   0.052054

count  total (s)   self (s)
  565   0.010455   0.006082   let channel = coc#client#get_channel(self)
  565              0.001281   if empty(channel)
                                return ''
  565              0.000304   endif
  565              0.000613   try
  565              0.000691     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
  565              0.000466     else
  565              0.019072       call call('rpcnotify', [channel, a:method] + a:args)
  565              0.000638     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
  565              0.000690   endtry

FUNCTION  nerdtree#exec()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:157
Called 21 times
Total time:   0.001305
 Self time:   0.001244

count  total (s)   self (s)
   21              0.000118     let old_ei = &eventignore
   21              0.000060     if a:ignoreAll
   21              0.000223         set eventignore=all
   21              0.000030     endif
   21              0.000033     try
   21              0.000428         exec a:cmd
   21              0.000057     finally
   21   0.000255   0.000194         let &eventignore = old_ei
   21              0.000043     endtry

FUNCTION  <SNR>177_is_modified_and_added()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  doge#buffer#get_doc_standard()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/buffer.vim:37
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000028   return get(g:, 'doge_test_env', 0) ? b:doge_supported_doc_standards[0] : get(b:, 'doge_doc_standard', get(g:, 'doge_doc_standard_' . a:filetype, b:doge_supported_doc_standards[0]))

FUNCTION  <SNR>81_on_bufenter()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/plugin/gitgutter.vim:221
Called 9 times
Total time:   0.011135
 Self time:   0.000445

count  total (s)   self (s)
    9   0.002470   0.000073   call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
    9              0.000053   if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
    9              0.000005   endif
                            
    9              0.000031   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
    9              0.000006   else
    9   0.008414   0.000121     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    9              0.000005   endif

FUNCTION  quick_scope#UnhighlightLine()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:61
Called 64 times
Total time:   0.020915
 Self time:   0.020915

count  total (s)   self (s)
  124              0.019865   for m in filter(getmatches(), printf('v:val.group ==# "%s" || v:val.group ==# "%s"', g:qs_hi_group_primary, g:qs_hi_group_secondary))
   60              0.000366     call matchdelete(m.id)
  124              0.000266   endfor

FUNCTION  <SNR>82_not_git_dir()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:59
Called 14 times
Total time:   0.001421
 Self time:   0.000218

count  total (s)   self (s)
   14   0.001413   0.000210   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  loupe#private#cleanup()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe/private.vim:110
Called 5 times
Total time:   0.000126
 Self time:   0.000072

count  total (s)   self (s)
    5              0.000024   if !exists('v:hlsearch') || !v:hlsearch
    4   0.000091   0.000037     call loupe#private#clear_highlight()
    5              0.000003   endif

FUNCTION  coc#float#close_related()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:789
Called 1 time
Total time:   0.000338
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000012   let timer = getwinvar(a:winid, 'timer', 0)
    1              0.000003   if timer
                                call timer_stop(timer)
    1              0.000002   endif
    1              0.000010   let kind = get(a:, 1, '')
    1   0.000240   0.000045   let winids = filter(coc#float#get_float_win_list(1), 'getwinvar(v:val, "target_winid", 0) == '.a:winid)
    1              0.000006   for id in winids
                                if s:is_vim
                                  " vim doesn't throw
                                  call popup_close(id)
                                elseif nvim_win_is_valid(id)
                                  if empty(kind) || getwinvar(id, 'kind', '') ==# kind
                                    noa call nvim_win_close(id, 1)
                                  endif
                                endif
    1              0.000003   endfor

FUNCTION  <SNR>70_AsyncRequest()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:112
Called 6 times
Total time:   0.002612
 Self time:   0.000781

count  total (s)   self (s)
    6              0.000287   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    6              0.000064   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    6              0.000010   endif
    6   0.002036   0.000205   call coc#rpc#notify(a:name, a:args)
    6              0.000013   return ''

FUNCTION  indent_guides#init_matches()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:176
Called 17 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   17              0.000131   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  <SNR>76_filter_buffer()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:153
Called 1050 times
Total time:   0.017602
 Self time:   0.011664

count  total (s)   self (s)
 1050   0.017259   0.011321   return bufexists(a:i) && buflisted(a:i) && !(getbufvar(a:i, '&filetype') ==# 'qf') && s:tabpage_filter(a:i)

FUNCTION  doge#buffer#register_doc_standard()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/buffer.vim:55
Called 15 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   15              0.000050   let b:doge_patterns[a:doc_standard] = a:patterns

FUNCTION  DimInactiveCallback()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:59
Called 4 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
    4              0.000017     if gettabwinvar(a:tabnr, a:winnr, '&diff')
                                  call s:Debug('Not dimming diff window.')
                                  return 0
    4              0.000003     endif
    4              0.000021     let bt = getbufvar(a:bufnr, '&buftype')
    4              0.000011     let ft = getbufvar(a:bufnr, '&filetype')
    4              0.000049     if (index(g:diminactive_buftype_blacklist, bt) != -1 || index(g:diminactive_filetype_blacklist, ft) != -1) && (index(g:diminactive_buftype_whitelist, bt) == -1     && index(g:diminactive_filetype_whitelist, ft) == -1)
                                  call s:Debug('Not dimming for buftype='.bt.', filetype='.ft.'.')
                                  return 0
    4              0.000002     endif
    4              0.000004     return 1

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 29 times
Total time:   0.000634
 Self time:   0.000305

count  total (s)   self (s)
   29   0.000482   0.000206   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   29   0.000141   0.000088   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  124()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:196
Called 108 times
Total time:   0.027864
 Self time:   0.001542

count  total (s)   self (s)
  108   0.000792   0.000449     if !g:NERDTree.ExistsForBuf()
                                    throw 'NERDTree.NoTreeError: No tree exists for the current buffer'
  108              0.000052     endif
                            
  108   0.026787   0.000808     return self.equals(self.getNerdtree().root)

FUNCTION  nerdtree#renderView()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree.vim:245
Called 4 times
Total time:   0.071467
 Self time:   0.000026

count  total (s)   self (s)
    4   0.071464   0.000024     call b:NERDTree.render()

FUNCTION  floaterm#buffer#getlines()
    Defined: ~/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buffer.vim:36
Called 1 time
Total time:   0.000399
 Self time:   0.000192

count  total (s)   self (s)
    1              0.000005   let lines = []
    1              0.000005   if a:bufnr == -1
    1   0.000376   0.000169     for bufnr in floaterm#buflist#gather()
                                  let lnum = getbufinfo(bufnr)[0]['lnum']
                                  let lines += getbufline(bufnr, max([lnum - a:length, 0]), '$')
    1              0.000001     endfor
                              else
                                let lnum = getbufinfo(a:bufnr)[0]['lnum']
                                let lines += getbufline(a:bufnr, max([lnum - a:length, 0]), '$')
    1              0.000000   endif
    1              0.000001   return lines

FUNCTION  246()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:278
Called 8 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    8              0.000016     return self._showHelp

FUNCTION  <SNR>179_handle_double_hunk()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 5 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    5              0.000035   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    5              0.000003   endif
                            
    5              0.000005   return a:modified_lines

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 8 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    8              0.000049   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 25 times
Total time:   0.000482
 Self time:   0.000235

count  total (s)   self (s)
   25   0.000474   0.000227   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  doge#comment#deactivate_when_done()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/comment.vim:169
Called 7 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    7              0.000023   if exists('b:doge_interactive')
                                let l:pos = getcurpos()[1:2]
                                call cursor(b:doge_interactive['lnum_comment_start_pos'], 1)
                                if search(s:comment_placeholder, 'W', b:doge_interactive['lnum_comment_end_pos']) == v:false
                                  call doge#deactivate()
                                endif
                                call cursor(l:pos)
    7              0.000003   endif

FUNCTION  336()
    Defined: ~/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buflist.vim:178
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000002   let candidates = []
    1              0.000002   let curr = self.head.next
    1              0.000002   while curr != self.head
                                if curr.is_valid()
                                  call add(candidates, curr.bufnr)
                                endif
                                let curr = curr.next
    1              0.000001   endwhile
    1              0.000001   return candidates

FUNCTION  <SNR>59_Leave()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:413
Called 4 times
Total time:   0.001772
 Self time:   0.000998

count  total (s)   self (s)
    4              0.000016   let tabnr = a:0 > 0 ? a:1 : tabpagenr()
    4              0.000012   let winnr = a:0 > 1 ? a:2 : winnr()
    4   0.000103   0.000036   let bufnr = a:0 > 2 ? a:3 : s:bufnr(tabnr, winnr)
                            
    4   0.000097   0.000042   call s:DebugIndent('Leave', {'t': tabnr, 'w': winnr, 'b': bufnr})
                            
    4              0.000011   if get(g:, 'SessionLoad', 0)
                                call s:DelegateForSessionLoad()
                                let s:debug_indent-=1
                                return
    4              0.000002   endif
                            
    4   0.000412   0.000049   if ! s:should_get_dimmed(tabnr, winnr, bufnr)
                                let s:debug_indent-=1
                                return
    4              0.000002   endif
                            
    4              0.000006   if g:diminactive_use_colorcolumn
    4   0.000320   0.000043     call s:store_orig_colorcolumn(tabnr, winnr, bufnr)
                            
    4              0.000016     let wrap = gettabwinvar(tabnr, winnr, '&wrap')
    4              0.000005     if wrap
                                  " HACK: when wrapping lines is enabled, we use the maximum number
                                  " of columns getting highlighted. This might get calculated by
                                  " looking for the longest visible line and using a multiple of
                                  " winwidth().
                                  let l:width = g:diminactive_max_cols
    4              0.000003     else
                                  " let l:width=winwidth(winnr)
                                  " Use window width for number of columns to dim.
                                  " This is too much with vertical splits, but I assume Vim to be smart
                                  " enough, so that won't have a negative impact on performance.
                                  " This has the benefit that window re-arrangement should not cause windows
                                  " to be not fully dimmed anymore.
    4              0.000008       let l:width = &columns
    4              0.000002     endif
                            
                                " Build &colorcolumn setting.
    4              0.000417     let l:range = join(range(1, l:width), ',')
    4   0.000065   0.000052     call s:Debug('Applying colorcolumn')
    4              0.000151     noautocmd call settabwinvar(tabnr, winnr, '&colorcolumn', l:range)
                              else
                                call s:Debug('Leave: colorcolumn: skipped/disabled.')
    4              0.000002   endif
                            
    4              0.000012   if g:diminactive_use_syntax && bufnr != winbufnr('%')
                                call s:set_syntax(bufnr, 0)
    4              0.000002   endif
    4              0.000010   let s:debug_indent-=1

FUNCTION  <SNR>163_setup_path()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter.vim:156
Called 14 times
Total time:   0.006228
 Self time:   0.000177

count  total (s)   self (s)
   14   0.000618   0.000119   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    3   0.005598   0.000045   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  212()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:7
Called 160 times
Total time:   0.004140
 Self time:   0.002650

count  total (s)   self (s)
  160   0.002754   0.001264     let flags = self._flagsForScope(a:scope)
  160              0.000563     if index(flags, a:flag) == -1
  160              0.000582         call add(flags, a:flag)
  160              0.000120     end

FUNCTION  213()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:15
Called 160 times
Total time:   0.001036
 Self time:   0.001036

count  total (s)   self (s)
  160              0.000971     let self._flags[a:scope] = []

FUNCTION  217()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/flag_set.vim:45
Called 211 times
Total time:   0.004040
 Self time:   0.004040

count  total (s)   self (s)
  211              0.000281     let flagstring = ''
  633              0.000893     for i in values(self._flags)
  422              0.000972         let flagstring .= join(i)
  633              0.000346     endfor
                            
  211              0.000367     if len(flagstring) == 0
                                    return ''
  211              0.000086     endif
                            
  211              0.000356     return '[' . flagstring . ']'

FUNCTION  indent_guides#indent_highlight_pattern()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:269
Called 986 times
Total time:   0.010512
 Self time:   0.010512

count  total (s)   self (s)
  986              0.003637   let l:pattern  = '^' . a:indent_pattern . '*\%' . a:column_start . 'v\zs'
  986              0.003494   let l:pattern .= a:indent_pattern . '*\%' . (a:column_start + a:indent_size) . 'v'
  986              0.001515   let l:pattern .= '\ze'
  986              0.001161   return l:pattern

FUNCTION  <SNR>59_bufnr()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:217
Called 27 times
Total time:   0.000468
 Self time:   0.000468

count  total (s)   self (s)
   27              0.000080   let tabnr = a:0 > 0 ? a:1 : tabpagenr()
   27              0.000064   let winnr = a:0 > 1 ? a:2 : winnr()
   27              0.000089   let tabbuflist = tabpagebuflist(tabnr)
   27              0.000081   if type(tabbuflist) == type(0)
                                return 0
   27              0.000017   endif
   27              0.000076   return get(tabbuflist, winnr-1)

FUNCTION  230()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:161
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     return self._type ==# 'tab'

FUNCTION  <SNR>59_should_get_dimmed()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:257
Called 4 times
Total time:   0.000363
 Self time:   0.000221

count  total (s)   self (s)
    4              0.000017   let bufnr = a:0 ? a:1 : s:bufnr(a:tabnr, a:winnr)
                            
    4              0.000006   let cb_r = 1
    4              0.000013   if exists('*DimInactiveCallback')
    4   0.000180   0.000038     let cb_r = DimInactiveCallback(a:tabnr, a:winnr, bufnr)
    4              0.000005     if !cb_r
                                  call s:Debug('should not get dimmed: callback returned '.string(cb_r), {'t':a:tabnr, 'w':a:winnr, 'b':bufnr})
                                  return 0
    4              0.000003     endif
    4              0.000003   endif
                            
    4              0.000014   let w = gettabwinvar(a:tabnr, a:winnr, 'diminactive')
    4              0.000011   if type(w) != type('')
                                call s:Debug('Use w:diminactive: '.w, {'t': a:tabnr, 'w': a:winnr, 'b': bufnr})
                                return w
    4              0.000002   endif
                            
                              " Backwards-compatible for: if !getbufvar(bufnr, 'diminactive', 1)
    4              0.000013   let b = getbufvar(bufnr, 'diminactive')
    4              0.000010   if type(b) != type('')
                                call s:Debug('Use b:diminactive: '.b, {'t': a:tabnr, 'w': a:winnr, 'b': bufnr})
                                return b
    4              0.000002   endif
                            
    4              0.000006   return g:diminactive

FUNCTION  polyglot#detect#H()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/detect.vim:49
Called 1 time
Total time:   0.028707
 Self time:   0.002314

count  total (s)   self (s)
    1              0.000005   if a:0 != 1 && did_filetype()
                                return
    1              0.000001   endif
  121              0.000113   for lnum in range(1, min([line("$"), 200]))
  120              0.000220     let line = getline(lnum)
  120              0.001356     if line =~# '^\s*\(@\(interface\|class\|protocol\|property\|end\|synchronised\|selector\|implementation\)\(\<\|\>\)\|#import\s\+.\+\.h[">]\)'
                                  if exists('g:c_syntax_for_h')
                                    set ft=objc | return
                                  endif
                                  set ft=objcpp | return
  120              0.000042     endif
  121              0.000057   endfor
    1              0.000003   if exists('g:c_syntax_for_h')
                                set ft=c | return
    1              0.000001   endif
    1              0.000002   if exists('g:ch_syntax_for_h')
                                set ft=ch | return
    1              0.000000   endif
    1   0.026406   0.000013   set ft=cpp | return

FUNCTION  234()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:187
Called 509 times
Total time:   0.002728
 Self time:   0.002728

count  total (s)   self (s)
  509              0.001217     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
  509              0.000212     endif
  509              0.000580     return s:NERDTree._PathFilters

FUNCTION  doge#helpers#deepextend()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/helpers.vim:124
Called 57 times
Total time:   0.004699
 Self time:   0.004699

count  total (s)   self (s)
   57              0.000272   let l:merge_lists = type(a:000[-1]) is v:t_bool && a:000[-1] == v:true
                            
                              " Thanks to: https://vi.stackexchange.com/a/20843
   57              0.000358   let l:args = filter(copy(a:000), 'type(v:val) == v:t_dict')
   57              0.000203   let l:new = deepcopy(a:1)
  171              0.000175   for l:arg in l:args
  114              0.000250     let l:index = index(l:args, l:arg)
  114              0.000106     if l:index == 0
   57              0.000049       continue
   57              0.000024     endif
  117              0.000244     for [l:k, l:v] in items(l:arg)
   60              0.000200       if type(l:v) is v:t_dict && type(get(l:new, l:k)) is v:t_dict
                                    let l:new[l:k] = doge#helpers#deepextend(l:new[l:k], l:v, l:merge_lists)
   60              0.000269       elseif type(l:v) is v:t_list && type(get(l:new, l:k)) is v:t_list && l:merge_lists == v:true
                                    let l:new[l:k] = uniq(sort(extend(copy(get(l:new, l:k)), l:v)))
   60              0.000044       else
   60              0.000119         let l:new[l:k] = l:v
   60              0.000025       endif
  117              0.000058     endfor
  114              0.000075   endfor
   57              0.000067   return l:new

FUNCTION  228()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:140
Called 17 times
Total time:   0.001012
 Self time:   0.001012

count  total (s)   self (s)
   17              0.000120     if exists('t:NERDTreeBufName')
   17              0.000861         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
                                for w in range(1,winnr('$'))
                                    if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
                                    endif
                                endfor
                            
                                return -1

FUNCTION  229()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:156
Called 12 times
Total time:   0.000968
 Self time:   0.000183

count  total (s)   self (s)
   12   0.000955   0.000171     return s:NERDTree.GetWinNum() !=# -1

FUNCTION  <SNR>76_filtered_buffers()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:158
Called 215 times
Total time:   0.026804
 Self time:   0.009202

count  total (s)   self (s)
  215   0.025431   0.007829   let l:buffers = filter(range(1, bufnr('$')), 's:filter_buffer(v:val)')
  215              0.000355   if s:reverse_buffers == 1
                                let l:buffers = reverse(l:buffers)
  215              0.000100   endif
  215              0.000259   return l:buffers

FUNCTION  <SNR>72_variables()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:239
Called 3 times
Total time:   0.000406
 Self time:   0.000406

count  total (s)   self (s)
    3              0.000014   let info = getbufinfo(a:bufnr)
    3              0.000041   let variables = empty(info) ? {} : copy(info[0]['variables'])
   93              0.000063   for key in keys(variables)
   90              0.000118     if key !~# '\v^coc'
   90              0.000091       unlet variables[key]
   90              0.000023     endif
   93              0.000027   endfor
    3              0.000004   return variables

FUNCTION  doge#buffer#get_patterns()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/buffer.vim:46
Called 3 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    3              0.000014   return get(g:, 'doge_test_env', 0) ? {} : get(b:, 'doge_patterns', {})

FUNCTION  <SNR>159_line()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:386
Called 242 times
Total time:   0.645268
 Self time:   0.105021

count  total (s)   self (s)
  242              0.000719   let _ = a:tabline ? '' : '%{lightline#link()}'
  242              0.000723   if s:lightline.palette == {}
                                call lightline#colorscheme()
  242              0.000133   endif
  242              0.001690   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
  242              0.001600   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
  242              0.001606   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
  242              0.000735   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
  242              0.001590   let ls = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
  242   0.497970   0.003418   let [lc, le, li] = s:expand(ls)
  242              0.001843   let rs = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
  242   0.032942   0.003436   let [rc, re, ri] = s:expand(rs)
  904              0.001317   for i in range(len(lc))
  662              0.002535     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '#'
 1580              0.002626     for j in range(len(lc[i]))
  918              0.006802       let x = le[i][j] ? lc[i][j] : has_key(f, lc[i][j]) ? s:func(f[lc[i][j]]) : get(c, lc[i][j], '')
  918              0.008860       let _ .= has_key(t, lc[i][j]) && t[lc[i][j]] ==# 'raw' || get(w, lc[i][j]) || le[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
  918              0.002692       if j < len(lc[i]) - 1 && s.left !=# ''
  256   0.018239   0.003868         let _ .= s:subseparator(lc[i][(j):], s.left, le[i][(j):])
  918              0.000544       endif
 1580              0.000882     endfor
  662              0.003254     let _ .= '%#LightlineLeft_' . mode . '_' . li[i] . '_' . li[i + 1] . '#'
  662              0.005040     let _ .= i < l + len(lc) - len(ls) && li[i] < l || li[i] != li[i + 1] ? p.left : len(lc[i]) ? s.left : ''
  904              0.000649   endfor
  242              0.000705   let _ .= '%#LightlineMiddle_' . mode . '#%='
  525              0.001218   for i in range(len(rc) - 1, 0, -1)
  283              0.001399     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '_' . ri[i + 1] . '#'
  283              0.002309     let _ .= i < r + len(rc) - len(rs) && ri[i] < r || ri[i] != ri[i + 1] ? p.right : len(rc[i]) ? s.right : ''
  283              0.000967     let _ .= '%#LightlineRight_' . mode . '_' . ri[i] . '#'
  594              0.001048     for j in range(len(rc[i]))
  311              0.002670       let x = re[i][j] ? rc[i][j] : has_key(f, rc[i][j]) ? s:func(f[rc[i][j]]) : get(c, rc[i][j], '')
  311              0.002895       let _ .= has_key(t, rc[i][j]) && t[rc[i][j]] ==# 'raw' || get(w, rc[i][j]) || re[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
  311              0.000902       if j < len(rc[i]) - 1 && s.right !=# ''
   28   0.002296   0.000477         let _ .= s:subseparator(rc[i][(j):], s.right, re[i][(j):])
  311              0.000187       endif
  594              0.000444     endfor
  525              0.000373   endfor
  242              0.000402   return _

FUNCTION  coc#highlight#update_highlights()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/highlight.vim:76
Called 3 times
Total time:   0.000407
 Self time:   0.000161

count  total (s)   self (s)
    3              0.000029   if !bufloaded(a:bufnr)
                                return
    3              0.000005   endif
    3              0.000025   let start = get(a:, 1, 0)
    3              0.000010   let end = get(a:, 2, -1)
    3              0.000011   if empty(a:highlights)
    3   0.000308   0.000061     call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
    3              0.000003     return
                              endif
                              let total = len(a:highlights)
                              " index list that exists with current highlights
                              let exists = []
                              let ns = coc#highlight#create_namespace(a:key)
                              let currIndex = 0
                              if has('nvim-0.5.0') || exists('*prop_list')
                                let current = coc#highlight#get(a:bufnr, a:key, start, end)
                                for lnum in sort(map(keys(current), 'str2nr(v:val)'), {a, b -> a - b})
                                  let items = current[lnum]
                                  let indexes = []
                                  let nextIndex = currIndex
                                  if currIndex != total
                                    for item in items
                                      for i in range(currIndex, total - 1)
                                        let hi = a:highlights[i]
                                        if hi['lnum'] > item['lnum']
                                          let nextIndex = i
                                          break
                                        endif
                                        if coc#helper#obj_equal(item, hi)
                                          call add(indexes, i)
                                          let nextIndex = max([nextIndex, i + 1])
                                        endif
                                      endfor
                                    endfor
                                  endif
                                  let currIndex = nextIndex
                                  " all highlights of current line exists, not clear.
                                  if len(indexes) == len(items)
                                    let exists = exists + indexes
                                  else
                                    if has('nvim')
                                      call nvim_buf_clear_namespace(a:bufnr, ns, lnum, lnum + 1)
                                    else
                                      call coc#api#call('buf_clear_namespace', [a:bufnr, ns, lnum, lnum + 1])
                                    endif
                                  endif
                                endfor
                              else
                                call coc#highlight#clear_highlight(a:bufnr, a:key, start, end)
                              endif
                              for i in range(0, total - 1)
                                if index(exists, i) == -1
                                  let hi = a:highlights[i]
                                  call coc#highlight#add_highlight(a:bufnr, ns, hi['hlGroup'], hi['lnum'], hi['colStart'], hi['colEnd'])
                                endif
                              endfor

FUNCTION  coc#util#get_bufoptions()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/util.vim:204
Called 3 times
Total time:   0.000742
 Self time:   0.000336

count  total (s)   self (s)
    3              0.000016   if !bufloaded(a:bufnr) | return v:null | endif
    3              0.000007   let bufname = bufname(a:bufnr)
    3              0.000008   let buftype = getbufvar(a:bufnr, '&buftype')
    3              0.000003   let previewwindow = 0
    3              0.000005   let winid = bufwinid(a:bufnr)
    3              0.000003   if winid != -1
    3              0.000008     let previewwindow = getwinvar(winid, '&previewwindow', 0)
    3              0.000001   endif
    3              0.000002   let size = -1
    3              0.000020   if bufnr('%') == a:bufnr
    3              0.000011     let size = line2byte(line("$") + 1)
                              elseif !empty(bufname)
                                let size = getfsize(bufname)
    3              0.000001   endif
    3              0.000003   let lines = []
    3              0.000012   if getbufvar(a:bufnr, 'coc_enabled', 1) && (buftype == '' || buftype == 'acwrite') && size < a:maxFileSize
    3              0.000094     let lines = getbufline(a:bufnr, 1, '$')
    3              0.000001   endif
    3   0.000532   0.000126   return { 'bufname': bufname, 'size': size, 'buftype': buftype, 'winid': winid, 'previewwindow': previewwindow == 0 ? v:false : v:true, 'variables': s:variables(a:bufnr), 'fullpath': empty(bufname) ? '' : fnamemodify(bufname, ':p'), 'eol': getbufvar(a:bufnr, '&eol'), 'filetype': getbufvar(a:bufnr, '&filetype'), 'iskeyword': getbufvar(a:bufnr, '&iskeyword'), 'changedtick': getbufvar(a:bufnr, 'changedtick'), 'lines': lines,}

FUNCTION  doge#buffer#get_supported_doc_standards()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge/buffer.vim:19
Called 3 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
                              " We sort them so that we can use uniq() on it.
    3              0.000037   let l:docs = uniq(sort(extend(copy(get(b:, 'doge_supported_doc_standards', [])), a:defaults)))
                            
                              " After sorted it, we will remove the defaults and prepend the defaults so
                              " that we can reset the order as we defined it in the ftplugin/{ft}.vim.
   18              0.000020   for l:default in a:defaults
   15              0.000043     call remove(l:docs, index(l:docs, l:default))
   18              0.000011   endfor
                            
                              " Prepend the defaults to the filtered docs list.
    3              0.000008   return extend(a:defaults, l:docs)

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 3 times
Total time:   0.000132
 Self time:   0.000045

count  total (s)   self (s)
    3   0.000067   0.000016   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000005   let summary[2] += a:count
    3   0.000057   0.000021   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>158_add_to_highlight_patterns()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:207
Called 782 times
Total time:   0.014930
 Self time:   0.014930

count  total (s)   self (s)
  782              0.002750   let [patt_p, patt_s] = a:patterns
  782              0.001972   let [hi_p, hi_s] = a:highlights
                            
                              " If there is a primary highlight for the last word, add it to the primary
                              " highlight pattern.
  782              0.001104   if hi_p > 0
  107              0.000610     let patt_p = printf('%s|%%%sc', patt_p, hi_p)
  675              0.000883   elseif hi_s > 0
   15              0.000050     let patt_s = printf('%s|%%%sc', patt_s, hi_s)
  782              0.000528   endif
                            
  782              0.001919   return [patt_p, patt_s]

FUNCTION  <SNR>175_on_stderr_nvim()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:66
Called 8 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    8              0.000036   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    8              0.000005   endif

FUNCTION  231()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:166
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000015     return self._type ==# 'window'

FUNCTION  232()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:171
Called 5 times
Total time:   0.000406
 Self time:   0.000086

count  total (s)   self (s)
    5   0.000374   0.000054     if !s:NERDTree.IsOpen()
                                    throw 'NERDTree.TreeNotOpen'
    5              0.000007     endif

FUNCTION  237()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/nerdtree.vim:205
Called 8 times
Total time:   0.129810
 Self time:   0.000066

count  total (s)   self (s)
    8   0.129806   0.000062     call self.ui.render()

FUNCTION  239()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:25
Called 8 times
Total time:   0.001432
 Self time:   0.001384

count  total (s)   self (s)
    8   0.000075   0.000056     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 3 ? 'single' : 'double') ."-click,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= '" '. g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= '" '. g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= '" '. (g:NERDTreeMouseMode ==# 1 ? 'double' : 'single') ."-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= '" '. g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= '" '. g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= '" '. g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= '" '. g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": preview file\n"
                                    let help .= '" '. g:NERDTreeMapPreview .": find dir in tree\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= '" '. g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= '" '. g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= '" '. g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= '" '. g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= '" '. g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                                    let help .= '" '. g:NERDTreeMapCustomOpen .": custom open\n"
                                    let help .= '" '. g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= '" '. g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= '" '. g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= '" '. g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= '" '. g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= '" '. g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= '" '. g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= '" '. g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= '" '. g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= '" '. g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= '" '. g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= '" '. g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= '" '. g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= '" '. g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= '" '. g:NERDTreeMapToggleHidden .': hidden files (' . (self.getShowHidden() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFilters .': file filters (' . (self.isIgnoreFilterEnabled() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleFiles .': files (' . (self.getShowFiles() ? 'on' : 'off') . ")\n"
                                    let help .= '" '. g:NERDTreeMapToggleBookmarks .': bookmarks (' . (self.getShowBookmarks() ? 'on' : 'off') . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= '" '. i.key .': '. i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= '" '. g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= '" '. g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    let help .= "\" :ReadBookmarks\n"
                                    let help .= "\" :WriteBookmarks\n"
                                    let help .= "\" :EditBookmarks\n"
                                    silent! put =help
    8   0.000088   0.000060     elseif !self.isMinimal()
    8              0.000035         let help ='" Press '. g:NERDTreeMapHelp ." for help\n"
    8              0.000093         silent! put =help
    8              0.000006     endif

FUNCTION  ProjectionistDetect()
    Defined: ~/.config/nvim/autoload/plugged/vim-projectionist/plugin/projectionist.vim:71
Called 3 times
Total time:   0.003627
 Self time:   0.000972

count  total (s)   self (s)
    3              0.000009   let b:projectionist = {}
    3              0.000004   unlet! b:projectionist_file
    3              0.000020   if a:path =~# '^\a[[:alnum:].+-]\+:'
                                let file = substitute(a:path, '[\/]$', '', '')
    3              0.000002   else
    3              0.000088     let file = simplify(fnamemodify(resolve(a:path), ':p:s?[\/]$??'))
    3              0.000002   endif
                            
    3              0.000004   let root = file
    3              0.000015   let ns = matchstr(file, '^\a\a\+\ze:')
    3              0.000008   if len(ns) && get(g:, 'projectionist_ignore_' . ns)
                                return
    3              0.000001   endif
    3   0.000049   0.000023   call s:load(ns)
    3              0.000003   let previous = ""
   35              0.000044   while root !=# previous && root !=# '.'
   32   0.000501   0.000149     if s:nscall(ns, 'filereadable', root . '/.projections.json')
                                  try
                                    let value = projectionist#json_parse(projectionist#readfile(root . '/.projections.json'))
                                    call projectionist#append(root, value)
                                  catch /^invalid JSON:/
                                  endtry
   32              0.000009     endif
   32              0.000055     for [key, value] in items(g:projectionist_heuristics)
                                  for test in split(key, '|')
                                    if s:has(ns, root, test)
                                      call projectionist#append(root, value)
                                      break
                                    endif
                                  endfor
   32              0.000010     endfor
   32              0.000027     let previous = root
   32              0.000053     let root = fnamemodify(root, ':h')
   35              0.000015   endwhile
                            
    3              0.000018   if exists('#User#ProjectionistDetect')
    3              0.000007     if v:version >= 704 || (v:version == 703 && has('patch442'))
    3              0.000002       try
    3              0.000012         let g:projectionist_file = file
    3   0.002295   0.000018         doautocmd <nomodeline> User ProjectionistDetect
    3              0.000003       finally
    3              0.000008         unlet! g:projectionist_file
    3              0.000002       endtry
                                else
                                  let modelines = &modelines
                                  try
                                    set modelines=0
                                    let g:projectionist_file = file
                                    doautocmd User ProjectionistDetect
                                  finally
                                    let &modelines = modelines
                                    unlet! g:projectionist_file
                                  endtry
    3              0.000001     endif
    3              0.000001   endif
                            
    3              0.000005   if !empty(b:projectionist)
                                let b:projectionist_file = file
                                call projectionist#activate()
    3              0.000001   endif

FUNCTION  fugitive#Find()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:1089
Called 3 times
Total time:   0.000752
 Self time:   0.000510

count  total (s)   self (s)
    3              0.000005   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
    3              0.000007   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
    3              0.000001   endif
    3   0.000019   0.000015   let rev = s:Slash(a:object)
    3              0.000044   if rev =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
    3              0.000010   elseif rev =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
    3              0.000001   endif
    3              0.000007   let dir = a:0 ? a:1 : s:Dir()
    3              0.000003   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs\%(\.\.\=$\|\.\.\=/.*\|/.*\|\w:/.*\)')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return ''
                                endif
    3              0.000001   endif
    3   0.000184   0.000015   let tree = s:Tree(dir)
    3              0.000006   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
    3              0.000002   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
    3              0.000007   elseif rev =~# '^\.git/'
    3              0.000006     let f = strpart(rev, 5)
    3              0.000004     let fdir = dir . '/'
    3   0.000068   0.000014     let cdir = fugitive#CommonDir(dir) . '/'
    3              0.000010     if f =~# '^\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[2:-1] : fdir . f)
    3              0.000007     elseif f =~# '^\.\.\%(/\|$\)'
                                  let f = base . f[2:-1]
    3              0.000015     elseif cdir !=# fdir && ( f =~# '^\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(fdir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
    3              0.000001     else
    3              0.000023       let f = simplify(fdir . f)
    3              0.000001     endif
                              elseif rev ==# ':/'
                                let f = tree
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                let f = FugitiveFind('.git/index', dir)
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(f)-6], s:cpath(f[0 : -6])) && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) ? "@" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$\|^$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                    if empty(commit) && len(file)
                                      let commit = repeat('0', 40)
                                    endif
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
    3              0.000001   endif
    3   0.000028   0.000013   return FugitiveVimPath(f)

FUNCTION  polyglot#init#is_disabled()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/init.vim:23
Called 12 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
   12              0.000023   if !g:polyglot_initialized
   12              0.000029     if a:path[0:7] == "autoload"
                                  let g:polyglot_initialized = 1
                            
                                  for p in globpath(&rtp, a:path, 0, 1)
                                    if p != a:caller
                                      exe "source " . p
                                    endif
                                  endfor
   12              0.000006     endif
   12              0.000005   endif
                            
   12              0.000038   return has_key(g:polyglot_is_disabled, a:name)

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:173
Called 5 times
Total time:   0.013683
 Self time:   0.000727

count  total (s)   self (s)
    5   0.000215   0.000043   call gitgutter#debug#log(a:diff)
                            
    5              0.000013   if !bufexists(a:bufnr)
                                return
    5              0.000002   endif
                            
    5   0.001504   0.000081   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    5   0.005920   0.000076   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    5              0.000012   let signs_count = len(modified_lines)
    5              0.000014   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    5              0.000002   else
    5              0.000015     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    5   0.005606   0.000227       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    5              0.000005     endif
    5              0.000002   endif
                            
    5   0.000234   0.000095   call s:save_last_seen_change(a:bufnr)
    5              0.000050   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    5              0.000002   endif

FUNCTION  <SNR>66_has()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:172
Called 52 times
Total time:   0.000505
 Self time:   0.000505

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
   52              0.000453   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  fzf_preview#remote#mr#append()
    Defined: ~/.config/nvim/autoload/plugged/fzf-preview.vim/autoload/fzf_preview/remote/mr.vim:1
Called 14 times
Total time:   0.038374
 Self time:   0.004953

count  total (s)   self (s)
   14   0.002831   0.000176   let files = s:get_files_with_create_directory(a:cache_path)
                            
   14              0.000064   call insert(files, a:path)
   14   0.035454   0.004687   call writefile(fzf_preview#remote#util#uniq(files)[:g:fzf_preview_mru_limit - 1], a:cache_path)

FUNCTION  324()
    Defined: ~/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buflist.vim:20
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000005   let node = deepcopy(self)
    1              0.000002   let node.bufnr = a:bufnr
    1              0.000002   return node

FUNCTION  gitgutter#setup_maps()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter.vim:107
Called 9 times
Total time:   0.002397
 Self time:   0.002175

count  total (s)   self (s)
    9              0.000027   if !g:gitgutter_map_keys
                                return
    9              0.000007   endif
                            
                              " Note hasmapto() and maparg() operate on the current buffer.
                            
    9              0.000034   let bufnr = bufnr('')
                            
    9   0.000280   0.000134   if gitgutter#utility#getbufvar(bufnr, 'mapped', 0)
    5              0.000005     return
    4              0.000002   endif
                            
    4              0.000239   if !hasmapto('<Plug>(GitGutterPrevHunk)') && maparg('[c', 'n') ==# ''
                                nmap <buffer> [c <Plug>(GitGutterPrevHunk)
    4              0.000002   endif
    4              0.000136   if !hasmapto('<Plug>(GitGutterNextHunk)') && maparg(']c', 'n') ==# ''
                                nmap <buffer> ]c <Plug>(GitGutterNextHunk)
    4              0.000002   endif
                            
    4              0.000167   if !hasmapto('<Plug>(GitGutterStageHunk)', 'v') && maparg('<Leader>hs', 'x') ==# ''
    4              0.000075     xmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    4              0.000002   endif
    4              0.000148   if !hasmapto('<Plug>(GitGutterStageHunk)', 'n') && maparg('<Leader>hs', 'n') ==# ''
    4              0.000070     nmap <buffer> <Leader>hs <Plug>(GitGutterStageHunk)
    4              0.000002   endif
    4              0.000140   if !hasmapto('<Plug>(GitGutterUndoHunk)') && maparg('<Leader>hu', 'n') ==# ''
    4              0.000064     nmap <buffer> <Leader>hu <Plug>(GitGutterUndoHunk)
    4              0.000002   endif
    4              0.000130   if !hasmapto('<Plug>(GitGutterPreviewHunk)') && maparg('<Leader>hp', 'n') ==# ''
    4              0.000061     nmap <buffer> <Leader>hp <Plug>(GitGutterPreviewHunk)
    4              0.000002   endif
                            
    4              0.000110   if !hasmapto('<Plug>(GitGutterTextObjectInnerPending)') && maparg('ic', 'o') ==# ''
                                omap <buffer> ic <Plug>(GitGutterTextObjectInnerPending)
    4              0.000002   endif
    4              0.000120   if !hasmapto('<Plug>(GitGutterTextObjectOuterPending)') && maparg('ac', 'o') ==# ''
    4              0.000067     omap <buffer> ac <Plug>(GitGutterTextObjectOuterPending)
    4              0.000002   endif
    4              0.000102   if !hasmapto('<Plug>(GitGutterTextObjectInnerVisual)') && maparg('ic', 'x') ==# ''
                                xmap <buffer> ic <Plug>(GitGutterTextObjectInnerVisual)
    4              0.000002   endif
    4              0.000118   if !hasmapto('<Plug>(GitGutterTextObjectOuterVisual)') && maparg('ac', 'x') ==# ''
    4              0.000065     xmap <buffer> ac <Plug>(GitGutterTextObjectOuterVisual)
    4              0.000002   endif
                            
    4   0.000124   0.000048   call gitgutter#utility#setbufvar(bufnr, 'mapped', 1)

FUNCTION  quick_scope#HighlightLine()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:15
Called 48 times
Total time:   0.203170
 Self time:   0.006805

count  total (s)   self (s)
   48              0.001263   if g:qs_enable && (!exists('b:qs_local_disable') || !b:qs_local_disable) && index(get(g:, 'qs_buftype_blacklist', []), &buftype) && index(get(g:, 'qs_filetype_blacklist', []), &filetype) < 0
   48              0.000371     let line = getline(line('.'))
   48              0.000190     let len = strlen(line)
   48              0.000172     let pos = col('.')
                            
   48              0.000258     if !empty(line) && len <= g:qs_max_chars
                                  " Highlight after the cursor.
   46              0.000099       if a:direction != 0
   46   0.113385   0.001124         let [patt_p, patt_s] = s:get_highlight_patterns(line, pos, len, a:targets)
   46   0.003429   0.000861         call s:apply_highlight_patterns([patt_p, patt_s])
   46              0.000037       endif
                            
                                  " Highlight before the cursor.
   46              0.000104       if a:direction != 1
   46   0.080785   0.000964         let [patt_p, patt_s] = s:get_highlight_patterns(line, pos, -1, a:targets)
   46   0.002508   0.000793         call s:apply_highlight_patterns([patt_p, patt_s])
   46              0.000037       endif
   48              0.000033     endif
   48              0.000030   endif

FUNCTION  242()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:211
Called 4 times
Total time:   0.003162
 Self time:   0.001004

count  total (s)   self (s)
                            
    4   0.000809   0.000016     if a:node.isRoot()
                                    return self.getRootLineNum()
    4              0.000001     endif
                            
    4   0.000297   0.000072     let l:pathComponents = [substitute(self.nerdtree.root.path.str({'format': 'UI'}), '/\s*$', '', '')]
    4              0.000007     let l:currentPathComponent = 1
                            
    4   0.000249   0.000029     let l:fullPath = a:node.path.str({'format': 'UI'})
                            
   24   0.000172   0.000053     for l:lineNumber in range(self.getRootLineNum() + 1, line('$'))
   24              0.000048         let l:currentLine = getline(l:lineNumber)
   24   0.000650   0.000114         let l:indentLevel = self._indentLevelFor(l:currentLine)
                            
   24              0.000035         if l:indentLevel !=# l:currentPathComponent
                                        continue
   24              0.000009         endif
                            
   24   0.000366   0.000101         let l:currentLine = self._stripMarkup(l:currentLine)
   24              0.000084         let l:currentPath =  join(l:pathComponents, '/') . '/' . l:currentLine
                            
                                    " Directories: If the current path 'starts with' the full path, then
                                    " either the paths are equal or the line is a cascade containing the
                                    " full path.
   24              0.000078         if l:fullPath[-1:] ==# '/' && stridx(l:currentPath, l:fullPath) ==# 0
    4              0.000004             return l:lineNumber
   20              0.000008         endif
                            
                                    " Files: The paths must exactly match.
   20              0.000026         if l:fullPath ==# l:currentPath
                                        return l:lineNumber
   20              0.000006         endif
                            
                                    " Otherwise: If the full path starts with the current path and the
                                    " current path is a directory, we add a new path component.
   20              0.000054         if stridx(l:fullPath, l:currentPath) ==# 0 && l:currentPath[-1:] ==# '/'
    4              0.000017             let l:currentLine = substitute(l:currentLine, '/\s*$', '', '')
    4              0.000010             call add(l:pathComponents, l:currentLine)
    4              0.000007             let l:currentPathComponent += 1
   20              0.000007         endif
   20              0.000012     endfor
                            
                                return -1

FUNCTION  243()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:259
Called 11 times
Total time:   0.000935
 Self time:   0.000935

count  total (s)   self (s)
   11              0.000043     let rootLine = 1
   44              0.000598     while rootLine <= line('$') && getline(rootLine) !~# '^\(/\|<\)'
   33              0.000121         let rootLine = rootLine + 1
   44              0.000075     endwhile
   11              0.000030     return rootLine

FUNCTION  244()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:268
Called 8 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    8              0.000012     return self._showBookmarks

FUNCTION  245()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:273
Called 493 times
Total time:   0.000615
 Self time:   0.000615

count  total (s)   self (s)
  493              0.000512     return self._showFiles

FUNCTION  247()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:283
Called 509 times
Total time:   0.000703
 Self time:   0.000703

count  total (s)   self (s)
  509              0.000593     return self._showHidden

FUNCTION  248()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:288
Called 72 times
Total time:   0.004044
 Self time:   0.003857

count  total (s)   self (s)
                                " Replace multi-character DirArrows with a single space so the
                                " indentation calculation doesn't get messed up.
   72              0.000234     if g:NERDTreeDirArrowExpandable ==# ''
                                    let l:line = '  '.a:line
   72              0.000091     else
   72              0.001480         let l:line = substitute(substitute(a:line, '\V'.g:NERDTreeDirArrowExpandable, ' ', ''), '\V'.g:NERDTreeDirArrowCollapsible, ' ', '')
   72              0.000091     endif
   72              0.000819     let leadChars = match(l:line, '\M\[^ ]')
   72   0.000932   0.000746     return leadChars / s:UI.IndentWid()

FUNCTION  249()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:301
Called 72 times
Total time:   0.000187
 Self time:   0.000187

count  total (s)   self (s)
   72              0.000143     return 2

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 15 times
Total time:   0.000757
 Self time:   0.000259

count  total (s)   self (s)
   15   0.000401   0.000100   let summary = gitgutter#hunk#summary(a:bufnr)
   15              0.000031   let summary[0] += a:count
   15   0.000315   0.000119   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>66_activate()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:87
Called 12 times
Total time:   0.001763
 Self time:   0.001165

count  total (s)   self (s)
                              " Directory browser plugins (e.g. vim-dirvish, NERDTree) tend to
                              " set a nofile buftype when you open a directory.
   12              0.000085   if &buftype != '' && &buftype != 'nofile' | return 0 | endif
                            
   12              0.000094   let patterns = split(g:rooter_targets, ',')
   12              0.000269   let fn = expand('%:p', 1)
                            
   12   0.000784   0.000186   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
                            
                              " directory
   12              0.000052   if empty(fn) || fn[-1:] == '/'
    4              0.000012     return index(patterns, '/') != -1
    8              0.000006   endif
                            
                              " file
    8              0.000107   if !filereadable(fn) | return 0 | endif
    8              0.000035   if !exists('*glob2regpat') | return 1 | endif
                            
    8              0.000084   for p in filter(copy(patterns), 'v:val != "/"')
    8              0.000128     if fn =~ glob2regpat(p)
    8              0.000010       return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  136()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_file_node.vim:319
Called 219 times
Total time:   0.344287
 Self time:   0.288836

count  total (s)   self (s)
  219              0.000303     let output = ''
  219              0.000251     if a:drawText ==# 1
                            
  211              0.000513         let treeParts = repeat('  ', a:depth - 1)
  211              0.000796         let treeParts .= (self.path.isDirectory || g:NERDTreeDirArrowExpandable ==# '' ? '' : '  ')
                            
  211   0.060558   0.001166         let line = treeParts . self.displayString()
  211              0.000467         let output = output . line . "\n"
  219              0.000098     endif
                            
                                " if the node is an open dir, draw its children
  219              0.000398     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   30   0.027059   0.000178         let childNodesToDraw = self.getVisibleChildren()
                            
   30   0.027630   0.000172         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
   30              0.000061         elseif len(childNodesToDraw) > 0
  241              0.000223             for i in childNodesToDraw
  211              0.001161                 let output = output . i._renderToString(a:depth + 1, 1)
  241              0.000137             endfor
   30              0.000013         endif
  219              0.000081     endif
                            
  219              0.000224     return output

FUNCTION  250()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:306
Called 509 times
Total time:   0.000764
 Self time:   0.000764

count  total (s)   self (s)
  509              0.000648     return self._ignoreEnabled ==# 1

FUNCTION  257()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:387
Called 80 times
Total time:   0.002235
 Self time:   0.002235

count  total (s)   self (s)
   80              0.001405     let l:line = substitute(a:line, '^.\{-}' . g:NERDTreeNodeDelimiter, '', '')
   80              0.000763     return substitute(l:line, g:NERDTreeNodeDelimiter.'.*$', '', '')

FUNCTION  258()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:393
Called 8 times
Total time:   0.129744
 Self time:   0.001837

count  total (s)   self (s)
    8   0.000147   0.000108     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    8              0.000027     let curLine = line('.')
    8              0.000021     let curCol = col('.')
    8              0.000016     let topLine = line('w0')
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    8              0.000302     silent 1,$delete _
                            
    8   0.001494   0.000063     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    8   0.000058   0.000043     if !self.isMinimal()
    8              0.000054         call setline(line('.')+1, '')
    8              0.000036         call cursor(line('.')+1, col('.'))
    8              0.000005     endif
                            
    8   0.000053   0.000037     if self.getShowBookmarks()
                                    call self._renderBookmarks()
    8              0.000005     endif
                            
                                " add the 'up a dir' line
    8   0.000041   0.000029     if !self.isMinimal()
    8   0.000090   0.000077         call setline(line('.')+1, s:UI.UpDirLine())
    8              0.000026         call cursor(line('.')+1, col('.'))
    8              0.000004     endif
                            
                                " draw the header line
    8   0.002869   0.000107     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    8              0.000042     call setline(line('.')+1, header)
    8              0.000025     call cursor(line('.')+1, col('.'))
                            
                                " draw the tree
    8   0.123807   0.000226     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    8              0.000064     silent 1,1delete _
                            
                                " restore the view
    8              0.000027     let old_scrolloff=&scrolloff
    8   0.000073   0.000049     let &scrolloff=0
    8              0.000026     call cursor(topLine, 1)
    8              0.000221     normal! zt
    8              0.000019     call cursor(curLine, curCol)
    8   0.000039   0.000030     let &scrolloff = old_scrolloff
                            
    8   0.000049   0.000044     setlocal readonly nomodifiable

FUNCTION  <SNR>175_on_stdout_nvim()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/async.vim:56
Called 16 times
Total time:   0.000289
 Self time:   0.000289

count  total (s)   self (s)
   16              0.000086   if empty(self.stdoutbuffer)
    8              0.000029     let self.stdoutbuffer = a:data
    8              0.000005   else
    8              0.000079     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   16              0.000008   endif

FUNCTION  lightline#link()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:218
Called 1951 times
Total time:   0.049785
 Self time:   0.045494

count  total (s)   self (s)
 1951              0.021438   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
 1951              0.004393   if s:mode ==# mode
 1937              0.002814     return ''
   14              0.000022   endif
   14              0.000037   let s:mode = mode
   14              0.000059   if !has_key(s:highlight, mode)
    2   0.004332   0.000040     call lightline#highlight(mode)
   14              0.000010   endif
   14              0.000350   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   42              0.000251   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
  154              0.000487     for [i, t] in map(range(0, l), '[v:val, 0]') + types
  126              0.000199       if i != l
   98              0.001151         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
  126              0.000089       endif
  700              0.002087       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  574              0.001553         if i + 1 == j || t || s && i != l
  266              0.003159           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  574              0.000493         endif
  700              0.000513       endfor
  154              0.000119     endfor
   42              0.000041   endfor
   14              0.000121   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
   14              0.000029   return ''

FUNCTION  <SNR>59_Enter()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:297
Called 9 times
Total time:   0.003611
 Self time:   0.000758

count  total (s)   self (s)
    9              0.000050   let tabnr = a:0 > 0 ? a:1 : tabpagenr()
    9              0.000027   let winnr = a:0 > 1 ? a:2 : winnr()
    9   0.000255   0.000087   let bufnr = a:0 > 2 ? a:3 : s:bufnr(tabnr, winnr)
                            
    9   0.000255   0.000113   call s:DebugIndent('Enter', {'t': tabnr, 'w': winnr, 'b': bufnr})
                            
    9              0.000024   if get(g:, 'SessionLoad', 0)
                                call s:DelegateForSessionLoad()
                                let s:debug_indent-=1
                                return
    9              0.000005   endif
                            
                              " Handle syntax on all visible buffers in the current tab.
                              " NOTE: tabpagebuflist might have duplicate buffers.
                              "       (using uniq would re-order the index (which is the window number))
    9              0.000013   if g:diminactive_use_syntax
                                let w = 1
                                let checked = []
                                for b in tabpagebuflist(tabnr)
                                  if index(checked, b) != -1
                                    continue
                                  endif
                                  if b != bufnr && b != winbufnr('%') && s:should_get_dimmed(tabnr, w, b)
                                    call s:set_syntax(b, 0)
                                  endif
                                  let w = w+1
                                  let checked += [b]
                                endfor
    9              0.000006   endif
                              " Always make sure to activate/reset syntax, e.g. after
                              " g:diminactive_use_syntax=0 has been set manually.
    9   0.000703   0.000074   call s:set_syntax(bufnr, 1)
                            
                              " Trigger WinEnter processing for (always) correct buffer in the window.
    9   0.001992   0.000079   call s:EnterWindow(tabnr, winnr)
                            
    9              0.000014   let s:debug_indent-=1

FUNCTION  <SNR>76_get_buffer_names()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:255
Called 629 times
Total time:   0.367724
 Self time:   0.038634

count  total (s)   self (s)
  629              0.001122   let l:names = []
  629              0.000843   let l:lengths = []
  629   0.212996   0.006159   let l:buffer_paths = s:get_buffer_paths(a:buffers)
 1464              0.003715   for l:i in range(a:from, a:to - 1)
  835   0.136065   0.013811     let [l:name, l:len] = s:get_buffer_name(l:i, a:buffers[l:i], l:buffer_paths[l:i])
  835              0.002537     call add(l:names, l:name)
  835              0.001920     call add(l:lengths, l:len + 4)
 1464              0.001286   endfor
  629              0.001393   return [l:names, l:lengths]

FUNCTION  <SNR>154_cpath()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:141
Called 6 times
Total time:   0.000349
 Self time:   0.000216

count  total (s)   self (s)
    6   0.000141   0.000072   if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
    6              0.000007   else
    6   0.000135   0.000071     let path = FugitiveVimPath(a:path)
    6              0.000005   endif
    6              0.000029   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 20 times
Total time:   0.003759
 Self time:   0.000674

count  total (s)   self (s)
   20   0.003741   0.000656   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>179_highlight_name_for_change()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 414 times
Total time:   0.001074
 Self time:   0.001074

count  total (s)   self (s)
  414              0.000488   if a:text ==# 'added'
  389              0.000315     return 'GitGutterLineAdded'
   25              0.000022   elseif a:text ==# 'removed'
    3              0.000002     return 'GitGutterLineRemoved'
   22              0.000018   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   22              0.000017   elseif a:text ==# 'modified'
   22              0.000017     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
                                return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  266()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/ui.vim:528
Called 15 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
   15              0.000035     return '.. (up a dir)'

FUNCTION  267()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/event.vim:6
Called 160 times
Total time:   0.002680
 Self time:   0.002680

count  total (s)   self (s)
  160              0.000687     let newObj = copy(self)
  160              0.000497     let newObj.nerdtree = a:nerdtree
  160              0.000403     let newObj.subject = a:subject
  160              0.000351     let newObj.action = a:action
  160              0.000337     let newObj.params = a:params
  160              0.000240     return newObj

FUNCTION  269()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:14
Called 160 times
Total time:   0.110913
 Self time:   0.009441

count  total (s)   self (s)
  160   0.004410   0.001729     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  320   0.005004   0.001648     for Listener in s:Notifier.GetListenersForEvent(a:event)
  160              0.001945         let l:Callback = type(Listener) == type(function('tr')) ? Listener : function(Listener)
  160   0.097526   0.002089         call l:Callback(event)
  320              0.000349     endfor

FUNCTION  <SNR>177_is_removed()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 10 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
   10              0.000023   return a:from_count > 0 && a:to_count == 0

FUNCTION  loupe#private#clear_highlight()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe/private.vim:93
Called 193 times
Total time:   0.003430
 Self time:   0.003430

count  total (s)   self (s)
  193              0.000664   if exists('w:loupe_hlmatch')
  188              0.000183     try
  188              0.000941       call matchdelete(w:loupe_hlmatch)
                                catch /\v(E802|E803)/
                                  " https://github.com/wincent/loupe/issues/1
  188              0.000215     finally
  188              0.000342       unlet w:loupe_hlmatch
  188              0.000178     endtry
  193              0.000072   endif

FUNCTION  <SNR>59_EnterWindow()
    Defined: ~/.config/nvim/autoload/plugged/vim-diminactive/plugin/diminactive.vim:340
Called 14 times
Total time:   0.004653
 Self time:   0.001545

count  total (s)   self (s)
   14              0.000057   let tabnr = a:0 > 0 ? a:1 : tabpagenr()
   14              0.000036   let winnr = a:0 > 1 ? a:2 : winnr()
   14   0.000361   0.000128   let bufnr = a:0 > 2 ? a:3 : s:bufnr(tabnr, winnr)
                            
   14   0.000352   0.000153   call s:DebugIndent('EnterWindow', {'t': tabnr, 'w': winnr, 'b': bufnr})
                            
   14   0.001020   0.000151   call s:restore_colorcolumn(tabnr, winnr, bufnr)
                            
                              " Handle left windows, after handling entering the new window, because
                              " it might derive the last set &colorcolumn setting.
   14   0.000123   0.000088   call s:Debug('Handle left window(s)')
   41              0.000103   for w in range(1, tabpagewinnr(tabnr, '$'))
   27              0.000084     if gettabwinvar(tabnr, w, 'diminactive_left_window')
    4              0.000006       if w != winnr
    4   0.001813   0.000042         call s:Leave(tabnr, w)
    4              0.000003       endif
    4              0.000039       noautocmd call settabwinvar(tabnr, w, 'diminactive_left_window', 0)
   27              0.000016     endif
   41              0.000036   endfor
   14              0.000031   let s:debug_indent-=1

FUNCTION  <SNR>58_KittyCommand()
    Defined: ~/.config/nvim/autoload/plugged/vim-kitty-navigator/plugin/kitty_navigator.vim:29
Called 1 time
Total time:   0.205434
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000009   let cmd = 'kitty @ ' . a:args
    1   0.205420   0.000034   return system(cmd)

FUNCTION  <SNR>177_process_modified()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:310
Called 6 times
Total time:   0.000100
 Self time:   0.000100

count  total (s)   self (s)
    6              0.000008   let offset = 0
   12              0.000018   while offset < a:to_count
    6              0.000011     let line_number = a:to_line + offset
    6              0.000018     call add(a:modifications, [line_number, 'modified'])
    6              0.000008     let offset += 1
   12              0.000008   endwhile

FUNCTION  loupe#hlmatch()
    Defined: ~/.config/nvim/autoload/plugged/loupe/autoload/loupe.vim:9
Called 189 times
Total time:   0.133180
 Self time:   0.129804

count  total (s)   self (s)
                              ""
                              " @option g:LoupeHighlightGroup string IncSearch
                              " Specifies the |:highlight| group used to emphasize the match currently under
                              " the cursor for the current search pattern. Defaults to "IncSearch" (ie.
                              " |hl-IncSearch|). For example:
                              "
                              " ```
                              " let g:LoupeHighlightGroup='Error'
                              " ```
                              "
                              " To prevent any special highlighting from being applied, set this option to
                              " "" (ie. the empty string).
  189              0.000817   let l:highlight=get(g:, 'LoupeHighlightGroup', 'IncSearch')
  189              0.000414   if empty(l:highlight)
                                return
  189              0.000171   endif
                            
  189              0.000361   if has('autocmd')
  189              0.000840     augroup LoupeHightlightMatch
  189              0.117695       autocmd!
  189              0.000238     augroup END
  189              0.000127   endif
                            
  189   0.005153   0.001778   call loupe#private#clear_highlight()
                            
                              " \c case insensitive
                              " \%# current cursor position
                              " @/ current search pattern
  189              0.000564   let l:pattern='\c\%#' . @/
                            
  189              0.000372   if exists('*matchadd')
  189              0.000103     try
  189              0.003957       let w:loupe_hlmatch=matchadd(l:highlight, l:pattern)
                                catch /.*/
                                  " Invalid search pattern.
  189              0.000117     endtry
  189              0.000067   endif

FUNCTION  lightline#highlight()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:263
Called 2 times
Total time:   0.004292
 Self time:   0.004193

count  total (s)   self (s)
    2              0.000013   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
    2              0.000022   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
    2              0.000040   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
    2              0.000038   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    2              0.000014   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
    4              0.000010   for mode in modes
    2              0.000007     let s:highlight[mode] = 1
    2              0.000014     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
    2              0.000012     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
    2              0.000010     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
    2              0.000024     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
    2              0.000023     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
    2              0.000021     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
    6              0.000027     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
   22              0.000064       for [i, t] in map(range(0, l), '[v:val, 0]') + types
   18              0.000032         if i < l || i < 1
   14              0.000144           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
   14   0.000622   0.000535           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
   18              0.000013         endif
  100              0.000282         for [j, s] in map(range(0, l), '[v:val, 0]') + types
   82              0.000167           if i + 1 == j || t || s && i != l
   38              0.000392             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
   38              0.000949             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
   82              0.000046           endif
  100              0.000059         endfor
   22              0.000014       endfor
    6              0.000004     endfor
    2   0.000079   0.000067     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
    4              0.000005   endfor
    2              0.000007   if !a:0 | let s:mode = '' | endif

FUNCTION  <SNR>154_FileIgnoreCase()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:136
Called 6 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    6              0.000063   return (exists('+fileignorecase') && &fileignorecase) || (a:for_completion && exists('+wildignorecase') && &wildignorecase)

FUNCTION  <SNR>177_write_buffer()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/diff.vim:375
Called 5 times
Total time:   0.000845
 Self time:   0.000845

count  total (s)   self (s)
    5              0.000273   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    5              0.000014   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    5              0.000002   endif
                            
    5              0.000014   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    5              0.000002   endif
                            
    5              0.000009   if getbufvar(a:bufnr, '&endofline')
    5              0.000010     call add(bufcontents, '')
    5              0.000002   endif
                            
    5              0.000010   let fenc = getbufvar(a:bufnr, '&fileencoding')
    5              0.000007   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    5              0.000002   endif
                            
    5              0.000008   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    5              0.000002   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    5              0.000003   try
    5              0.000397     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    5              0.000004   endtry

FUNCTION  271()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/notifier.vim:30
Called 160 times
Total time:   0.003356
 Self time:   0.001895

count  total (s)   self (s)
  160   0.002580   0.001119     let listenersMap = s:Notifier.GetListenersMap()
  160              0.000702     return get(listenersMap, a:name, [])

FUNCTION  <SNR>192_should_illuminate_file()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:157
Called 497 times
Total time:   0.027219
 Self time:   0.020404

count  total (s)   self (s)
  497              0.004997   let g:Illuminate_ftblacklist = get(g:, 'Illuminate_ftblacklist', [])
  497              0.002712   let g:Illuminate_ftwhitelist = get(g:, 'Illuminate_ftwhitelist', [])
                            
  497   0.018241   0.011425   return !s:list_contains_pat(g:Illuminate_ftblacklist, &filetype) && (empty(g:Illuminate_ftwhitelist) || s:list_contains_pat(g:Illuminate_ftwhitelist, &filetype))

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/float.vim:781
Called 480 times
Total time:   0.016391
 Self time:   0.008764

count  total (s)   self (s)
  480   0.012852   0.005225   let id = coc#float#get_related(a:winid, 'scrollbar')
  480              0.001368   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
  480              0.000302   endif

FUNCTION  <SNR>56_load()
    Defined: ~/.config/nvim/autoload/plugged/vim-projectionist/plugin/projectionist.vim:36
Called 3 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    3              0.000014   if len(a:ns) && !has_key(s:loaded, a:ns) && len(findfile('autoload/' . a:ns . '.vim', escape(&rtp, ' ')))
                                exe 'runtime! autoload/' . a:ns . '.vim'
                                let s:loaded[a:ns] = 1
    3              0.000001   endif

FUNCTION  indent_guides#calculate_guide_size()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:232
Called 17 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   17              0.000057   let l:guide_size = g:indent_guides_guide_size
                            
   17              0.000055   if l:guide_size == 0 || l:guide_size > s:indent_size
                                let l:guide_size = s:indent_size
   17              0.000009   endif
                            
   17              0.000025   return l:guide_size

FUNCTION  indent_guides#capture_highlight()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:248
Called 17 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
   17              0.000064   redir => l:output
   17              0.000752   exe "silent hi " . a:group_name
   17              0.000071   redir END
                            
   17              0.000160   let l:output = substitute(l:output, "\n", "", "")
   17              0.000030   return l:output

FUNCTION  50()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/path.vim:814
Called 3 times
Total time:   0.001284
 Self time:   0.000411

count  total (s)   self (s)
    3   0.000918   0.000045     let str = self.str()
    6              0.000036     for t in range(tabpagenr('$'))
    9              0.000035         for b in tabpagebuflist(t+1)
    6              0.000168             if str ==# expand('#' . b . ':p')
                                            return t+1
    6              0.000007             endif
    9              0.000015         endfor
    6              0.000010     endfor
    3              0.000007     return 0

FUNCTION  indent_guides#enable()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:33
Called 17 times
Total time:   0.056457
 Self time:   0.033642

count  total (s)   self (s)
   17              0.000090   let g:indent_guides_autocmds_enabled = 1
                            
   17   0.000753   0.000196   if &diff || indent_guides#exclude_filetype()
                                call indent_guides#clear_matches()
                                return
   17              0.000010   end
                            
   17   0.003268   0.000165   call indent_guides#init_script_vars()
   17   0.000367   0.000181   call indent_guides#highlight_colors()
   17   0.008600   0.000143   call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
  510              0.000668   for l:level in range(s:start_level, s:indent_levels)
  493              0.001517     let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
  493              0.001202     let l:column_start = (l:level - 1) * s:indent_size + 1
                            
                                " define the higlight patterns and add to matches list
  493              0.000686     if g:indent_guides_space_guides
  493   0.011059   0.005716       let l:soft_pattern = indent_guides#indent_highlight_pattern(g:indent_guides_soft_pattern, l:column_start, s:guide_size)
  493              0.007571       call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
  493              0.000348     end
  493              0.000723     if g:indent_guides_tab_guides
  493   0.010540   0.005371       let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
  493              0.007263       call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
  493              0.000335     end
  510              0.000336   endfor

FUNCTION  <SNR>76_get_icon()
    Defined: ~/.config/nvim/autoload/plugged/lightline-bufferline/autoload/lightline/bufferline.vim:103
Called 835 times
Total time:   0.019322
 Self time:   0.019322

count  total (s)   self (s)
  835              0.002376   if s:enable_devicons == 1 && exists('*WebDevIconsGetFileTypeSymbol')
                                return WebDevIconsGetFileTypeSymbol(fnamemodify(bufname(a:buffer), ':t'))
  835              0.002506   elseif s:enable_devicons == 1 && has('nvim-0.5') && exists('g:nvim_web_devicons')
                                return luaeval("require('bufferline')._get_icon(vim.fn.bufname(" . a:buffer . "))")
  835              0.000434   endif
                            
  835              0.001042   if s:enable_nerdfont == 1
                                try
                                  return nerdfont#find(fnamemodify(bufname(a:buffer), ':t'), 0)
                                catch /^Vim\%((\a\+)\)\=:E117:/
                                endtry
  835              0.000366   endif
                            
  835              0.000832   return ''

FUNCTION  <SNR>66_rooter()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:68
Called 12 times
Total time:   0.004718
 Self time:   0.000516

count  total (s)   self (s)
   12   0.001897   0.000134   if !s:activate() | return | endif
                            
   12              0.000054   let root = getbufvar('%', 'rootDir')
   12              0.000023   if empty(root)
    4   0.002385   0.000038     let root = s:root()
    4              0.000027     call setbufvar('%', 'rootDir', root)
   12              0.000007   endif
                            
   12              0.000018   if empty(root)
                                call s:rootless()
                                return
   12              0.000006   endif
                            
   12   0.000196   0.000104   call s:cd(root)

FUNCTION  indent_guides#process_autocmds()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:21
Called 17 times
Total time:   0.056757
 Self time:   0.000299

count  total (s)   self (s)
   17              0.000042   if g:indent_guides_autocmds_enabled
   17   0.056635   0.000178     call indent_guides#enable()
                              else
                                call indent_guides#disable()
   17              0.000012   end

FUNCTION  coc#rpc#notify()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/autoload/coc/rpc.vim:96
Called 565 times
Total time:   0.075192
 Self time:   0.013037

count  total (s)   self (s)
  565   0.009595   0.003867   if !coc#rpc#ready()
                                return ''
  565              0.000322   endif
  565   0.063420   0.006992   call s:client['notify'](a:method, a:args)
  565              0.000746   return ''

FUNCTION  doge#on_filetype_change()
    Defined: ~/.config/nvim/autoload/plugged/vim-doge/autoload/doge.vim:120
Called 3 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
                              " Check if the current filetype is an alias, if so, initialize that filetype.
    3              0.000009   if get(g:, 'doge_ignore_on_filetype_change', 0) == v:true
                                return 0
    3              0.000001   else
    3              0.000006     let l:orig_ft = &filetype
    9              0.000023     for [l:ft, l:aliases] in items(get(g:, 'doge_filetype_aliases'))
    6              0.000011       if index(l:aliases, l:orig_ft) >= 0
                                    let g:doge_ignore_on_filetype_change = 1
                                    execute('setlocal ft=' . l:ft)
                                    execute('setlocal ft=' . l:orig_ft)
                                    let g:doge_ignore_on_filetype_change = 0
                                    break
    6              0.000002       endif
    9              0.000005     endfor
    3              0.000001   endif
                            
                              " Remove conflicting doc standards from the previous filetype.
    3              0.000011   if !exists('b:doge_prev_supported_doc_standards') && exists('b:doge_supported_doc_standards')
                                " Save the current supported doc standards
    3              0.000012     let b:doge_prev_supported_doc_standards = copy(get(b:, 'doge_supported_doc_standards', []))
    3              0.000005     let b:doge_prev_ft = &filetype
                              elseif exists('b:doge_prev_supported_doc_standards') && exists('b:doge_supported_doc_standards') && get(b:, 'doge_prev_ft', '') != &filetype
                                " Remove all the doc standards from the previous filetype.
                                " If the current filetype is not an alias of the previous filetype then we
                                " will remove the doc standard.
                                for l:doc in get(b:, 'doge_prev_supported_doc_standards', [])
                                  let l:is_alias = 0
                            
                                  if (has_key(g:doge_filetype_aliases, &filetype) && index(get(g:doge_filetype_aliases, &filetype, []), b:doge_prev_ft) >= 0) || (has_key(g:doge_filetype_aliases, b:doge_prev_ft) && index(get(g:doge_filetype_aliases, b:doge_prev_ft, []), &filetype) >= 0)
                                    let l:is_alias = 1
                                  endif
                            
                                  if l:is_alias == v:false
                                    for [l:ft, l:aliases] in items(get(g:, 'doge_filetype_aliases'))
                                      if index(l:aliases, &filetype) >= 0 && index(l:aliases, b:doge_prev_ft) >= 0
                                        let l:is_alias = 1
                                        break
                                      endif
                                    endfor
                                  endif
                            
                                  if l:is_alias == v:false
                                    let l:doc_idx = index(b:doge_supported_doc_standards, l:doc)
                                    if l:doc_idx >= 0 && b:doge_prev_supported_doc_standards != b:doge_supported_doc_standards
                                      call remove(b:doge_supported_doc_standards, l:doc_idx)
                                      if has_key(get(b:, 'doge_patterns', {}), l:doc)
                                        unlet b:doge_patterns[l:doc]
                                      endif
                                    endif
                                  endif
                            
                                  let b:doge_doc_standard = get(g:, 'doge_doc_standard_' . &filetype, b:doge_supported_doc_standards[0])
                                endfor
                                let b:doge_prev_supported_doc_standards = copy(b:doge_supported_doc_standards)
                                let b:doge_prev_ft = &filetype
    3              0.000001   endif

FUNCTION  nerdtree#ui_glue#invokeKeyMap()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:408
Called 7 times
Total time:   0.420451
 Self time:   0.000273

count  total (s)   self (s)
    7   0.420430   0.000252     call g:NERDTreeKeyMap.Invoke(a:key)

FUNCTION  <SNR>49_lastplace()
    Defined: ~/.config/nvim/autoload/plugged/vim-lastplace/plugin/vim-lastplace.vim:29
Called 5 times
Total time:   0.000996
 Self time:   0.000996

count  total (s)   self (s)
    5              0.000077 	if index(split(g:lastplace_ignore_buftype, ","), &buftype) != -1 
                            		return
    5              0.000004    	endif
                            
    5              0.000045 	if index(split(g:lastplace_ignore, ","), &filetype) != -1
                            		return
    5              0.000003 	endif
                            
    5              0.000006 	try
                            		"if the file does not exist on disk (a new, unsaved file) then do nothing
    5              0.000282 		if empty(glob(@%))
                            			return
    5              0.000004 		endif
                            	catch
                            		return
    5              0.000005 	endtry
                            
    5              0.000030 	if line("'\"") > 0 && line("'\"") <= line("$")
                            		"if the last edit position is set and is less than the
                            		"number of lines in this buffer.
                            
    5              0.000031 		if line("w$") == line("$")
                            			"if the last line in the current buffer is
                            			"also the last line visible in this window
    1              0.000069 			execute "normal! g`\""
                            
    4              0.000023 		elseif line("$") - line("'\"") > ((line("w$") - line("w0")) / 2) - 1
                            			"if we're not at the bottom of the file, center the
                            			"cursor on the screen after we make the jump
    2              0.000127 			execute "normal! g`\"zz"
                            
    2              0.000001 		else
                            			"otherwise, show as much context as we can by jumping
                            			"to the end of the file and then to the mark. If we
                            			"pressed zz here, there would be blank lines at the
                            			"bottom of the screen. We intentionally leave the
                            			"last line blank by pressing <c-e> so the user has a
                            			"clue that they are near the end of the file.
    2              0.000115 			execute "normal! \G'\"\<c-e>"
    5              0.000003 		endif
    5              0.000003 	endif
    5              0.000024 	if foldclosed(".") != -1 && g:lastplace_open_folds
                            		"if we're in a fold, make the current line visible and recenter screen
                            		execute "normal! zvzz"
    5              0.000003 	endif

FUNCTION  <SNR>70_Autocmd()
    Defined: ~/.config/nvim/autoload/plugged/coc.nvim/plugin/coc.vim:245
Called 559 times
Total time:   0.081412
 Self time:   0.008051

count  total (s)   self (s)
  559              0.001459   if !g:coc_service_initialized
                                return
  559              0.000376   endif
  559   0.078489   0.005129   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 99 times
Total time:   0.001188
 Self time:   0.001188

count  total (s)   self (s)
   99              0.000344   let ggvars = getbufvar(a:buffer, 'gitgutter')
   99              0.000490   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   69              0.000134     return ggvars[a:varname]
   30              0.000018   endif
   30              0.000030   if a:0
   27              0.000032     return a:1
    3              0.000001   endif

FUNCTION  <SNR>58_KittyAwareNavigate()
    Defined: ~/.config/nvim/autoload/plugged/vim-kitty-navigator/plugin/kitty_navigator.vim:41
Called 5 times
Total time:   0.281504
 Self time:   0.000379

count  total (s)   self (s)
    5              0.000054   let nr = winnr()
    5              0.000041   let kitty_last_pane = (a:direction == 'p' && s:kitty_is_last_pane)
    5              0.000014   if !kitty_last_pane
    5   0.075777   0.000087     call s:VimNavigate(a:direction)
    5              0.000004   endif
    5              0.000022   let at_tab_page_edge = (nr == winnr())
                            
    5              0.000011   if kitty_last_pane || at_tab_page_edge
    1              0.000017     let mappings = {   "h": "left",   "j": "bottom",   "k": "top",   "l": "right" }
    1              0.000013     let args = 'kitten neighboring_window.py' . ' ' . mappings[a:direction]
    1   0.205472   0.000038     silent call s:KittyCommand(args)
    1              0.000009     let s:kitty_is_last_pane = 1
    4              0.000002   else
    4              0.000005     let s:kitty_is_last_pane = 0
    5              0.000003   endif

FUNCTION  AutoPairsTryInit()
    Defined: ~/.config/nvim/autoload/plugged/auto-pairs/plugin/auto-pairs.vim:603
Called 9 times
Total time:   0.008803
 Self time:   0.001025

count  total (s)   self (s)
    9              0.000033   if exists('b:autopairs_loaded')
    5              0.000006     return
    4              0.000003   end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
    4              0.000006   if g:AutoPairsMapCR
    4              0.000015     if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
    4              0.000315       let info = maparg('<CR>', 'i', 0, 1)
    4              0.000010       if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
    4              0.000004       else
    4              0.000012         let old_cr = info['rhs']
    4   0.000144   0.000047         let old_cr = s:ExpandMap(old_cr)
    4              0.000035         let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
    4              0.000011         let is_expr = info['expr']
    4              0.000009         let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
    4              0.000003       endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
    4              0.000003     end
                            
    4              0.000018     if old_cr !~ 'AutoPairsReturn'
    4              0.000005       if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
    4              0.000182         execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
    4              0.000010         let old_cr = wrapper_name
    4              0.000003       end
                                  " Always silent mapping
    4              0.000117       execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
    4              0.000003     end
    4              0.000002   endif
    4   0.007722   0.000042   call AutoPairsInit()

FUNCTION  <SNR>82_filename()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/utility.vim:219
Called 3 times
Total time:   0.000119
 Self time:   0.000016

count  total (s)   self (s)
    3   0.000118   0.000015   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  <SNR>68_DevIconsGetArtifactFix()
    Defined: ~/.config/nvim/autoload/plugged/vim-devicons/plugin/webdevicons.vim:544
Called 320 times
Total time:   0.003464
 Self time:   0.003464

count  total (s)   self (s)
  320              0.000755   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
  320              0.000254   else
  320              0.000656     let artifactFix = ''
  320              0.000229   endif
                            
  320              0.000566   return artifactFix

FUNCTION  <SNR>66_current()
    Defined: ~/.config/nvim/autoload/plugged/vim-rooter/plugin/rooter.vim:208
Called 4 times
Total time:   0.000451
 Self time:   0.000163

count  total (s)   self (s)
    4              0.000055   let fn = expand('%:p', 1)
    4   0.000343   0.000055   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
    4              0.000019   if empty(fn) | return getcwd() | endif  " opening vim without a file
    4              0.000015   if g:rooter_resolve_links | let fn = resolve(fn) | endif
    4              0.000014   return fnamemodify(fn, ':h')

FUNCTION  polyglot#ft#FTheader()
    Defined: ~/.config/nvim/autoload/plugged/vim-polyglot/autoload/polyglot/ft.vim:110
Called 2 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    2              0.000080   if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
    2              0.000004   elseif exists("g:c_syntax_for_h")
                                setf c
    2              0.000002   elseif exists("g:ch_syntax_for_h")
                                setf ch
    2              0.000001   else
    2              0.000001     setf cpp
    2              0.000001   endif

FUNCTION  illuminate#on_leaving_autocmds()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:40
Called 15 times
Total time:   0.002423
 Self time:   0.000493

count  total (s)   self (s)
   15   0.001221   0.000249   if s:should_illuminate_file()
   15   0.001167   0.000209     call s:remove_illumination()
   15              0.000013   endif

FUNCTION  <SNR>192_get_cur_word()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:124
Called 1191 times
Total time:   0.050447
 Self time:   0.050447

count  total (s)   self (s)
 1191              0.004730   let line = getline('.')
 1191              0.003770   let col = col('.') - 1
 1191              0.005413   let left_part = strpart(line, 0, col + 1)
 1191              0.005020   let right_part = strpart(line, col, col('$'))
 1191              0.023585   let word = matchstr(left_part, '\k*$') . matchstr(right_part, '^\k*')[1:]
                            
 1191              0.005756   return '\<' . escape(word, '/\') . '\>'

FUNCTION  145()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/lib/nerdtree/tree_dir_node.vim:141
Called 66 times
Total time:   0.049527
 Self time:   0.000453

count  total (s)   self (s)
   66   0.049385   0.000311     if !self.isCascadable()
   66              0.000106         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  <SNR>131_Remove_Matches()
    Defined: /usr/share/nvim/runtime/plugin/matchparen.vim:197
Called 510 times
Total time:   0.006063
 Self time:   0.006063

count  total (s)   self (s)
  510              0.002468   if exists('w:paren_hl_on') && w:paren_hl_on
   22              0.000239     silent! call matchdelete(3)
   22              0.000083     let w:paren_hl_on = 0
  510              0.000366   endif

FUNCTION  <SNR>56_nscall()
    Defined: ~/.config/nvim/autoload/plugged/vim-projectionist/plugin/projectionist.vim:43
Called 32 times
Total time:   0.000352
 Self time:   0.000352

count  total (s)   self (s)
   32              0.000077   if len(a:ns) && !get(g:, 'projectionist_ignore_' . a:ns) && exists('*' . a:ns . '#' . a:fn)
                                return call(a:ns . '#' . a:fn, [a:path] + a:000)
   32              0.000011   else
   32              0.000203     return call(a:fn, [a:path] + a:000)
                              endif

FUNCTION  <SNR>118_activateFileNode()
    Defined: ~/.config/nvim/autoload/plugged/nerdtree/autoload/nerdtree/ui_glue.vim:146
Called 3 times
Total time:   0.200246
 Self time:   0.000145

count  total (s)   self (s)
    3   0.200240   0.000139     call a:node.activate({'reuse': 'all', 'where': 'p', 'keepopen': !nerdtree#closeTreeOnOpen()})

FUNCTION  <SNR>84_CeilingDirectories()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/plugin/fugitive.vim:239
Called 22 times
Total time:   0.000334
 Self time:   0.000334

count  total (s)   self (s)
   22              0.000044   if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
   22              0.000007   endif
   22              0.000059   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  <SNR>192_remove_illumination()
    Defined: ~/.config/nvim/autoload/plugged/vim-illuminate/autoload/illuminate.vim:134
Called 726 times
Total time:   0.035573
 Self time:   0.035573

count  total (s)   self (s)
  726              0.005573   if has('timers') && exists('s:timer_id') && s:timer_id > -1
                                call timer_stop(s:timer_id)
                                let s:timer_id = -1
  726              0.000489   endif
                            
  726              0.001830   if exists('w:match_id')
  717              0.000821     try
  717              0.007397       call matchdelete(w:match_id)
  433              0.004730     catch /\v(E803|E802)/
  717              0.001159     endtry
  726              0.000449   endif
                            
  726              0.002030   if exists('w:match_curword_id')
                                try
                                  call matchdelete(w:match_curword_id)
                                catch /\v(E803|E802)/
                                endtry
  726              0.000386   endif
                            
  726              0.001582   let s:previous_match = ''

FUNCTION  lightline#statusline()
    Defined: ~/.config/nvim/autoload/plugged/lightline.vim/autoload/lightline.vim:309
Called 27 times
Total time:   0.034171
 Self time:   0.000596

count  total (s)   self (s)
   27              0.000105   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
   27              0.000017   endif
   27   0.033967   0.000393   return s:line(0, a:inactive)

FUNCTION  quick_scope#StopTimer()
    Defined: ~/.config/nvim/autoload/plugged/quick-scope/autoload/quick_scope.vim:55
Called 16 times
Total time:   0.000260
 Self time:   0.000260

count  total (s)   self (s)
   16              0.000104   if g:qs_delay > 0
   16              0.000096     call timer_stop(s:timer)
   16              0.000024   endif

FUNCTION  <SNR>178_reset_summary()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 5 times
Total time:   0.000123
 Self time:   0.000052

count  total (s)   self (s)
    5   0.000119   0.000048   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>154_TempReadPre()
    Defined: ~/.config/nvim/autoload/plugged/vim-fugitive/autoload/fugitive.vim:2466
Called 3 times
Total time:   0.000448
 Self time:   0.000178

count  total (s)   self (s)
    3   0.000347   0.000077   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                if empty(&bufhidden)
                                  setlocal bufhidden=delete
                                endif
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                let b:git_dir = dict.dir
                                if len(dict.dir)
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
    3              0.000003   endif

FUNCTION  <SNR>68_CursorHoldUpdate()
    Defined: ~/.config/nvim/autoload/plugged/vim-devicons/plugin/webdevicons.vim:399
Called 6 times
Total time:   0.219181
 Self time:   0.000718

count  total (s)   self (s)
    6              0.000059   if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
    6              0.000009   endif
                            
    6   0.000706   0.000160   if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
    6              0.000008   endif
                            
                              " Do not update when a special buffer is selected
    6              0.000057   if !empty(&l:buftype)
    2              0.000005     return
    4              0.000004   endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
    4              0.000030   let l:winnr = winnr()
    4              0.000022   let l:altwinnr = winnr('#')
                            
    4   0.001099   0.000069   call g:NERDTree.CursorToTreeWin()
    4   0.145474   0.000089   call b:NERDTree.root.refreshFlags()
    4   0.071544   0.000043   call NERDTreeRender()
                            
    4              0.000020   exec l:altwinnr . 'wincmd w'
    4              0.000042   exec l:winnr . 'wincmd w'

FUNCTION  indent_guides#clear_matches()
    Defined: ~/.config/nvim/autoload/plugged/vim-indent-guides/autoload/indent_guides.vim:75
Called 17 times
Total time:   0.008457
 Self time:   0.008316

count  total (s)   self (s)
   17   0.000290   0.000148   call indent_guides#init_matches()
   17              0.000046   if !empty(w:indent_guides_matches)
   16              0.000028     let l:index = 0
  944              0.000727     for l:match_id in w:indent_guides_matches
  928              0.000431       try
  928              0.001898         call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
  928              0.000443       endtry
  928              0.001720       call remove(w:indent_guides_matches, l:index)
  928              0.001204       let l:index += l:index
  944              0.000472     endfor
   17              0.000012   endif

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.config/nvim/autoload/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 5 times
Total time:   0.000368
 Self time:   0.000096

count  total (s)   self (s)
    5   0.000201   0.000053   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    5   0.000161   0.000038   call s:reset_summary(a:bufnr)

FUNCTION  floaterm#buflist#gather()
    Defined: ~/.config/nvim/autoload/plugged/vim-floaterm/autoload/floaterm/buflist.vim:216
Called 1 time
Total time:   0.000021
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000020   0.000006   return s:buflist.gather()

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  242   0.645268   0.105021  <SNR>159_line()
  215   0.619974   0.008280  lightline#tabline()
  484   0.524058   0.070638  <SNR>159_expand()
  609   0.453420   0.013516  <SNR>159_convert()
  215   0.439904   0.012404  <SNR>159_evaluate_expand()
  215   0.422517   0.016116  lightline#bufferline#buffers()
    7   0.420451   0.000273  nerdtree#ui_glue#invokeKeyMap()
    7   0.420178   0.001152  81()
  629   0.367724   0.038634  <SNR>76_get_buffer_names()
   39   0.364184   0.117634  167()
  219   0.344287   0.288836  136()
    7   0.340565   0.000358  80()
    5   0.281504   0.000379  <SNR>58_KittyAwareNavigate()
   48   0.221777   0.002985  quick_scope#HighlightLineDelayCallback()
    6   0.219181   0.000718  <SNR>68_CursorHoldUpdate()
  629   0.206837             <SNR>76_get_buffer_paths()
    1   0.205434   0.000049  <SNR>58_KittyCommand()
  481   0.203958   0.035928  illuminate#on_cursor_moved()
   48   0.203170   0.006805  quick_scope#HighlightLine()
    3   0.200246   0.000145  <SNR>118_activateFileNode()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  219   0.344287   0.288836  136()
  629              0.206837  <SNR>76_get_buffer_paths()
   92   0.192082   0.177152  <SNR>158_get_highlight_patterns()
  189   0.133180   0.129804  loupe#hlmatch()
   39   0.364184   0.117634  167()
  242   0.645268   0.105021  <SNR>159_line()
  505   0.099479   0.093480  <SNR>131_Highlight_Matching_Pair()
 1166   0.165567   0.080563  43()
  835   0.122253   0.078346  <SNR>76_get_buffer_name()
  484   0.524058   0.070638  <SNR>159_expand()
    3   0.193476   0.068484  18()
  565   0.056428   0.052054  <SNR>73_notify()
 1191              0.050447  <SNR>192_get_cur_word()
 1951   0.049785   0.045494  lightline#link()
  629   0.367724   0.038634  <SNR>76_get_buffer_names()
  160   0.038936   0.037224  WebDevIconsGetFileTypeSymbol()
  481   0.203958   0.035928  illuminate#on_cursor_moved()
  726              0.035573  <SNR>192_remove_illumination()
   17   0.056457   0.033642  indent_guides#enable()
 1132   0.072494   0.033457  48()

